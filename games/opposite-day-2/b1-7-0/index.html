<!DOCTYPE HTML>
<html>

<body>
    <canvas id="canvas"></canvas>
    <script src="https://johnbutlergames.w3spaces.com/game-setup.js"></script>
    <script src="levels.js"></script>
    <style>
        @font-face {
            font-family: rubik;
            src: url("fonts/Rubik-Regular.ttf");
        }

        @font-face {
            font-family: rubikbold;
            src: url("fonts/Rubik-SemiBold.ttf");
        }
    </style>
    <script>
        var title = "Opposite Day 2";
        var dimensions = { width: 1000, height: 1000 };
        var images = {
            "circlesBackground": "images/circles-background.png",
            "pingPongBackground": "images/ping-pong-background.png",
            "snakeBackground": "images/snake-background.png",
            "sokobanBackground": "images/sokoban-background.png",
            "sokobanCubeBackground": "images/sokoban-cube-background.png",
            "sokobanBox": "images/sokoban-box.png",
            "sokobanBlueBox": "images/sokoban-blue-box.png",
            "sokobanBlueBoxLit": "images/sokoban-blue-box-lit.png",
            "jumpEnemy": "images/jump-enemy.png",
            "greenSparkle": "images/green-sparkle.png",
            "arrows": "images/keys-arrows.png",
            "wasd": "images/keys-wasd.png",
            "circuitRed": "images/circuit-red.png",
            "circuitBlack": "images/circuit-black.png",
            "checkmark": "images/checkmark.png",
            "redCube": "images/red-cube.png",
            "blueCube": "images/blue-cube.png",
            "uncollectedCube": "images/uncollected-cube.png",
            "lock": "images/lock.png",
            "level1": "images/level1.png",
            "level2": "images/level2.png",
            "level3": "images/level3.png",
            "level4": "images/level4.png",
            "level5": "images/level5.png",
            "level6": "images/level6.png",
        };
        var audios = {};

        initialize();
        window.setInterval(update, 10);
        var t = 0;

        function main() {
            menu.tick();
            t++;
        }

        var menu = {
            titleScreen: true,
            levelSelectScreen: false,
            levelSelectAnimation: 0,
            wipeSaveScreen: false,
            wipeSaveAnimation: 0,
            titleScreenAnimation: 0,
            firstButtonAnimation: 0,
            secondButtonAnimation: 0,
            backButtonAnimation: 0,
            newGameAnimation: 0,
            loadingLevel: false,
            loadingLevelAnimation: 0,
            levelSelectAnimations: [],
            tick: function () {
                this.update();
                this.draw();
            },
            update: function () {
                if (this.titleScreen) {
                    this.updateTitleScreen();
                } else {
                    game.update();
                }
            },
            draw: function () {
                if (this.titleScreen) {
                    this.drawTitleScreen();
                } else {
                    game.draw();
                }
            },
            updateTitleScreen: function () {
                if (this.levelSelectScreen) {
                    this.levelSelectAnimation++;
                } else {
                    this.levelSelectAnimation--;
                }
                this.levelSelectAnimation = Math.max(Math.min(this.levelSelectAnimation, 40), 0);

                if (this.wipeSaveScreen) {
                    this.wipeSaveAnimation++;
                } else {
                    this.wipeSaveAnimation--;
                }
                this.wipeSaveAnimation = Math.max(Math.min(this.wipeSaveAnimation, 40), 0);

                if (this.newGameAnimation) {
                    this.newGameAnimation++;
                    var speed = Math.min(this.newGameAnimation, (-180 - game.cam.y) / 10);
                    game.cam.y += speed;
                    game.cam.y = Math.min(game.cam.y, -200);
                    game.cam.x = 0 * 0.05 + game.cam.x * 0.95;
                    if (this.newGameAnimation > 80) {
                        this.titleScreen = false;
                    }
                    return;
                }
                if (this.loadingLevelAnimation) {
                    this.loadingLevelAnimation++;
                    if (this.loadingLevelAnimation > 80) {
                        this.titleScreen = false;
                        game.level.load(this.loadingLevel);
                        game.level.levelTransition = game.level.levelTransitionCap;
                    }
                }
                if (this.loadingLevelAnimation < 80) {
                    this.titleScreenAnimation++;
                    game.cam.x = (t / 5 % (350 * 2 / 0.8));
                    game.cam.y = -2000 + (t % (350 * 2 / 0.8));
                }

                var text1 = "Not New Game";
                var text2 = false;
                if (saveDataStored) {
                    text1 = "Don't Continue";
                    text2 = "Not New Game";
                }
                ctx.font = "70px rubik";
                var width = ctx.measureText(text1).width;
                if (Mouse.inBox(500 - width / 2, 460 - 70 / 2 - 10, width, 70 + 20) && !this.levelSelectAnimation) {
                    this.firstButtonAnimation++;
                    if (Mouse.click) {
                        if (this.wipeSaveScreen) {
                            game.newGameFromMenu = true;
                            game.newGame();
                            this.newGameAnimation = 1;
                        } else {
                            if (text1 == "Don't Continue") {
                                this.levelSelectScreen = true;
                                Mouse.click = false;
                            } else {
                                game.newGameFromMenu = true;
                                game.newGame();
                                this.newGameAnimation = 1;
                            }
                        }
                    }
                } else {
                    this.firstButtonAnimation--;
                }
                var width = ctx.measureText(text2).width;
                if (Mouse.inBox(500 - width / 2, 600 - 70 / 2 - 10, width, 70 + 20) && (text2 || this.wipeSaveAnimation) && !this.levelSelectAnimation) {
                    this.secondButtonAnimation++;
                    if (Mouse.click) {
                        this.wipeSaveScreen = !this.wipeSaveScreen;
                    }
                } else {
                    this.secondButtonAnimation--;
                }
                var width = ctx.measureText("Not Back").width;
                if (Mouse.inBox(500 - width / 2, 900 - 70 / 2 - 10, width, 70 + 20) && this.levelSelectAnimation && !this.loadingLevel) {
                    this.backButtonAnimation++;
                    if (Mouse.click) {
                        this.levelSelectScreen = false;
                    }
                } else {
                    this.backButtonAnimation--;
                }
                this.firstButtonAnimation = Math.min(Math.max(0, this.firstButtonAnimation), 15);
                this.secondButtonAnimation = Math.min(Math.max(0, this.secondButtonAnimation), 15);
                this.backButtonAnimation = Math.min(Math.max(0, this.backButtonAnimation), 15);

                this.updateLevelSelectScreen();
                this.updateWipeSaveScreen();
            },
            drawTitleScreen: function () {
                game.draw();

                ctx.save();
                if (this.levelSelectAnimation) {
                    var a = easeInOut(this.levelSelectAnimation / 40);
                    ctx.translate(-a * 1000, 0);
                }
                if (this.wipeSaveAnimation) {
                    var a = easeInOut(this.wipeSaveAnimation / 40);
                    ctx.translate(a * 1000, 0);
                }

                if (this.titleScreenAnimation < 20) {
                    ctx.save();
                    ctx.fillStyle = "white";
                    ctx.globalAlpha = 1 - this.titleScreenAnimation / 20;
                    ctx.fillRect(0, 0, 1000, 1000);
                    ctx.restore();
                }

                ctx.fillStyle = "black";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "100px rubikbold";

                var fade = 1 - easeInOut(this.newGameAnimation / 40);

                var a = easeInOut((this.titleScreenAnimation - 20) / 40) * fade;
                ctx.save();
                ctx.translate(500, 200);
                ctx.scale(a, a);
                ctx.fillText("Opposite Day 2", 0, 0);
                ctx.restore();

                var text1 = "Not New Game";
                var text2 = false;
                if (saveDataStored) {
                    text1 = "Don't Continue";
                    text2 = "Not New Game";
                }
                ctx.font = "70px rubik";
                var a = easeInOut((this.titleScreenAnimation - 70) / 40) * (1 + easeInOut(this.firstButtonAnimation / 15) * 0.1) * fade;
                ctx.save();
                ctx.translate(500, 460);
                ctx.scale(a, a);
                ctx.fillText(text1, 0, 0);
                ctx.globalAlpha = this.firstButtonAnimation / 15;
                ctx.fillText(`[  ${text1}  ]`, 0, 0);
                ctx.restore();

                if (text2) {
                    var a = easeInOut((this.titleScreenAnimation - 90) / 40) * (1 + easeInOut(this.secondButtonAnimation / 15) * 0.1) * fade;
                    ctx.save();
                    ctx.translate(500, 600);
                    ctx.scale(a, a);
                    ctx.fillText(text2, 0, 0);
                    ctx.globalAlpha = this.secondButtonAnimation / 15;
                    ctx.fillText(`[  ${text2}  ]`, 0, 0);
                    ctx.restore();
                }

                ctx.font = "40px rubik";
                var a = easeInOut((this.titleScreenAnimation - 120) / 40) * fade;
                ctx.save();
                ctx.translate(500, 940);
                ctx.scale(a, a);
                ctx.fillText("Not by John Butler", 0, 0);
                ctx.restore();

                this.drawLevelSelectScreen(fade);
                this.drawWipeSaveScreen(fade);

                ctx.restore();
            },
            updateWipeSaveScreen: function () {

            },
            drawWipeSaveScreen: function (fade) {
                ctx.font = "100px rubikbold";
                ctx.save();
                ctx.translate(-500, 200);
                ctx.scale(fade, fade);
                ctx.fillText("Aren't You Sure?", 0, 0);
                ctx.restore();

                ctx.font = "40px rubik";
                ctx.save();
                ctx.translate(-500, 305);
                ctx.scale(fade, fade);
                ctx.fillText("This action will permanently", 0, -25);
                ctx.fillText("undelete your past progress.", 0, 25);
                ctx.restore();

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.firstButtonAnimation / 15) * 0.1) * fade;
                ctx.save();
                ctx.translate(-500, 460);
                ctx.scale(a, a);
                ctx.fillText("Unproceed", 0, 0);
                ctx.globalAlpha = this.firstButtonAnimation / 15;
                ctx.fillText(`[  Unproceed  ]`, 0, 0);
                ctx.restore();

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.secondButtonAnimation / 15) * 0.1) * fade;
                ctx.save();
                ctx.translate(-500, 600);
                ctx.scale(a, a);
                ctx.fillText("Uncancel", 0, 0);
                ctx.globalAlpha = this.secondButtonAnimation / 15;
                ctx.fillText(`[  Uncancel  ]`, 0, 0);
                ctx.restore();
            },
            updateLevelSelectScreen: function () {
                if (this.levelSelectAnimations.length == 0) {
                    for (var n = 0; n < 10; n++) {
                        this.levelSelectAnimations.push({ shake: 0, selected: 0, hover: 0 });
                    }
                }
                if (this.loadingLevel === false) {
                    if (this.levelSelectScreen) {
                        for (var n = 0; n < 10; n++) {
                            var x = n % 5;
                            var y = Math.floor(n / 5);
                            var box = { x: 150 + x * 150, y: 430 + y * 200, w: 100, h: 100 };
                            if (Mouse.inBox(box.x, box.y, box.w, box.h)) {
                                if (saveData.levelsBeaten > n - 1) {
                                    if (Mouse.click) {
                                        this.levelSelectAnimations[n].selected = 1;
                                        this.loadingLevel = n;
                                        this.loadingLevelAnimation = 1;
                                    } else {
                                        this.levelSelectAnimations[n].hover++;
                                    }
                                } else {
                                    this.levelSelectAnimations[n].hover += 0.3;
                                    if (Mouse.click) {
                                        this.levelSelectAnimations[n].shake = 40;
                                    }
                                }
                            } else {
                                this.levelSelectAnimations[n].hover -= 0.1;
                            }
                        }
                    } else {
                        for (var n = 0; n < 10; n++) {
                            this.levelSelectAnimations[n].hover--;
                        }
                    }
                }
                for (var n = 0; n < 10; n++) {
                    if (this.levelSelectAnimations[n].selected) {
                        this.levelSelectAnimations[n].selected++;
                    }
                    if (this.loadingLevel === false) {
                        this.levelSelectAnimations[n].hover *= 0.85;
                        this.levelSelectAnimations[n].hover = Math.max(this.levelSelectAnimations[n].hover, 0);
                    }
                    this.levelSelectAnimations[n].shake--;
                    this.levelSelectAnimations[n].shake = Math.max(this.levelSelectAnimations[n].shake, 0);
                }
            },
            drawLevelSelectScreen: function (fade) {
                ctx.font = "100px rubikbold";
                ctx.fillText("Level Deselect", 1500, 200);

                ctx.font = "40px rubik";
                var percentComplete;
                var barPercent;
                if (!saveData) {
                    barPercent = 0;
                    percentComplete = 0;
                } else {
                    var levelAmount = 10;
                    var levelsComplete = saveData.levelsBeaten / levelAmount;
                    var blueCubes = saveData.cubesCollected.filter(e => e === true).length / levelAmount;
                    var redCubes = saveData.redCubesCollected.filter(e => e === true).length / levelAmount;
                    percentComplete = levelsComplete * 0.75 + blueCubes * 0.25 + redCubes * 0.25;
                    barPercent = levelsComplete * 0.75 + blueCubes * 0.25;
                }
                if (isNaN(percentComplete)) percentComplete = 0;
                var percentCompleteText = Math.floor(percentComplete * 100);
                ctx.fillText(percentCompleteText + "% Incomplete", 1500, 350);

                ctx.lineCap = "round";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 20;
                ctx.beginPath();
                ctx.moveTo(1200, 300);
                ctx.lineTo(1800, 300);
                ctx.stroke();
                if (redCubes) {
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 15;
                    ctx.beginPath();
                    ctx.moveTo(1250, 308.5);
                    ctx.lineTo(1250 + 500, 308.5);
                    ctx.stroke();
                    ctx.strokeStyle = "rgb(255,100,100)";
                    ctx.lineWidth = 7;
                    ctx.beginPath();
                    ctx.moveTo(1250, 308.5);
                    ctx.lineTo(1250 + 500 * redCubes, 308.5);
                    ctx.stroke();
                }
                ctx.strokeStyle = "rgb(100,100,255)";
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(1200, 300);
                ctx.lineTo(1200 + 600 * barPercent, 300);
                ctx.stroke();

                for (var n = 0; n < levelAmount; n++) {
                    var x = n % 5;
                    var y = Math.floor(n / 5);
                    ctx.save();
                    ctx.translate(1150 + x * 150, 430 + y * 200);
                    var s = 1 + this.levelSelectAnimations[n].hover * 0.03;
                    s -= 0.5 * easeInOut(this.levelSelectAnimations[n].selected / 20);
                    ctx.translate(50, 50);
                    ctx.scale(s, s);
                    if (this.levelSelectAnimations[n].shake) {
                        ctx.rotate(Math.sin(t / 3) * this.levelSelectAnimations[n].shake / 3 * Math.PI / 180);
                    }
                    ctx.translate(-50, -50);

                    if (saveData.levelsBeaten > n - 1) {
                        ctx.fillStyle = "white";
                    } else {
                        ctx.fillStyle = "rgb(200,200,200)";
                    }
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 4;
                    ctx.lineJoin = "round";
                    ctx.lineCap = "round";
                    ctx.fillRect(0, 0, 100, 100);
                    if (saveData.levelsBeaten > n - 1) {
                        if (images["level" + (n + 1)]) ctx.drawImage(images["level" + (n + 1)], 0, 0, 100, 100);
                    } else {
                        ctx.drawImage(images.lock, 0, 0, 100, 100);
                    }
                    ctx.strokeRect(0, 0, 100, 100);

                    if (saveData.levelsBeaten > n) {
                        ctx.drawImage(images.checkmark, 80, -20, 40, 40);
                    }

                    if (saveData.levelsBeaten > n - 1) {
                        if (saveData.redCubesCollected[n]) {
                            ctx.drawImage(images.redCube, 55, 110, 45, 45);
                            if (saveData.cubesCollected[n]) {
                                ctx.drawImage(images.blueCube, 5, 110, 45, 45);
                            } else {
                                ctx.drawImage(images.uncollectedCube, 5, 110, 45, 45);
                            }
                        } else {
                            if (saveData.cubesCollected[n]) {
                                ctx.drawImage(images.blueCube, 27.5, 110, 45, 45);
                            } else {
                                ctx.drawImage(images.uncollectedCube, 27.5, 110, 45, 45);
                            }
                        }
                    }

                    ctx.restore();
                }

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.backButtonAnimation / 15) * 0.1);
                ctx.save();
                ctx.translate(1500, 900);
                ctx.scale(a, a);
                ctx.fillText("Not Back", 0, 0);
                ctx.globalAlpha = this.backButtonAnimation / 15;
                ctx.fillText(`[  Not Back  ]`, 0, 0);
                ctx.restore();

                if (this.loadingLevelAnimation) {
                    var a = easeInOut(this.loadingLevelAnimation / 80);
                    var radius = (1 - a) * 1500;
                    var cors = {};
                    var n = this.loadingLevel;
                    cors.x = 1150 + n % 5 * 150 + 50;
                    cors.y = 430 + Math.floor(n / 5) * 200 + 50;
                    var grd = ctx.createRadialGradient(cors.x, cors.y, radius, cors.x, cors.y, radius + 20);
                    grd.addColorStop(0, "rgba(0,0,0,0)");
                    grd.addColorStop(1, "rgba(0,0,0,1)");
                    ctx.fillStyle = grd;
                    ctx.fillRect(1000, 0, 1000, 1000);

                    ctx.save();
                    ctx.fillStyle = "black";
                    ctx.globalAlpha = easeInOut((a - 0.99) * 100);
                    ctx.fillRect(1000, 0, 1000, 1000);
                    ctx.restore();
                }
            }
        }

        var game = {
            newGameFromMenu: false,
            backgroundOffset: {
                x: 0,
                y: 0,
            },
            backgroundOpacity: 1,
            update: function () {
                var transitionPercent = this.level.levelTransition / this.level.levelTransitionCap;
                if (transitionPercent < 0.5) {
                    this.objects.update();
                    this.input.update();
                    this.cam.update();
                    this.particles.update();
                }
                this.level.update();

                this.backgroundOffset.x %= 700;
                this.backgroundOffset.y %= 700;
                this.background.update();
            },
            draw: function () {
                ctx.save();
                this.cam.alignViewport();

                this.background.draw();
                this.objects.draw();
                this.particles.draw();

                ctx.restore();

                this.level.drawLevelTransition();
            },
            newGame: function () {
                saveData = {
                    levelsBeaten: 0,
                    cubesCollected: [],
                    redCubesCollected: []
                };
                deleteSaveData();
                this.level.load(0);
            },
            background: {
                effect: {
                    active: false,
                    time: 0,
                    type: "",
                    alpha: 0,
                    radius: 0,
                    origin: { x: 0, y: 0 },
                    color: "",
                    start: function (type, origin) {
                        this.active = true;
                        this.type = type;
                        var color = type;
                        if (color == "blue") {
                            color = "rgba(50,120,255,0.3)";
                        } else if (color == "red") {
                            color = "rgba(255,100,100,0.4)";
                        } else if (color == "green") {
                            color = "rgba(0,200,50,0.3)";
                        } else if (color == "purple") {
                            color = "rgba(170,80,255,0.5)";
                        }
                        this.color = color;
                        this.alpha = 1;
                        this.radius = 20;
                        if (origin) {
                            this.origin = { x: origin.x, y: origin.y };
                        } else {
                            var player = game.objects.objects.find(e => e.type == "player");
                            if (player) {
                                var x = player.x + player.w / 2;
                                var y = player.y + player.h / 2;
                                this.origin = { x: x, y: y };
                            }
                        }
                    },
                    end: function () {
                        this.active = false;
                    }
                },
                update: function () {
                    if (this.effect.active) {
                        this.effect.radius *= 1.1;
                        this.effect.radius = Math.min(this.effect.radius, 5000);
                        this.effect.alpha -= 0.02;
                        this.effect.alpha = Math.max(this.effect.alpha, 0);
                        this.effect.time++;
                    } else {
                        this.effect.time = 0;
                    }
                },
                draw: function () {
                    if (game.backgroundOpacity == 0) return;

                    var distance = 0.2;
                    var tileSize = 700;
                    var viewportSize = 1000 / game.cam.zoom;
                    var tileCount = Math.ceil(viewportSize / tileSize) * 2;
                    var xOffsetDigit = Math.floor(game.cam.x * (1 - distance) / (tileSize * 2));
                    var yOffsetDigit = Math.floor(game.cam.y * (1 - distance) / (tileSize * 2));
                    var xOffset = Math.floor(game.cam.x * (1 - distance) / (tileSize * 2)) * tileSize * 2 + game.cam.x * distance + game.backgroundOffset.x;
                    var yOffset = Math.floor(game.cam.y * (1 - distance) / (tileSize * 2)) * tileSize * 2 + game.cam.y * distance + game.backgroundOffset.y;

                    ctx.save();
                    ctx.translate(xOffset, yOffset);
                    ctx.translate(-tileCount / 2 * tileSize, -tileCount / 2 * tileSize);
                    ctx.globalAlpha = game.backgroundOpacity;

                    for (var x = -2; x < tileCount + 2; x++) {
                        for (var y = -2; y < tileCount + 2; y++) {
                            var xCor = x + xOffsetDigit * 2;
                            var yCor = y + yOffsetDigit * 2;

                            ctx.save();
                            ctx.translate(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2);

                            ctx.fillStyle = "rgb(245,245,245)";
                            for (var x2 = 0; x2 < 2; x2++) {
                                for (var y2 = 0; y2 < 2; y2++) {
                                    ctx.save();
                                    ctx.translate(x2 * tileSize / 2, y2 * tileSize / 2);
                                    if ((x2 + y2) % 2 == 0) {
                                        ctx.scale(0.4, 0.4);
                                        ctx.rotate(45 * Math.PI / 180);
                                        if (this.effect.active && this.effect.type == "red") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.rotate(90 * Math.PI / 180 * s);
                                        }
                                        ctx.fillRect(-tileSize / 2.5, -tileSize / 2.5, tileSize / 1.25, tileSize / 1.25);
                                        if (this.effect.active && this.effect.type == "red") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.globalAlpha = easeInBack(s);
                                            ctx.fillStyle = "rgba(255,100,100,0.4)";
                                            ctx.fillRect(-tileSize / 2.5, -tileSize / 2.5, tileSize / 1.25, tileSize / 1.25);
                                            ctx.globalAlpha = 1;
                                            ctx.fillStyle = "black";
                                            ctx.font = "50px Arial";
                                        }
                                        if (this.effect.active && this.effect.type == "green") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + x2 * 56 + y2 * 78 + Math.floor(Math.sin(xCor / 3) * 100) + Math.floor(Math.sin(yCor / 3) * 150);
                                            var a = Math.min(Math.max(Math.sin(time / 30) - 0.6, 0) * 1.5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 20;
                                            ctx.strokeStyle = "rgba(0,255,0,0.4)";
                                            ctx.strokeRect(-tileSize / 2.5 - 10, -tileSize / 2.5 - 10, tileSize / 1.25 + 20, tileSize / 1.25 + 20);
                                        }
                                        if (this.effect.active && this.effect.type == "blue") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + x2 * 30 + y2 * 10 + xCor * 60 + yCor * 20;
                                            var a = Math.min(Math.max(Math.sin(time / 60) - 0.8, 0) * 5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 20;
                                            ctx.strokeStyle = "rgba(0,0,255,0.5)";
                                            ctx.strokeRect(-tileSize / 2.5 - 10, -tileSize / 2.5 - 10, tileSize / 1.25 + 20, tileSize / 1.25 + 20);
                                            ctx.fillStyle = "rgba(0,0,255,0.1)";
                                            ctx.fillRect(-tileSize / 2.5, -tileSize / 2.5, tileSize / 1.25, tileSize / 1.25);
                                        }
                                    } else {
                                        ctx.scale(0.3, 0.3);
                                        if (this.effect.active && this.effect.type == "red") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.rotate(-90 * Math.PI / 180 * s);
                                        }
                                        ctx.fillRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        if (this.effect.active && this.effect.type == "red") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.globalAlpha = easeInBack(s);
                                            ctx.fillStyle = "rgba(255,100,100,0.4)";
                                            ctx.fillRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        }
                                        if (this.effect.active && this.effect.type == "green") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + x2 * 56 + y2 * 78 + Math.floor(Math.sin(xCor / 3) * 100) + Math.floor(Math.sin(yCor / 3) * 150);
                                            var a = Math.min(Math.max(Math.sin(time / 30) - 0.6, 0) * 1.5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 20;
                                            ctx.strokeStyle = "rgba(0,255,0,0.4)";
                                            ctx.strokeRect(-tileSize / 2 - 10, -tileSize / 2 - 10, tileSize + 20, tileSize + 20);
                                        }
                                        if (this.effect.active && this.effect.type == "blue") {
                                            var animateIn = easeInOut(this.effect.time / 40);
                                            var time = t + x2 * 30 + y2 * 10 + xCor * 60 + yCor * 20 + 200;
                                            var a = Math.min(Math.max(Math.sin(time / 60) - 0.8, 0) * 5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 20;
                                            ctx.strokeStyle = "rgba(0,0,255,0.5)";
                                            ctx.strokeRect(-tileSize / 2 - 10, -tileSize / 2 - 10, tileSize + 20, tileSize + 20);
                                            ctx.fillStyle = "rgba(0,0,255,0.1)";
                                            ctx.fillRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        }
                                    }
                                    ctx.restore();
                                }
                            }

                            if (this.effect.active && this.effect.type == "green") {
                                for (var n = 0; n < 4; n++) {
                                    var x3 = n % 2;
                                    var y3 = Math.floor(n / 2);
                                    ctx.fillStyle = "rgba(0,255,0,0.4)";
                                    var animateIn = easeInOut(this.effect.time / 40);
                                    var time = t + x3 * 56 + y3 * 78 + Math.floor(Math.sin(xCor / 3) * 100) + Math.floor(Math.sin(yCor / 3) * 150);
                                    var s = 0.7 + Math.max(Math.sin(time / 10) - 0.6, 0) * 1.5;
                                    s *= animateIn;
                                    ctx.save();
                                    ctx.translate(175 + x3 * 350, 175 + y3 * 350);
                                    ctx.scale(s, s);
                                    ctx.rotate(time * Math.PI / 180);
                                    ctx.fillRect(-10, -10, 20, 20);
                                    ctx.restore();
                                }
                            }

                            ctx.restore();
                        }
                    }

                    ctx.restore();

                    if (this.effect.active) {
                        ctx.save();
                        ctx.globalAlpha = this.effect.alpha;
                        ctx.beginPath();
                        ctx.fillStyle = this.effect.color;
                        ctx.arc(this.effect.origin.x, this.effect.origin.y, this.effect.radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            },
            input: {
                keys: {
                    left: [37, 65],
                    right: [39, 68],
                    up: [38, 87],
                    down: [40, 83],
                    skip: [32],
                    restartLevel: [82],
                    restartGame: [8]
                },
                left: false,
                right: false,
                up: false,
                down: false,
                leftStart: false,
                rightStart: false,
                upStart: false,
                downStart: false,
                skip: false,
                restartLevel: false,
                restartGame: false,
                leftHold: 0,
                rightHold: 0,
                upHold: 0,
                downHold: 0,
                update: function () {
                    this.left = this.keys.left.some(e => Keys.keys[e]);
                    this.right = this.keys.right.some(e => Keys.keys[e]);
                    this.up = this.keys.up.some(e => Keys.keys[e]);
                    this.down = this.keys.down.some(e => Keys.keys[e]);
                    this.skip = this.keys.skip.some(e => Keys.keys[e]);
                    this.restartLevel = this.keys.restartLevel.some(e => Keys.keys[e]);
                    this.restartGame = this.keys.restartGame.some(e => Keys.keys[e]);
                    if (game.level.playerControlDelay) {
                        this.left = false;
                        this.right = false;
                        this.up = false;
                        this.down = false;
                    }
                    var directions = ["left", "right", "up", "down"];
                    for (var n = 0; n < 4; n++) {
                        var dir = directions[n];
                        if (this[`${dir}Start`]) {
                            this[`${dir}Start`]++;
                        } else if (this[dir]) {
                            this[`${dir}Start`] = 1;
                        }
                        if (this[dir]) {
                            this[`${dir}Hold`]++;
                        } else {
                            this[`${dir}Hold`] = 0;
                            this[`${dir}Start`] = 0;
                        }
                    }
                }
            },
            objects: {
                objects: [],
                update: function () {
                    for (var o of this.objects) {
                        if (o.type == "player") {
                            this.updatePlayer(o);
                            continue;
                        }
                        this.updateObject(o);
                    }
                    this.objects = this.objects.filter(e => !e.delete);
                },
                draw: function () {
                    for (var o of this.objects) {
                        if (o.type == "player") {
                            this.drawPlayer(o);
                            continue;
                        }
                        this.drawObject(o);
                    }
                },
                updatePlayerEye: function (o) {
                    if (o.controlDelay) {
                        o.controlDelay--;
                        return;
                    }
                    var o2;
                    if (o.id == "player eye 1") {
                        o2 = game.objects.objects.find(e => e.id == "player eye 2");
                    }
                    if (o.id == "player eye 2") {
                        o2 = game.objects.objects.find(e => e.id == "player eye 1");
                    }
                    if (!o2) return;
                    if (!o.xmove) o.xmove = 0;
                    if (!o.ymove) o.ymove = 0;
                    var speed = 0.4;
                    if (game.input.left) {
                        o.xmove -= speed;
                    }
                    if (game.input.right) {
                        o.xmove += speed;
                    }
                    if (game.input.up) {
                        if (o.y < 200) {
                            o.ymove -= speed / 4;
                        } else {
                            o.ymove -= speed;
                        }
                    }
                    if (game.input.down) {
                        o.ymove += speed;
                    }
                    var a1 = t;
                    var a2 = t + 10000;
                    if (o.id == "player eye 2") {
                        a1 = t + 847634;
                        a2 = t + 857634;
                    }
                    var closeToSurface = o.y < 700 && o2.y < 700;
                    var start = 400;
                    var end = 200;
                    var distanceToSurface = Math.max(Math.min(1 - (o.y / 2 + o2.y / 2 - start) / (start - end), 1), 0);
                    if (!closeToSurface && !game.level.triggers.tripped("red cube")) {
                        o.xmove += Math.sin(t / 100) / 90 + Math.sin(t / 435) / 90 + Math.sin(t / 34) / 90;
                        o.ymove += Math.sin(a2 / 100) / 90 + Math.sin(a2 / 435) / 90 + Math.sin(a2 / 34) / 90;
                    }
                    var dir = dirTo(o.x, o.y, o2.x, o2.y);
                    var dist = distTo(o.x, o.y, o2.x, o2.y);
                    var distance = 200;
                    if (closeToSurface) {
                        var percent = distanceToSurface * 0.05;
                        o.y = o.y * (1 - percent) + o2.y * percent;
                        distance = 200 - (200 - 15) * distanceToSurface;
                        var move = distToMove(dist - distance, dir);
                        o.xmove += move.x / (1000 - 980 * distanceToSurface);
                        o.ymove += move.y / (1000 - 980 * distanceToSurface);
                    } else {
                        var speed = dist - distance;
                        if (speed < 0) {
                            speed *= 0.5;
                            speed = Math.max(speed, -30);
                        }
                        var move = distToMove(speed, dir);
                        o.xmove += move.x / 1000;
                        o.ymove += move.y / 1000;
                    }
                    var a3 = t + 20000;
                    var rotation = Math.sin(a3 / 100) / 90 + Math.sin(a3 / 435) / 90 + Math.sin(a3 / 34) / 90;
                    var move = distToMove(rotation, dir + 90);
                    if (!closeToSurface && !game.level.triggers.tripped("red cube")) {
                        o.xmove += move.x;
                        o.ymove += move.y;
                    }
                    o.xmove *= 0.9;
                    o.ymove *= 0.9;

                    var player = o;
                    var axises = ["x", "y"];
                    var dims = ["w", "h"];
                    for (var n = 0; n < 2; n++) {
                        var axis = axises[n];
                        var dim = dims[n];
                        player[axis] += player[`${axis}move`];
                        for (var o of game.objects.objects) {
                            if (!o.eyeCollide) continue;
                            if (!blocksCollidingEdge(player, o)) continue;
                            if (o.type == "lava") player.delete = true;
                            if (!blocksColliding(player, o)) continue;
                            if (player[axis] + player[dim] / 2 < o[axis] + o[dim] / 2) {
                                player[axis] = o[axis] - player[dim];
                            } else {
                                player[axis] = o[axis] + o[dim];
                            }
                            player[`${axis}move`] = 0;
                        }
                    }

                    for (var o of game.objects.objects) {
                        if (o.type != "cube") continue;
                        if (o.collected) continue;
                        var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                        if (dist > 50) continue;
                        o.collectedAnimation = 20;
                        o.collected = true;
                        game.particles.createEffect("collect cube", o);
                        if (o.red) {
                            saveData.redCubesCollected[game.level.level] = true;
                        } else {
                            saveData.cubesCollected[game.level.level] = true;
                        }
                        updateSaveData();
                    }

                    if (player.delete && player.noDeathEffect !== true) {
                        game.particles.createEffect("eye death", player);
                        game.cam.screenshake = 20;
                    }
                },
                updateOldPlayer: function (o) {
                    if (game.level.levelComplete) {
                        o.x--;
                        return;
                    }
                    for (var o2 of game.objects.objects) {
                        if (!o2.collide) continue;
                        if (o2.type != "lava") continue;
                        if (!blocksColliding(o, o2)) continue;
                        o.delete = true;
                        game.particles.createEffect("player death", o);
                        game.cam.screenshake = 20;
                    }

                    o.x += o.xmove;
                    for (var o2 of game.objects.objects) {
                        if (!o2.collide) continue;
                        if (o2.type != "block") continue;
                        if (!blocksColliding(o, o2)) continue;
                        if (o.x + o.w / 2 < o2.x + o2.w / 2) {
                            o.x = o2.x - o.w;
                        } else {
                            o.x = o2.x + o2.w;
                        }
                        o.xmove = 0;
                    }
                    var touchingGround = false;
                    o.y += o.ymove;
                    for (var o2 of game.objects.objects) {
                        if (!o2.collide) continue;
                        if (o2.type != "block") continue;
                        if (!blocksColliding(o, o2)) continue;
                        if (o.y + o.h / 2 < o2.y + o2.h / 2) {
                            touchingGround = true;
                            o.y = o2.y - o.h;
                        } else {
                            o.y = o2.y + o2.h;
                        }
                        o.ymove = 0;
                    }

                    if (game.input.left) {
                        o.xmove += 0.15;
                    }
                    if (game.input.right) {
                        o.xmove -= 0.15;
                    }
                    if (game.input.down && touchingGround) {
                        o.ymove = -6;
                    }
                    o.ymove += 0.08;

                    o.xmove *= 0.96;
                    o.ymove *= 0.98;
                },
                updateCirclesPlayer: function (o) {
                    if (game.input.left) {
                        o.xmove -= 0.12;
                    }
                    if (game.input.right) {
                        o.xmove += 0.12;
                    }
                    o.turn *= 0.95;
                    o.turn += o.xmove * 0.05;
                    o.angle += o.turn;

                    var collide = false;
                    for (var o2 of game.objects.objects) {
                        if (o2.type != "circle") continue;
                        var dist = distTo(o.x, o.y, o2.x, o2.y);
                        if (dist > o.r + o2.r) continue;
                        collide = true;

                        var energy = 1.6;
                        var distX = o2.x - o.x;
                        var distY = o2.y - o.y;
                        var nx = distX / dist;
                        var ny = distY / dist;
                        var penetration = o.r + o2.r - dist;
                        var k = o.xmove * nx + o.ymove * ny;
                        o.xmove -= k * nx * energy;
                        o.turn += k * nx * 5;
                        o.ymove -= k * ny * energy;
                        o.x -= nx * penetration;
                        o.y -= ny * penetration;
                    }

                    if (game.input.up && collide) {
                        o.ymove = -6;
                    }

                    o.ymove += 0.15;
                    o.xmove *= 0.98;
                    o.ymove *= 0.98;

                    o.x += o.xmove;
                    o.y += o.ymove;
                },
                updatePingPongPlayer: function (o) {
                    o.x += o.xmove;
                    o.y += o.ymove;
                    if (o.y <= -4500) {
                        o.y = -4500;
                        o.ymove *= -1;
                    }
                    if (o.y >= -3500 - o.h) {
                        o.y = -3500 - o.h;
                        o.ymove *= -1;
                    }
                    var o2 = game.objects.objects.find(e => e.id == "player score");
                    if (o2.scoreTime) o2.scoreTime--;
                    var o2 = game.objects.objects.find(e => e.id == "opponent score");
                    if (o2.scoreTime) o2.scoreTime--;
                    if (o.x < -500) {
                        var o2 = game.objects.objects.find(e => e.id == "player score");
                        if (!o2.scoreTime) {
                            o2.content = String(Number(o2.content) + 1);
                            o2.scoreTime = 10;
                        }
                    }
                    var playerPaddle = game.objects.objects.find(e => e.id == "player paddle");
                    if (o.xmove > 0 && blocksColliding(o, playerPaddle)) {
                        o.xmove *= -1.1;
                        o.ymove *= 1.1;
                        o.x = playerPaddle.x - o.w;
                    }
                    var opponentPaddle = game.objects.objects.find(e => e.id == "opponent paddle");
                    if (o.xmove < 0 && blocksColliding(o, opponentPaddle)) {
                        o.xmove *= -1.1;
                        o.ymove *= 1.1;
                        o.x = opponentPaddle.x + opponentPaddle.w;
                    }
                    if (o.x > 500 - o.w) {
                        game.particles.createEffect("ping pong death", o);
                        o.delete = true;
                        game.cam.screenshake = 20;
                        var o2 = game.objects.objects.find(e => e.id == "opponent score");
                        if (!o2.scoreTime) {
                            o2.content = String(Number(o2.content) + 1);
                            o2.scoreTime = 10;
                        }
                    }
                },
                updatePacmanPlayer: function (o) {
                    o.animation = ((o.x + o.y) / 40 * Math.PI + Math.PI * 0.2) * 2;
                    var move = distToMove(1, o.angle);
                    if (game.level.triggers.tripped("red cube")) {
                        move = distToMove(4, o.angle);
                    }
                    o.touchingLeft = false;
                    o.touchingRight = false;
                    o.touchingTop = false;
                    o.touchingBottom = false;
                    o.x += move.x;
                    o.x = Math.round(o.x);
                    for (var o2 of game.objects.objects) {
                        if (!o2.pacmanCollide) continue;
                        if (!blocksCollidingEdge(o, o2)) continue;
                        if (o.y == o2.y + o2.h || o.y == o2.y - o.h) continue;
                        if (o.x + o.w / 2 < o2.x + o2.w / 2) {
                            o.touchingRight = true;
                        } else {
                            o.touchingLeft = true;
                        }
                        if (!blocksColliding(o, o2)) continue;
                        if (o.x + o.w / 2 < o2.x + o2.w / 2) {
                            o.x = o2.x - o.w;
                            o.y = Math.round((o.y - 20) / 40) * 40 + 20;
                        } else {
                            o.x = o2.x + o2.w;
                            o.y = Math.round((o.y - 20) / 40) * 40 + 20;
                        }
                    }
                    o.y += move.y;
                    o.y = Math.round(o.y);
                    for (var o2 of game.objects.objects) {
                        if (!o2.pacmanCollide) continue;
                        if (!blocksCollidingEdge(o, o2)) continue;
                        if (o.x == o2.x + o2.w || o.x == o2.x - o.w) continue;
                        if (o.y + o.h / 2 < o2.y + o2.h / 2) {
                            o.touchingBottom = true;
                        } else {
                            o.touchingTop = true;
                        }
                        if (!blocksColliding(o, o2)) continue;
                        if (o.y + o.h / 2 < o2.y + o2.h / 2) {
                            o.y = o2.y - o.h;
                            o.x = Math.round((o.x - 20) / 40) * 40 + 20;
                        } else {
                            o.y = o2.y + o2.h;
                            o.x = Math.round((o.x - 20) / 40) * 40 + 20;
                        }
                    }
                    if (o.nextDirection == 0 && !o.touchingTop) o.angle = 0;
                    if (o.nextDirection == 90 && !o.touchingRight) o.angle = 90;
                    if (o.nextDirection == 180 && !o.touchingBottom) o.angle = 180;
                    if (o.nextDirection == 270 && !o.touchingLeft) o.angle = 270;
                    if (game.input.upHold === 1) {
                        o.nextDirection = 0;
                    }
                    if (game.input.downHold === 1) {
                        o.nextDirection = 180;
                    }
                    if (game.input.rightHold === 1) {
                        o.nextDirection = 90;
                    }
                    if (game.input.leftHold === 1) {
                        o.nextDirection = 270;
                    }
                    for (var o2 of game.objects.objects) {
                        if (o2.type != "pacman dot") continue;
                        if (!blocksColliding(o, o2)) continue;
                        o2.collected = true;
                        o2.alpha = 0;
                    }
                },
                updateSnakePlayer: function (o) {
                    if (o.deathAnimation) {
                        o.deathAnimation++;
                        return;
                    }
                    var speed = Math.round(Math.max(21 - o.length / 12, 10));
                    o.move.time++;
                    var p = o.move.time / speed;
                    o.x = o.move.origin.x + o.move.direction.x * p;
                    o.y = o.move.origin.y + o.move.direction.y * p;
                    if (o.move.time > speed * 0.6) {
                        for (var o2 of game.objects.objects) {
                            if (o2.type != "apple") continue;
                            if (!blocksColliding(o, o2)) continue;
                            o2.delete = true;
                            o.length += 4;
                            for (var o3 of game.objects.objects) {
                                if (o3.type != "snake body") continue;
                                o3.time += speed * 4;
                            }
                        }
                        var collide = false;
                        for (var o2 of game.objects.objects) {
                            if (!o2.snakeCollide) continue;
                            if (o2.noCollideTime) continue;
                            if (!blocksColliding(o, o2)) continue;
                            collide = true;
                            break;
                        }
                        if (collide) {
                            for (var o2 of game.objects.objects) {
                                if (o2.type != "snake body" && o2.type != "snake player") continue;
                                o2.deathAnimation = 1;
                            }
                            game.cam.screenshake = 20;
                        }
                    }
                    if (o.move.time >= speed) {
                        o.move.lastDirection.x = o.move.direction.x;
                        o.move.lastDirection.y = o.move.direction.y;
                        var body = {
                            x: o.x,
                            y: o.y,
                            w: 40,
                            h: 40,
                            type: "snake body",
                            time: o.length * speed - speed,
                            snakeCollide: true,
                            noCollideTime: speed,
                            move: {
                                direction: {
                                    x: o.move.direction.x,
                                    y: o.move.direction.y
                                },
                                origin: {
                                    x: o.move.origin.x,
                                    y: o.move.origin.y
                                },
                                speed: speed
                            }
                        };
                        game.objects.objects.splice(game.objects.objects.length - 1, 0, body);
                        o.move.origin.x = o.x;
                        o.move.origin.y = o.y;
                        o.move.time = 0;
                        o.turned = false;
                        if (o.preserveTurnedStatus) {
                            o.preserveTurnedStatus = false;
                            o.turned = true;
                        }

                        if (o.move.directionQueue.length > 0) {
                            var direction = o.move.directionQueue.shift();
                            var opposed = o.move.lastDirection.x == -direction.x || o.move.lastDirection.y == -direction.y;
                            if (!opposed) {
                                o.move.direction = direction;
                            }
                        }
                    }
                    o.angle = dirTo(0, 0, o.move.direction.x, o.move.direction.y);
                    var move = false;
                    if (game.input.leftHold === 1) {
                        move = { x: -40, y: 0 }
                    }
                    if (game.input.rightHold === 1) {
                        move = { x: 40, y: 0 }
                    }
                    if (game.input.upHold === 1) {
                        move = { x: 0, y: -40 }
                    }
                    if (game.input.downHold === 1) {
                        move = { x: 0, y: 40 }
                    }
                    if (!move) return;
                    if (o.turned) {
                        if (o.move.directionQueue.length < 4) o.move.directionQueue.push(move);
                    } else {
                        o.turned = true;
                        if (o.move.time > speed * 0.6) {
                            if (o.move.directionQueue.length < 4) {
                                o.move.directionQueue.push(move);
                                o.preserveTurnedStatus = true;
                            }
                        } else {
                            var opposedX = o.move.lastDirection.x && o.move.lastDirection.x == -move.x;
                            var opposedY = o.move.lastDirection.y && o.move.lastDirection.y == -move.y;
                            var opposed = opposedX || opposedY;
                            if (!opposed) {
                                o.move.direction = move;
                            }
                        }
                    }
                },
                updateSokobanPlayer: function (o) {
                    if (o.move) {
                        o.move.time++;
                        var p = o.move.time / 5;
                        o.x = o.move.origin.x + o.move.direction.x * p;
                        o.y = o.move.origin.y + o.move.direction.y * p;
                        if (o.move.time == 5) {
                            o.move = false;
                        }
                    } else {
                        if (game.input.leftStart === 1 || game.input.leftHold > 17) {
                            o.move = {
                                direction: { x: -40, y: 0 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (game.input.rightStart === 1 || game.input.rightHold > 17) {
                            o.move = {
                                direction: { x: 40, y: 0 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (game.input.upStart === 1 || game.input.upHold > 17) {
                            o.move = {
                                direction: { x: 0, y: -40 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (game.input.downStart === 1 || game.input.downHold > 17) {
                            o.move = {
                                direction: { x: 0, y: 40 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (o.move) {
                            var newPos = {
                                x: o.move.origin.x + o.move.direction.x,
                                y: o.move.origin.y + o.move.direction.y,
                                w: 40,
                                h: 40
                            }
                            var cor = newPos;
                            var moveBox = false;
                            while (game.objects.objects.find(function (e) {
                                if (e.type !== "sokoban box") return false;
                                if (e.x != cor.x) return false;
                                if (e.y != cor.y) return false;
                                return true;
                            })) {
                                var box = game.objects.objects.find(function (e) {
                                    if (e.type !== "sokoban box") return false;
                                    if (e.x != cor.x) return false;
                                    if (e.y != cor.y) return false;
                                    return true;
                                });
                                box.move = structuredClone(o.move);
                                box.move.origin.x = box.x;
                                box.move.origin.y = box.y;
                                cor.x += o.move.direction.x;
                                cor.y += o.move.direction.y;
                                cor.x = Math.round(cor.x);
                                cor.y = Math.round(cor.y);
                                moveBox = true;
                            }
                            var collide = game.objects.objects.some(function (e) {
                                if (!e.sokobanCollide && !(moveBox && e.sokobanBoxCollide)) return false;
                                if (blocksColliding(e, cor)) return true;
                            });
                            if (collide) {
                                o.move = false;
                                for (var box of game.objects.objects) {
                                    if (box.type != "sokoban box") continue;
                                    box.move = false;
                                }
                            }
                        }
                    }

                    var player = o;
                    for (var o of game.objects.objects) {
                        if (o.type != "cube") continue;
                        if (!o.collide) continue;
                        if (o.collected) continue;
                        var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                        if (dist > 50) continue;
                        o.collectedAnimation = 20;
                        o.collected = true;
                        game.particles.createEffect("collect cube", o);
                        saveData.cubesCollected[game.level.level] = true;
                        updateSaveData();
                    }
                },
                updatePlayer: function (o) {
                    if (o.updatePlayer === false) return;
                    this.updatePlayerMovement(o);
                    this.updatePlayerCollisions(o);
                    this.updatePlayerCubeCollection(o);
                    this.updatePlayerCoyoteTime(o);
                    this.updatePlayerAnimations(o);
                },
                updatePlayerAnimations: function (o) {
                    var angle = 0;
                    var x = o.x + o.w / 2;
                    var y = o.y + o.h / 2;
                    if (o.positionHistory.length > 0) {
                        angle = dirTo(o.positionHistory[0].x, o.positionHistory[0].y, x, y);
                    }
                    o.positionHistory.unshift({ x: x, y: y, angle: angle });
                    if (game.background.effect.active && game.background.effect.type == "green") {
                        while (o.positionHistory.length > 30) o.positionHistory.pop();
                    } else {
                        while (o.positionHistory.length > 10) o.positionHistory.pop();
                    }
                    if (o.spawnTime > 0) o.spawnTime--;
                    if (o.spawnAnimation > 0) o.spawnAnimation--;
                    if (game.input.up) {
                        o.targetEyeHeight--;
                        o.targetEyeHeight = Math.max(o.targetEyeHeight, -5);
                    } else {
                        o.targetEyeHeight++;
                        o.targetEyeHeight = Math.min(o.targetEyeHeight, 5);
                        if (o.ymove <= 0) {
                            if (o.targetEyeHeight > 0) o.targetEyeHeight -= 2;
                        }
                    }
                    o.eyeHeight = o.eyeHeight * 0.9 + o.targetEyeHeight * 0.1;
                    if (o.againstLeft.current && game.input.left && !o.againstBottom.current) {
                        o.wallSlideAnimation++;
                        o.wallSlideAnimationDirection = "left";
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            if (Math.random() < 0.06) game.particles.createEffect("player wall slide");
                        } else {
                            if (Math.random() < 0.03) game.particles.createEffect("player wall slide");
                        }
                    } else if (o.againstRight.current && game.input.right && !o.againstBottom.current) {
                        o.wallSlideAnimation++;
                        o.wallSlideAnimationDirection = "right";
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            if (Math.random() < 0.06) game.particles.createEffect("player wall slide");
                        } else {
                            if (Math.random() < 0.03) game.particles.createEffect("player wall slide");
                        }
                    } else {
                        o.wallSlideAnimation--;
                    }
                    o.wallSlideAnimation = Math.max(Math.min(o.wallSlideAnimation, 15), 0);
                    var targetStretch = Math.max(o.ymove, 0) * 2;
                    o.stretchAnimation = o.stretchAnimation * 0.8 + targetStretch * 0.2;
                    if (o.againstBottom.current) {
                        o.splatAnimation++;
                    } else {
                        o.splatAnimation = 0;
                    }
                    if (o.againstBottom.current) {
                        o.runSkew = o.runSkew * 0.9 + (-o.xmove / 50) * 0.05;
                    } else {
                        o.runSkew *= 0.9;
                    }
                    var target = o.xmove * 0.9;
                    if (o.wallSlideAnimation) {
                        if (o.wallSlideAnimationDirection == "right") {
                            target = 5;
                        } else {
                            target = -5;
                        }
                    }
                    target = Math.min(Math.max(target, -5), 5);
                    o.eyeDirection = o.eyeDirection * 0.9 + target * 0.1;

                    if (o.againstBottom.time == 1) game.particles.createEffect("player land");

                    if (game.background.effect.active && game.background.effect.type == "green") {
                        var speed = distTo(0, 0, o.xmove, o.ymove);
                        if (t % 10 == 0 && speed > 2) game.particles.createEffect("player speed effect");
                        if ((t + 5) % 10 == 0 && speed > 8) game.particles.createEffect("player speed effect");
                    }

                    if (o.delete && !o.noDeathEffect) {
                        game.particles.createEffect("player death");
                        game.cam.screenshake = 20;
                    }

                    o.eyePositions[0] = { x: o.x + o.w / 2 + o.eyeDirection * 1.5 - 7, y: o.y + o.h / 2 + o.eyeHeight - 7 };
                    o.eyePositions[1] = { x: o.x + o.w / 2 + o.eyeDirection * 1.5 + 7, y: o.y + o.h / 2 + o.eyeHeight - 7 };
                },
                updatePlayerCoyoteTime: function (o) {
                    if (o.againstLeft.current) {
                        o.againstLeft.last = 0;
                        o.againstLeft.time++;
                    } else {
                        o.againstLeft.time = 0;
                        o.againstLeft.last++;
                    }
                    if (o.againstRight.current) {
                        o.againstRight.last = 0;
                        o.againstRight.time++;
                    } else {
                        o.againstRight.time = 0;
                        o.againstRight.last++;
                    }
                    if (o.againstTop.current) {
                        o.againstTop.last = 0;
                        o.againstTop.time++;
                    } else {
                        o.againstTop.time = 0;
                        o.againstTop.last++;
                    }
                    if (o.againstBottom.current) {
                        o.againstBottom.last = 0;
                        o.againstBottom.time++;
                    } else {
                        o.againstBottom.time = 0;
                        o.againstBottom.last++;
                    }
                },
                updatePlayerMovement: function (o) {
                    if (game.level.levelComplete) {
                        o.ymove = 0;
                        return;
                    }
                    var againstWall = o.againstLeft.current || o.againstRight.current;
                    if (game.input.left) {
                        o.xmove -= 0.4;
                        if (game.input.leftHold > 15) o.xmove -= 0.1;
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.3) game.particles.createEffect("player run");
                        } else {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.1) game.particles.createEffect("player run");
                        }
                    }
                    if (game.input.right) {
                        o.xmove += 0.4;
                        if (game.input.rightHold > 15) o.xmove += 0.1;
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.3) game.particles.createEffect("player run");
                        } else {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.1) game.particles.createEffect("player run");
                        }
                    }
                    if (o.againstTop.current) {
                        o.againstLeft.last = 10;
                        o.againstRight.last = 10;
                    }
                    if (game.input.up && o.ymove >= 0) {
                        if (o.againstBottom.last < 5) {
                            o.ymove = -10;
                            o.lastJumpType = "ground";
                            o.xmove *= 1.1;
                        } else if (o.againstRight.last < 10) {
                            o.ymove = -10;
                            o.xmove = -10;
                            o.lastJumpType = "wall";
                            game.particles.createEffect("player wall jump");
                        } else if (o.againstLeft.last < 10) {
                            o.ymove = -10;
                            o.xmove = 10;
                            o.lastJumpType = "wall";
                            game.particles.createEffect("player wall jump");
                        }
                    }

                    if (o.againstBottom.current) {
                        if (game.input.right || game.input.left) {
                            o.xmove *= 0.9;
                        } else {
                            o.xmove *= 0.8;
                        }
                    } else {
                        o.xmove *= 0.93;
                    }
                    o.ymove *= 0.98;

                    if (o.againstRight.current && game.input.right) {
                        o.ymove *= 0.8;
                    }
                    if (o.againstLeft.current && game.input.left) {
                        o.ymove *= 0.8;
                    }

                    if (o.ymove >= 0) {
                        o.ymove += 0.3;
                        if (game.input.up) {
                            o.ymove -= 0.05;
                        }
                    } else {
                        if (o.againstBottom.last < 20) {
                            o.ymove += 0.5;
                            if (game.input.up) o.ymove -= 0.3;
                        } else {
                            o.ymove += 0.3;
                            if (game.input.up) o.ymove -= 0.15;
                        }
                    }
                    if (game.input.down) {
                        if (!o.againstBottom.current) {
                            o.xmove *= 1.005;
                        }
                        if (o.ymove < 0 && o.againstBottom.last > 20) {
                            o.ymove *= 0.5;
                            o.ymove += 0.2;
                        } else {
                            o.ymove += 0.2;
                        }
                    }
                },
                updatePlayerCollisions: function (o) {
                    var player = o;
                    player.againstLeft.current = false;
                    player.againstRight.current = false;
                    player.againstTop.current = false;
                    player.againstBottom.current = false;
                    var axises = ["x", "y"];
                    var dims = ["w", "h"];
                    var directions = [["Left", "Right"], ["Top", "Bottom"]];
                    for (var n = 0; n < 2; n++) {
                        var axis = axises[n];
                        var dim = dims[n];
                        player[axis] += player[`${axis}move`];
                        for (var o of game.objects.objects) {
                            if (o.collide === false) continue;
                            if (o.type == "player") continue;
                            if (!blocksCollidingEdge(player, o)) continue;
                            if (o.type == "lava" && !game.level.levelComplete) player.delete = true;
                            if (o.type == "unstable" && !o.touched) {
                                o.touched = true;
                                o.alpha = 1;
                            }
                            if (o.type == "button") {
                                if (axis == "x" && player.y + player.h == o.y) {
                                    if (o.h > 12) {
                                        o.h -= 3;
                                        o.y += 3;
                                        player.y += 3;
                                        return;
                                    }
                                }
                            }
                            if (o.type == "platform") {
                                if (axis == "y") {
                                    if (player.ymove > 0 && player.y + player.h < o.y + o.h && !game.input.down) {
                                        player[axis] = o[axis] - player[dim];
                                        player[`against${directions[n][1]}`].current = true;
                                        player.ymove = 0;
                                    } else {
                                        if (game.input.up) player.ymove = -9;
                                        player[`against${directions[n][1]}`].current = true;
                                    }
                                }
                                continue;
                            }
                            if (!blocksColliding(player, o)) continue;
                            if (player[axis] + player[dim] / 2 < o[axis] + o[dim] / 2) {
                                player[axis] = o[axis] - player[dim];
                                player[`against${directions[n][1]}`].current = true;
                                if (o.slippery && axis == "x") {
                                    player[`against${directions[n][1]}`].current = false;
                                }
                            } else {
                                player[axis] = o[axis] + o[dim];
                                player[`against${directions[n][0]}`].current = true;
                                if (o.slippery && axis == "x") {
                                    player[`against${directions[n][0]}`].current = false;
                                }
                            }
                            player[`${axis}move`] = 0;
                        }
                    }
                },
                updatePlayerCubeCollection: function (o) {
                    var player = o;
                    for (var o of game.objects.objects) {
                        if (o.type != "cube") continue;
                        if (o.collected) continue;
                        var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                        if (dist > 70) continue;
                        o.collectedAnimation = 20;
                        o.collected = true;
                        game.particles.createEffect("collect cube", o);
                        if (o.red) {
                            saveData.redCubesCollected[game.level.level] = true;
                        } else {
                            saveData.cubesCollected[game.level.level] = true;
                        }
                        updateSaveData();
                    }
                },
                drawPlayer: function (o) {
                    ctx.fillStyle = "rgba(200,200,255,0.1)";
                    if (game.background.effect.active && game.background.effect.type == "green") {
                        ctx.fillStyle = "rgba(100,100,255,0.3)";
                    }
                    ctx.beginPath();
                    for (var n = 0; n < o.positionHistory.length; n++) {
                        var p = o.positionHistory[n];
                        var percent = (n + 1) / o.positionHistory.length;
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.angle * Math.PI / 180);
                        ctx.lineTo(-(1 - percent) * o.w / 2, 0);
                        ctx.restore();
                    }
                    for (var n = o.positionHistory.length - 1; n >= 0; n--) {
                        var p = o.positionHistory[n];
                        var percent = (n + 1) / o.positionHistory.length;
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.angle * Math.PI / 180);
                        ctx.lineTo((1 - percent) * o.w / 2, 0);
                        ctx.restore();
                    }
                    ctx.closePath();
                    ctx.fill();

                    ctx.save();
                    ctx.translate(o.x, o.y);
                    if (o.spawnTime) {
                        ctx.globalAlpha = t % 20 < 10 ? 1 : 0.8;
                    }
                    if (o.spawnAnimation) {
                        var s = easeInOut((20 - o.spawnAnimation) / 20);
                        ctx.translate(o.w / 2, o.h / 2);
                        ctx.scale(s, s);
                        ctx.translate(-o.w / 2, -o.h / 2);
                    }

                    var skew = o.wallSlideAnimation / 500;
                    if (o.wallSlideAnimationDirection == "right") skew = -skew;
                    if (skew) ctx.transform(1, skew, 0, 1, 0, 0);
                    ctx.transform(1, 0, o.runSkew, 1, 0, 0);
                    var stretch = o.stretchAnimation / 100;
                    if (stretch) {
                        ctx.translate(o.w / 2, 0);
                        ctx.scale(1, 1 + stretch);
                        ctx.translate(-o.w / 2, 0);
                    }
                    var splat = easeInBack(o.splatAnimation / 15) / 15;
                    if (splat) {
                        ctx.translate(o.w / 2, o.h);
                        ctx.scale(1 + splat, 1 - splat);
                        ctx.translate(-o.w / 2, -o.h);
                    }
                    ctx.fillStyle = "rgb(50,50,255)";
                    if (game.background.effect.active && game.background.effect.type == "green") {
                        ctx.fillStyle = "rgb(50,50,255)";
                    }
                    ctx.roundRect(0, 0, o.w, o.h, 2);
                    ctx.fill();

                    ctx.translate(o.w / 2, o.h / 2);

                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(o.eyeDirection * 1.5 - 7, o.eyeHeight - 7, 3.7, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(o.eyeDirection * 1.5 + 7, o.eyeHeight - 7, 3.7, 0, 2 * Math.PI);
                    ctx.fill();

                    ctx.restore();
                },
                updateObject: function (o) {
                    if (o.update) o.update();
                    if (o.spawnAnimation) o.spawnAnimation--;
                    if (o.decay) {
                        o.alpha -= o.decay;
                        o.alpha = Math.max(o.alpha, 0);
                        if (o.maxAlpha) o.alpha = Math.max(o.alpha, o.maxAlpha);
                    }
                    if (o.type == "cube") {
                        if (!o.animationSpeed) o.animationSpeed = 1;
                        if (!o.animation) o.animation = 0;
                        if (o.collected) {
                            o.animationSpeed *= 0.99;
                            o.animationSpeed += 0.002;
                        }
                        if (o.collectedAnimation) o.collectedAnimation--;
                        o.animation += o.animationSpeed;
                    }
                    if (o.type == "button") {
                        o.firstPress = false;
                        if (o.h >= o.originalHeight) {
                            o.pressed = false;
                            return;
                        }
                        if (o.h == 12) {
                            if (!o.pressed) {
                                o.firstPress = true;
                            }
                            o.pressed = true;
                        }
                        if (o.pushBack === false) return;
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (blocksCollidingEdge(o, player)) return;
                        o.h += 3;
                        o.y -= 3;
                    }
                    if (o.type == "unstable") {
                        if (o.touched) {
                            o.decay = 0.02;
                            if (o.decayValue) o.decay = o.decayValue;
                            if (o.alpha <= 0) o.collide = false;
                        }
                    }
                    if (o.type == "player eye") {
                        this.updatePlayerEye(o);
                    }
                    if (o.type == "sokoban player") {
                        this.updateSokobanPlayer(o);
                    }
                    if (o.type == "snake player") {
                        this.updateSnakePlayer(o);
                    }
                    if (o.type == "pacman player") {
                        this.updatePacmanPlayer(o);
                    }
                    if (o.type == "ping pong player") {
                        this.updatePingPongPlayer(o);
                    }
                    if (o.type == "circles player") {
                        this.updateCirclesPlayer(o);
                    }
                    if (o.type == "old player") {
                        this.updateOldPlayer(o);
                    }
                    if (o.type == "snake body") {
                        if (o.deathAnimation) {
                            o.deathAnimation++;
                            return;
                        }
                        if (o.noCollideTime >= 0) {
                            o.noCollideTime--;
                        } else {
                            o.noCollideTime = 0;
                        }
                        o.time--;
                        if (o.time < o.move.speed) {
                            o.moving = true;
                            var percent = 1 - (o.time / o.move.speed);
                            o.x = o.move.origin.x + o.move.direction.x * percent;
                            o.y = o.move.origin.y + o.move.direction.y * percent;
                        }
                        if (o.time <= 0) o.delete = true;
                    }
                    if (o.type == "sokoban box") {
                        if (o.move) {
                            o.move.time++;
                            var p = o.move.time / 5;
                            o.x = o.move.origin.x + o.move.direction.x * p;
                            o.y = o.move.origin.y + o.move.direction.y * p;
                            if (o.move.time == 5) {
                                o.move = false;
                            }
                        }
                        if (o.blue) {
                            o.lit = game.objects.objects.some(e => e.type == "clue" && e.x == o.x + 20 && e.y == o.y + 20);
                        }
                    }
                    if (o.type == "jump enemy") {
                        o.x += o.xmove;
                        if (o.x > 1460) {
                            o.xmove *= -1;
                            o.x = 1460;
                        }
                        if (o.x < 1310) {
                            o.xmove *= -1;
                            o.x = 1310;
                        }
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (player && blocksCollidingEdge(o, player)) {
                            if (player.y + player.h < o.y + o.h / 2) {
                                o.delete = true;
                                game.particles.createEffect("jump enemy death", o);
                                player.ymove = -20;
                            } else {
                                player.delete = true;
                            }
                        }
                    }
                },
                drawObject: function (o) {
                    if (o.alpha <= 0) return;
                    ctx.save();
                    ctx.translate(o.x, o.y);
                    if (o.drawType == "snake player" || o.drawType == "pacman player") ctx.translate(o.w / 2, o.h / 2);
                    if (o.angle) ctx.rotate(o.angle * Math.PI / 180);
                    if (o.alpha) ctx.globalAlpha = o.alpha;
                    if (o.spawnAnimation) {
                        var a = 1 - easeInOut(o.spawnAnimation / o.spawnAnimationDuration);
                        ctx.globalAlpha = a;
                        ctx.scale(a, a);
                    }
                    if (!o.drawType) o.drawType = o.type;
                    if (o.drawType == "clue") {
                        var color = { r: 30, g: 30, b: 30, a: 1 };
                        if (o.air) {
                            color = { r: 0, g: 0, b: 0, a: 0.05 };
                        }
                        if (o.blue) {
                            color = { r: 0, g: 0, b: 0, a: 0.1 };
                        }
                        if (o.white) {
                            color = { r: 255, g: 255, b: 255, a: 1 };
                        }
                        if (o.proximity !== undefined) {
                            var distToPlayer;
                            var player = game.objects.objects.find(e => e.type == "player");
                            var distToPlayer;
                            if (player) {
                                distToPlayer = distTo(o.x, o.y, player.x, player.y);
                            } else {
                                distToPlayer = 10000;
                            }
                            var a = Math.max(Math.min((distToPlayer - o.radius) / o.proximity, 1), 0);
                            if (o.activated) a = 0;
                            var blue = { r: 50, g: 120, b: 255, a: 1 };
                            if (o.color) {
                                blue = o.color;
                                blue.a = 1;
                            }
                            if (color.a == 1 || a == 1) {
                                color.r = color.r * a + blue.r * (1 - a);
                                color.g = color.g * a + blue.g * (1 - a);
                                color.b = color.b * a + blue.b * (1 - a);
                            } else {
                                color.r = blue.r;
                                color.g = blue.g;
                                color.b = blue.b;
                            }
                            color.a = color.a * a + blue.a * (1 - a);
                            ctx.shadowColor = `rgba(${color.r},${color.g},${color.b},${color.a})`;
                            ctx.shadowBlur = (1 - a) * 40;
                        }
                        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;
                        if (o.down) {
                            ctx.beginPath();
                            ctx.moveTo(-20, -7);
                            ctx.lineTo(20, -7);
                            ctx.lineTo(0, 15);
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.fillRect(-15, -15, 30, 30);
                        }
                    } else if (o.drawType == "cube") {
                        if (o.collected) {
                            var colorFunction = function (x, y, z, n) {
                                return `rgba(200,200,200,0.5)`;
                            }
                            if (o.onBlue) {
                                var colorFunction = function (x, y, z, n) {
                                    return `rgba(0,0,0,0.1)`;
                                }
                            }
                            drawRotatingCube({
                                size: 30,
                                xAngle: o.animation / 150,
                                yAngle: o.animation / 170,
                                zAngle: o.animation / 180,
                                border: false,
                                colorFunction: colorFunction
                            });
                        }
                        if (!o.collected || o.collectedAnimation) {
                            if (o.collectedAnimation) {
                                ctx.globalAlpha *= o.collectedAnimation / 20;
                            }
                            var s = 1 + Math.sin(o.animation / 40) * 0.1;
                            ctx.scale(s, s);
                            var grd = ctx.createRadialGradient(0, 0, 30, 0, 0, 150);
                            if (o.red) {
                                grd.addColorStop(0, "rgba(255,0,0,0.24)");
                                grd.addColorStop(0.33, "rgba(255,0,0,0.12)");
                                grd.addColorStop(0.66, "rgba(255,0,0,0.036)");
                                grd.addColorStop(1, "rgba(255,0,0,0)");
                            } else {
                                grd.addColorStop(0, "rgba(0,0,255,0.24)");
                                grd.addColorStop(0.33, "rgba(0,0,255,0.12)");
                                grd.addColorStop(0.66, "rgba(0,0,255,0.036)");
                                grd.addColorStop(1, "rgba(0,0,255,0)");
                            }
                            ctx.fillStyle = grd;
                            ctx.beginPath();
                            ctx.arc(0, 0, 150, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        if (!o.collected) {
                            var s = easeInOut(o.alpha);
                            ctx.scale(s, s);
                            if (o.red) {
                                drawRotatingCube({
                                    size: 30,
                                    xAngle: o.animation / 150,
                                    yAngle: o.animation / 170,
                                    zAngle: o.animation / 180,
                                    colorFunction: function (x, y, z, n) {
                                        var l = (1 - y) * 150 + x * 50;
                                        var r = 220 + l / 3;
                                        var g = 20 + l;
                                        var b = 20 + l;
                                        return `rgb(${r},${g},${b})`;
                                    }
                                });
                            } else {
                                drawRotatingCube({
                                    size: 30,
                                    xAngle: o.animation / 150,
                                    yAngle: o.animation / 170,
                                    zAngle: o.animation / 180,
                                    colorFunction: function (x, y, z, n) {
                                        var l = (1 - y) * 150 + x * 50;
                                        var r = 20 + l;
                                        var g = 20 + l * 1.2;
                                        var b = 220 + l / 3;
                                        return `rgb(${r},${g},${b})`;
                                    }
                                });
                            }
                        }
                    } else if (o.drawType == "text") {
                        ctx.fillStyle = o.color || "black";
                        ctx.font = o.font || "50px rubik";
                        ctx.textAlign = o.textAlign || "center";
                        ctx.textBaseline = o.textBaseline || "middle";
                        ctx.fillText(o.content, 0, 0);
                    } else if (o.drawType == "image") {
                        ctx.drawImage(images[o.image], 0, 0, o.w, o.h);
                    } else if (o.drawType == "jump enemy") {
                        ctx.drawImage(images.jumpEnemy, 0, 0, o.w, o.h);
                    } else if (o.drawType == "arrow") {
                        ctx.strokeStyle = o.color || "black";
                        ctx.lineWidth = o.lineWidth || 12;
                        ctx.lineCap = "round";
                        ctx.lineJoin = "round";
                        var totalWidth = o.totalWidth || 200;
                        var height = o.height || 25;
                        var headWidth = o.headWidth || 40;
                        ctx.beginPath();
                        ctx.moveTo(-totalWidth / 2, 0);
                        ctx.lineTo(totalWidth / 2, 0);
                        ctx.lineTo(totalWidth / 2 - headWidth, height);
                        ctx.moveTo(totalWidth / 2, 0);
                        ctx.lineTo(totalWidth / 2 - headWidth, -height);
                        ctx.stroke();
                    } else if (o.drawType == "block") {
                        ctx.fillStyle = "black";
                        if (o.color) ctx.fillStyle = o.color;
                        if (o.blueAnimation && o.blueAnimation > 0) {
                            var x = o.blueAnimationOrigin.x;
                            var y = o.blueAnimationOrigin.y;
                            var r1 = o.blueAnimation ** 1.8 - 500;
                            var r2 = r1 + 500;
                            r1 = Math.max(r1, 0);
                            var grd = ctx.createRadialGradient(x, y, r1, x, y, r2);
                            grd.addColorStop(0, "rgb(50,50,255)");
                            grd.addColorStop(1, "black");
                            ctx.fillStyle = grd;
                        }
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "platform") {
                        ctx.fillStyle = "black";
                        if (o.color) ctx.fillStyle = o.color;
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "sokoban box") {
                        if (o.blue) {
                            if (o.lit) {
                                ctx.shadowColor = "rgb(50,120,255)";
                                ctx.shadowBlur = 40;
                                ctx.drawImage(images.sokobanBlueBoxLit, 0, 0, o.w, o.h);
                            } else {
                                ctx.drawImage(images.sokobanBlueBox, 0, 0, o.w, o.h);
                            }
                        } else {
                            ctx.drawImage(images.sokobanBox, 0, 0, o.w, o.h);
                        }
                    } else if (o.drawType == "unstable") {
                        ctx.strokeStyle = "black";
                        if (o.color) ctx.strokeStyle = o.color;
                        ctx.lineWidth = 5;
                        ctx.strokeRect(2.5, 2.5, o.w - 5, o.h - 5);
                    } else if (o.drawType == "lava") {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "red";
                        ctx.fillStyle = "red";
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "glass") {
                        ctx.fillStyle = "rgba(0,0,0,0.04)";
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "lava glass") {
                        ctx.fillStyle = "rgba(255,0,0,0.04)";
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "button") {
                        ctx.fillStyle = "rgb(255,120,100)";
                        if (o.color) ctx.fillStyle = o.color;
                        ctx.fillRect(0, 0, o.w, o.h);
                        ctx.fillStyle = "rgb(50,50,50)";
                        ctx.fillRect(-10, o.h - 5, o.w + 20, 6);
                    } else if (o.drawType == "player eye") {
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(3.7, 3.7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.drawType == "sokoban player") {
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.fillRect(0, 0, 40, 40);
                        ctx.fillStyle = "black";
                        ctx.fillRect(9, 7, 7, 7);
                        ctx.fillRect(24, 7, 7, 7);
                    } else if (o.drawType == "snake player") {
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.translate(-20, -20);
                        ctx.fillStyle = "rgb(50,50,255)";
                        if (o.deathAnimation) {
                            if ((o.deathAnimation + 15) % 40 > 15) {
                                ctx.fillStyle = "rgb(50,50,200)";
                            }
                        }
                        ctx.fillRect(0, 0, 40, 40);
                        ctx.fillStyle = "black";
                        if (o.deathAnimation) {
                            ctx.save();
                            ctx.translate(9 + 7 / 2, 7 + 7 / 2);
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.fillRect(-6, -1, 12, 2);
                            ctx.fillRect(-1, -6, 2, 12);
                            ctx.restore();
                            ctx.save();
                            ctx.translate(24 + 7 / 2, 7 + 7 / 2);
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.fillRect(-6, -1, 12, 2);
                            ctx.fillRect(-1, -6, 2, 12);
                            ctx.restore();
                        } else {
                            ctx.fillRect(9, 7, 7, 7);
                            ctx.fillRect(24, 7, 7, 7);
                        }
                    } else if (o.drawType == "snake body") {
                        ctx.fillStyle = "rgb(50,50,255)";
                        if (o.deathAnimation) {
                            if ((o.deathAnimation + 15) % 40 > 15) {
                                ctx.fillStyle = "rgb(50,50,200)";
                            }
                        }
                        ctx.fillRect(0, 0, o.w, o.h);
                        if (o.moving) {
                            var percent = o.time / o.move.speed;
                            percent = Math.min(percent, 1);
                            var x = o.move.direction.x * percent;
                            var y = o.move.direction.y * percent;
                            ctx.fillRect(x, y, o.w, o.h);
                        }
                    } else if (o.drawType == "apple") {
                        ctx.fillStyle = "rgb(255,50,50)";
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "pacman player") {
                        var openDistance = Math.round((Math.sin(o.animation) * 0.5 + 0.5) * 2) / 2 * 30;
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.translate(-o.w / 2, -o.h / 2);
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.beginPath();
                        ctx.moveTo(2 - openDistance / 5, 0);
                        ctx.lineTo(20 - openDistance / 2, 0);
                        ctx.lineTo(20, 25);
                        ctx.lineTo(20 + openDistance / 2, 0);
                        ctx.lineTo(38 + openDistance / 5, 0);
                        ctx.lineTo(40, 40);
                        ctx.lineTo(0, 40);
                        ctx.closePath();
                        ctx.fill();
                        if (o.angle == 270) {
                            ctx.translate(o.w / 2, o.h / 2);
                            ctx.scale(-1, 1);
                            ctx.translate(-o.w / 2, -o.h / 2);
                        }
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(10 - openDistance / 3.7, 8, 3.5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(11 - openDistance / 7, 20, 3.5, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.type == "pacman dot") {
                        ctx.fillStyle = "rgb(200,200,200)";
                        if (o.red) ctx.fillStyle = "rgb(255,150,150)";
                        if (o.clue) {
                            ctx.translate(o.w / 2, o.h / 2);
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.translate(-o.w / 2, -o.h / 2);
                            ctx.fillRect(0, 0, o.w, o.h);
                        } else {
                            ctx.fillRect(0, 0, o.w, o.h);
                        }
                    } else if (o.drawType == "ping pong player") {
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.fillRect(0, 0, 40, 40);
                        ctx.fillStyle = "black";
                        ctx.fillRect(9, 7, 7, 7);
                        ctx.fillRect(24, 7, 7, 7);
                    } else if (o.drawType == "circles player") {
                        ctx.scale(o.r / 40, o.r / 40);
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.beginPath();
                        ctx.arc(0, 0, 40, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(-14, -12, 7, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(14, -12, 7, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.drawType == "circle") {
                        ctx.fillStyle = o.color;
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 10;
                        ctx.beginPath();
                        ctx.arc(0, 0, o.r - 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    } else if (o.drawType == "old player") {
                        ctx.fillStyle = "blue";
                        ctx.fillRect(0, 0, o.w, o.h);

                        ctx.fillStyle = "black";
                        var dir = dirTo(0, 0, o.xmove, o.ymove);
                        var speed = distTo(0, 0, o.xmove, o.ymove);
                        speed = Math.min(speed, 5);
                        var move = distToMove(speed, dir);
                        ctx.beginPath();
                        ctx.arc(move.x * 1.5 + o.w / 2 - 7, move.y * 2 + o.h / 2 - 7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(move.x * 1.5 + o.w / 2 + 7, move.y * 2 + o.h / 2 - 7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            },
            particles: {
                objects: [],
                update: function () {
                    for (var o of this.objects) {
                        this.updateObject(o);
                    }
                    this.objects = this.objects.filter(e => !e.delete);
                },
                draw: function () {
                    for (var o of this.objects) {
                        this.drawObject(o);
                    }
                },
                updateObject: function (o) {
                    if (o.xmove) o.x += o.xmove;
                    if (o.ymove) o.y += o.ymove;
                    if (o.damping) {
                        o.xmove *= o.damping;
                        o.ymove *= o.damping;
                    }
                    if (o.type == "player death circle") {
                        o.r += 2;
                    }
                    if (o.type == "player eye death circle") {
                        o.r += 2;
                    }
                    if (o.type == "cube collect particle") {
                        o.r += 4;
                    }
                    if (o.type == "player speed effect particle") {
                        o.r++;
                        o.r = Math.min(o.r, 10);
                    }
                    if (o.rotate) {
                        o.angle += o.rotate;
                    }
                    if (o.gravity) o.ymove += o.gravity;
                    if (o.decay) o.alpha -= o.decay;
                    if (o.alpha <= 0) o.delete = true;
                },
                drawObject: function (o) {
                    if (o.r <= 0) return;
                    ctx.save();
                    if (o.alpha) ctx.globalAlpha = o.alpha;
                    if (o.drawType == "circle") {
                        ctx.translate(o.x, o.y);
                        ctx.fillStyle = o.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, o.r, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    if (o.drawType == "square") {
                        ctx.translate(o.x, o.y);
                        ctx.fillStyle = o.color;
                        ctx.fillRect(-o.r, -o.r, o.r * 2, o.r * 2);
                    }
                    if (o.drawType == "image") {
                        ctx.translate(o.x, o.y);
                        if (o.angle) ctx.rotate(o.angle * Math.PI / 180);
                        ctx.drawImage(images[o.image], -o.r, -o.r, o.r * 2, o.r * 2);
                    }
                    ctx.restore();
                },
                create: function (o) {
                    if (o.type == "player speed effect particle") {
                        o.drawType = "image";
                        o.image = "greenSparkle";
                        o.r = -5;
                        o.rotate = 3;
                        if (Math.random() < 0.5) o.rotate *= -1;
                        o.angle = Math.random() * 360;
                        o.alpha = 1 + Math.random();
                        o.gravity = 0.01;
                        o.decay = 0.02;
                    }
                    if (o.type == "player land particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,255,0.5)";
                        o.alpha = 1 + Math.random();
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            o.color = "rgba(0,0,255,0.7)";
                            o.r = 4.5;
                        }
                        o.gravity = 0.01;
                        o.decay = 0.05;
                    }
                    if (o.type == "player wall jump particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,255,0.5)";
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            o.color = "rgba(0,0,255,0.7)";
                            o.r = 4.5;
                        }
                        o.alpha = 1 + Math.random();
                        o.gravity = 0.03;
                        o.decay = 0.05;
                    }
                    if (o.type == "player run particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,255,0.1)";
                        if (game.background.effect.active && game.background.effect.type == "green") {
                            o.color = "rgba(0,0,255,0.3)";
                            o.r = 4.5;
                        }
                        o.alpha = 3 + Math.random();
                        o.decay = 0.05;
                    }
                    if (o.type == "player death particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.damping = 0.99;
                        o.color = "rgba(0,0,255,0.5)";
                        o.alpha = 3 + Math.random() * 3;
                        o.decay = 0.05;
                    }
                    if (o.type == "player eye death particle") {
                        o.drawType = "circle";
                        o.r = 2;
                        o.damping = 0.99;
                        o.color = "rgba(0,0,0,0.5)";
                        o.alpha = 3 + Math.random() * 3;
                        o.decay = 0.05;
                    }
                    if (o.type == "player death circle") {
                        o.drawType = "circle";
                        o.r = 10;
                        o.color = "rgba(0,0,255,0.3)";
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "player eye death circle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,0,0.1)";
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "cube collect particle") {
                        o.drawType = "circle";
                        o.r = 10;
                        o.color = "rgba(100,100,255,0.3)";
                        if (o.red) {
                            o.color = "rgba(255,100,100,0.3)";
                        }
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "jump enemy death particle") {
                        o.drawType = "square";
                        o.r = 5;
                        o.color = "red";
                        o.alpha = 1;
                        o.decay = 0.05;
                        var move = distToMove(1 + Math.random() * 2.5, Math.random() * 360);
                        o.xmove = move.x;
                        o.ymove = move.y;
                    }
                    if (o.type == "ping pong player death particle") {
                        o.drawType = "square";
                        o.r = 5;
                        o.color = "blue";
                        o.alpha = 50;
                        o.decay = 1;
                    }
                    this.objects.push(o);
                },
                createEffect: function (effect, data) {
                    var player;
                    if (effect.includes("player")) {
                        player = game.objects.objects.find(e => e.type == "player");
                        if (!player) {
                            if (data) {
                                player = data;
                            } else {
                                return;
                            }
                        }
                    }
                    if (effect == "player speed effect") {
                        var o = {};
                        o.type = "player speed effect particle";
                        o.x = player.x + player.w * Math.random();
                        o.y = player.y + player.h * Math.random();
                        o.xmove = 0;
                        o.ymove = - Math.random() * 1;
                        this.create(o);
                    }
                    if (effect == "player land") {
                        var amount = 5;
                        if (game.background.effect.active && game.background.effect.type == "green") amount *= 2;
                        for (var n = 0; n < amount; n++) {
                            var percent = n / (amount - 1);
                            var o = {};
                            o.type = "player land particle";
                            o.x = player.x + player.w * percent;
                            o.y = player.y + player.h;
                            o.xmove = -2.5 + 5 * percent;
                            o.ymove = - Math.random() * 1;
                            this.create(o);
                        }
                    }
                    if (effect == "player run") {
                        var o = {};
                        o.type = "player run particle";
                        o.y = player.y + player.h * (0.7 + Math.random() * 0.3);
                        o.ymove = -0.2 - Math.random() * 0.3;
                        if (player.xmove > 0) {
                            o.x = player.x;
                            o.xmove = -0.5;
                        } else {
                            o.x = player.x + player.w;
                            o.xmove = 0.5;
                        }
                        this.create(o);
                    }
                    if (effect == "player wall jump") {
                        var count = 3;
                        if (game.background.effect.active && game.background.effect.type == "green") amount *= 2;
                        for (var n = 0; n < count; n++) {
                            var percent = n / count;
                            var o = {};
                            o.type = "player wall jump particle";
                            o.y = player.y + player.h * percent;
                            o.ymove = -3 + 5 * percent;
                            if (player.xmove > 0) {
                                o.x = player.x;
                                o.xmove = Math.random() * 0.8 + 0.1;
                            } else {
                                o.x = player.x + player.w;
                                o.xmove = -Math.random() * 0.8 - 0.1;
                            }
                            this.create(o);
                        }
                    }
                    if (effect == "player wall slide") {
                        var o = {};
                        o.type = "player wall jump particle";
                        o.y = player.y;
                        o.ymove = -1;
                        if (player.wallSlideAnimationDirection == "left") {
                            o.x = player.x;
                            o.xmove = Math.random() * 1 + 0.3;
                        } else {
                            o.x = player.x + player.w;
                            o.xmove = -Math.random() * 1 - 0.3;
                        }
                        this.create(o);
                    }
                    if (effect == "player death") {
                        var count = 10;
                        for (var n = 0; n < count; n++) {
                            var o = {};
                            o.type = "player death particle";
                            o.y = player.y + player.h / 2;
                            o.x = player.x + player.w / 2;
                            var dir = Math.random() * 360;
                            var speed = 1 + Math.random();
                            var move = distToMove(speed, dir);
                            o.xmove = move.x;
                            o.ymove = move.y;
                            this.create(o);
                        }
                        var o = {};
                        o.type = "player death circle";
                        o.y = player.y + player.h / 2;
                        o.x = player.x + player.w / 2;
                        this.create(o);
                    }
                    if (effect == "eye death") {
                        var player = data;
                        var count = 5;
                        for (var n = 0; n < count; n++) {
                            var o = {};
                            o.type = "player eye death particle";
                            o.y = player.y + player.h / 2;
                            o.x = player.x + player.w / 2;
                            var dir = Math.random() * 360;
                            var speed = 1 + Math.random();
                            var move = distToMove(speed, dir);
                            o.xmove = move.x;
                            o.ymove = move.y;
                            this.create(o);
                        }
                        var o = {};
                        o.type = "player eye death circle";
                        o.y = player.y + player.h / 2;
                        o.x = player.x + player.w / 2;
                        this.create(o);
                    }
                    if (effect == "collect cube") {
                        var o = {};
                        o.x = data.x;
                        o.y = data.y;
                        o.red = data.red;
                        o.type = "cube collect particle";
                        this.create(o);
                    }
                    if (effect == "jump enemy death") {
                        for (var n = 0; n < 40; n++) {
                            var o = {};
                            o.x = data.x;
                            o.y = data.y;
                            o.type = "jump enemy death particle";
                            this.create(o);
                        }
                    }
                    if (effect == "ping pong death") {
                        for (var n = 0; n < 8; n++) {
                            var angle = n / 8 * 360;
                            var move = distToMove(2, angle);
                            var o = {};
                            o.x = data.x;
                            o.y = data.y;
                            o.xmove = move.x;
                            o.ymove = move.y;
                            o.type = "ping pong player death particle";
                            this.create(o);
                        }
                    }
                }
            },
            cam: {
                screenshake: 0,
                x: 0,
                y: 0,
                zoom: 1,
                origin: { x: 0, y: 0 },
                offset: { x: 0, y: 0 },
                shakeX: 0,
                shakeY: 0,
                viewportBoundary: false,
                followX: 0,
                followY: 0,
                update: function () {
                    if (this.screenshake) this.screenshake--;
                    this.screenshake = Math.max(this.screenshake, 0);
                    this.shakeX = Math.random() * this.screenshake - this.screenshake / 2;
                    this.shakeY = Math.random() * this.screenshake - this.screenshake / 2;
                    var o = game.objects.objects.find(e => e.type == "player");
                    var eye1 = game.objects.objects.find(e => e.id == "player eye 1");
                    var eye2 = game.objects.objects.find(e => e.id == "player eye 2");
                    if (!o && eye1 && eye2) {
                        var o = { x: eye1.x / 2 + eye2.x / 2, y: eye1.y / 2 + eye2.y / 2, w: 0, h: 0 };
                    }
                    if (o) {
                        var distToPlayer = distTo(this.x, this.y, o.x + this.offset.x, o.y + this.offset.y);
                        var followX = this.followX;
                        var followY = this.followY;
                        if (distToPlayer > 100) {
                            followX += (distToPlayer - 100) / 5000;
                            followY += (distToPlayer - 100) / 5000;
                        }
                        followX = Math.max(Math.min(followX, 1), 0);
                        followY = Math.max(Math.min(followY, 1), 0);
                        if (this.speedModifiers) {
                            if (this.speedModifiers.x !== undefined) {
                                followX *= this.speedModifiers.x;
                            }
                            if (this.speedModifiers.y !== undefined) {
                                followY *= this.speedModifiers.y;
                            }
                        }
                        this.x = this.x * (1 - followX) + (o.x + this.offset.x + o.w / 2) * followX;
                        this.y = this.y * (1 - followY) + (o.y + this.offset.y + o.h / 2) * followY;
                    }

                    if (this.viewportBoundary) {
                        var o = this.viewportBoundary;
                        this.x = Math.max(Math.min(this.x, o.x + o.w), o.x);
                        this.y = Math.max(Math.min(this.y, o.y + o.h), o.y);
                    }

                    if (this.levelFunction) this.levelFunction();
                },
                levelFunction: false,
                alignViewport: function () {
                    ctx.translate(500, 500);
                    ctx.scale(this.zoom, this.zoom);
                    ctx.translate(-this.x + this.shakeX, -this.y + this.shakeY);
                },
                alignCoordinates: function (x, y) {
                    x = (x - this.x + this.shakeX) * this.zoom + 500;
                    y = (y - this.y + this.shakeY) * this.zoom + 500;
                    return { x: x, y: y };
                }
            },
            level: {
                level: 0,
                levelAnimationTime: 0,
                playerControlDelay: 0,
                playerSpawnPoint: {},
                lastPlayerPosition: {},
                levelComplete: false,
                levelTransition: 0,
                levelTransitionCap: 100,
                playerDead: false,
                playerRespawnTime: 0,
                levelCompleteFunction: false,
                playerDeadFunction: false,
                manualRespawn: false,
                update: function () {
                    this.levelAnimationTime++;

                    if (this.playerControlDelay) this.playerControlDelay--;

                    var player = game.objects.objects.find(e => e.type == "player");
                    var playerEye = game.objects.objects.find(e => e.id == "player eye 1") && game.objects.objects.find(e => e.id == "player eye 2");
                    if (player) {
                        this.lastPlayerPosition.x = player.x;
                        this.lastPlayerPosition.y = player.y;
                    } else if (playerEye) {
                        var eye1 = game.objects.objects.find(e => e.id == "player eye 1");
                        var eye2 = game.objects.objects.find(e => e.id == "player eye 2");
                        this.lastPlayerPosition.x = eye1.x * 0.5 + eye2.x * 0.5;
                        this.lastPlayerPosition.y = eye1.y * 0.5 + eye2.y * 0.5;
                    } else {
                        var possiblePlayers = game.objects.objects.filter(e => e.type.includes("player"));
                        var substitutePlayer = possiblePlayers[possiblePlayers.length - 1];
                        if (substitutePlayer) {
                            this.lastPlayerPosition.x = substitutePlayer.x;
                            this.lastPlayerPosition.y = substitutePlayer.y;
                        }
                    }

                    this.triggers.update();

                    if (this.levelComplete) {
                        this.levelTransition++;
                        if (game.input.skip) this.levelTransition = this.levelTransitionCap;
                        if (this.levelTransition >= this.levelTransitionCap) {
                            this.level++;
                            this.load(this.level);
                            saveData.levelsBeaten = Math.max(saveData.levelsBeaten, this.level);
                            updateSaveData();
                        }
                        return;
                    } else {
                        this.levelTransition--;
                        if (game.input.skip) this.levelTransition = 0;
                    }
                    this.levelTransition = Math.min(Math.max(this.levelTransition, 0), this.levelTransitionCap);

                    if (this.levelCompleteFunction()) {
                        this.levelComplete = true;
                        game.background.effect.end();
                    }

                    if (!this.playerDead) {
                        if (this.playerDeadFunction) {
                            if (this.playerDeadFunction()) {
                                this.playerDead = true;
                                this.playerRespawnTime = 200;
                            }
                        } else {
                            if (!player && !playerEye) {
                                this.playerDead = true;
                                this.playerRespawnTime = 200;
                            }
                        }
                    } else {
                        if (this.respawnTimeFunction) {
                            this.respawnTimeFunction();
                        } else {
                            this.playerRespawnTime--;
                        }
                        if (this.manualRespawn) {
                            this.playerRespawnTime;
                            if (this.playerRespawnTime <= 0) {
                                this.playerDead = false;
                                this.manualRespawn();
                            }
                        } else {
                            var a = Math.min(Math.max((120 - this.playerRespawnTime) / 120, 0), 1);
                            var p0 = easeInOut(a);
                            var p = easeInOut(a) * (1 - a);
                            game.cam.x = game.cam.x * (1 - p0) + game.cam.origin.x * p0;
                            game.cam.y = game.cam.y * (1 - p0) + game.cam.origin.y * p0;
                            game.cam.zoom = game.cam.zoom * (1 - p) + 1 * p;
                            game.cam.offset.x = game.cam.offset.x * (1 - p);
                            game.cam.offset.y = game.cam.offset.y * (1 - p);
                            if (this.playerRespawnTime <= 0) {
                                this.playerDead = false;
                                this.reload(this.level);
                            }
                        }
                    }

                    if (game.input.skip) {
                        if (levels[this.level].reload) levels[this.level].reload();
                        this.levelAnimationTime = 100000;
                        this.playerControlDelay = 0;
                    }

                    if (game.input.restartLevel) {
                        this.load(this.level);
                    }

                    if (game.input.restartGame) {
                        game.newGame();
                    }
                },
                drawLevelTransition: function () {
                    if (!this.levelTransition) return;
                    if (isNaN(this.lastPlayerPosition.x) || isNaN(this.lastPlayerPosition.y)) {
                        ctx.fillStyle = "black";
                        ctx.fillRect(0, 0, 1000, 1000);
                        return;
                    }
                    var a = easeInOut(this.levelTransition / (this.levelTransitionCap * 0.8));
                    var radius = (1 - a) * 1500;
                    var cors = game.cam.alignCoordinates(this.lastPlayerPosition.x + 20, this.lastPlayerPosition.y + 20);
                    var grd = ctx.createRadialGradient(cors.x, cors.y, radius, cors.x, cors.y, radius + 20);
                    grd.addColorStop(0, "rgba(0,0,0,0)");
                    grd.addColorStop(1, "rgba(0,0,0,1)");
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, 1000, 1000);

                    ctx.save();
                    ctx.fillStyle = "black";
                    ctx.globalAlpha = easeInOut((a - 0.99) * 100);
                    ctx.fillRect(0, 0, 1000, 1000);
                    ctx.restore();
                },
                createPlayer: function (x, y) {
                    var o = {
                        type: "player",
                        x: x,
                        y: y,
                        w: 40,
                        h: 40,
                        xmove: 0,
                        ymove: 0,
                        targetEyeHeight: 0,
                        eyeHeight: 0,
                        eyeDirection: 0,
                        wallSlideAnimation: 0,
                        wallSlideAnimationDirection: "right",
                        stretchAnimation: 0,
                        splatAnimation: 0,
                        lastJumpType: false,
                        runSkew: 0,
                        positionHistory: [],
                        eyePositions: [],
                        againstLeft: { current: false, last: 100, time: 0 },
                        againstRight: { current: false, last: 100, time: 0 },
                        againstTop: { current: false, last: 100, time: 0 },
                        againstBottom: { current: false, last: 100, time: 0 }
                    };
                    return o;
                },
                load: function (level) {
                    this.level = level;
                    this.levelAnimationTime = 0;
                    game.objects.objects = JSON.parse(JSON.stringify(levels[level].objects));
                    if (saveData.cubesCollected[this.level]) {
                        var cube = game.objects.objects.find(e => e.type == "cube");
                        if (cube) cube.collected = true;
                    }
                    if (saveData.redCubesCollected[this.level]) {
                        var cube = game.objects.objects.find(e => e.type == "cube" && e.red);
                        if (cube) cube.collected = true;
                    }
                    for (var o of game.objects.objects) {
                        if (o.type == "text") o.collide = false;
                        if (o.type == "arrow") o.collide = false;
                        if (o.type == "button") o.slippery = o.slippery || true;
                        if (!o.w || !o.h) o.collide = false;
                    }
                    this.playerSpawnPoint = levels[level].spawnPoint;
                    game.objects.objects.push(game.level.createPlayer(this.playerSpawnPoint.x, this.playerSpawnPoint.y));
                    game.cam.levelFunction = levels[level].camFunction || false;
                    game.cam.viewportBoundary = JSON.parse(JSON.stringify(levels[level].viewportBoundary));
                    game.cam.offset = JSON.parse(JSON.stringify(levels[level].camOffset));
                    var x = levels[level].camStartingPosition.x;
                    var y = levels[level].camStartingPosition.y;
                    if (!game.newGameFromMenu) {
                        game.cam.x = x;
                        game.cam.y = y;
                    }
                    game.newGameFromMenu = false;
                    game.cam.origin = { x: x, y: y };
                    game.cam.zoom = 1;
                    game.cam.speedModifiers = levels[level].camSpeedModifiers || false;
                    game.cam.followX = levels[level].camFollowX || 0.01;
                    game.cam.followY = levels[level].camFollowY || 0.01;
                    game.backgroundOffset = { x: 0, y: 0 };
                    game.backgroundOpacity = 1;
                    game.level.playerRespawnTime = 0;
                    game.level.playerDead = false;
                    if (levels[level].playerDeadFunction) {
                        this.playerDeadFunction = levels[level].playerDeadFunction;
                    } else {
                        this.playerDeadFunction = false;
                    }
                    if (levels[level].manualRespawn) {
                        this.manualRespawn = levels[level].manualRespawn;
                    } else {
                        this.manualRespawn = false;
                    }
                    if (levels[level].respawnTimeFunction) {
                        this.respawnTimeFunction = levels[level].respawnTimeFunction;
                    } else {
                        this.respawnTimeFunction = false;
                    }
                    this.playerControlDelay = levels[level].playerControlDelay || 0;
                    this.triggers.triggered = [];
                    this.triggers.triggerChecks = levels[level].triggers || [];
                    this.levelCompleteFunction = levels[level].levelComplete;
                    this.levelComplete = false;
                    game.background.effect.active = false;
                },
                reload: function (level) {
                    this.load(level);
                    for (var o of game.objects.objects) {
                        if (o.spawnAnimation) o.spawnAnimation = 0;
                    }
                    this.playerControlDelay = 0;
                    this.levelAnimationTime = 100000;
                    var player = game.objects.objects.find(e => e.type == "player");
                    player.spawnTime = 150;
                    player.spawnAnimation = 20;
                    game.background.effect.active = false;
                    if (levels[level].reload) levels[level].reload();
                },
                triggers: {
                    triggerChecks: [],
                    triggered: [],
                    tripped: function (name) {
                        return this.triggered.includes(name);
                    },
                    update: function () {
                        var untrip = [];
                        for (var trigger of this.triggerChecks) {
                            if (this.triggered.includes(trigger.name)) {
                                if (trigger.passive) trigger.passive();
                                if (trigger.stop && trigger.stop()) {
                                    if (trigger.untrip) trigger.untrip();
                                    untrip.push(trigger.name);
                                }
                                continue;
                            }
                            if (trigger.check()) {
                                this.triggered.push(trigger.name);
                                if (trigger.trip) trigger.trip();
                            }
                        }
                        this.triggered = this.triggered.filter(e => !untrip.includes(e));
                        for (var trigger of this.triggerChecks) {
                            if (this.triggered.includes(trigger.name)) {
                                if (trigger.passive) trigger.passive();
                            }
                        }
                    }
                }
            }
        }

        function drawRotatingCube(data) {
            var s = data.size || 30;
            var vertices = [
                { x: -s, y: -s, z: -s },
                { x: s, y: -s, z: -s },
                { x: s, y: s, z: -s },
                { x: -s, y: s, z: -s },
                { x: -s, y: -s, z: s },
                { x: s, y: -s, z: s },
                { x: s, y: s, z: s },
                { x: -s, y: s, z: s }
            ];
            var angle = data.zAngle || 0;
            for (var o of vertices) {
                var x = o.x * Math.cos(angle) - o.y * Math.sin(angle);
                var y = o.x * Math.sin(angle) + o.y * Math.cos(angle);
                o.x = x;
                o.y = y;
            }
            var angle = data.xAngle || 0;
            for (var o of vertices) {
                var y = o.y * Math.cos(angle) - o.z * Math.sin(angle);
                var z = o.y * Math.sin(angle) + o.z * Math.cos(angle);
                o.y = y;
                o.z = z;
            }
            var angle = data.yAngle || 0;
            for (var o of vertices) {
                var x = o.z * Math.sin(angle) + o.x * Math.cos(angle);
                var z = o.z * Math.cos(angle) - o.x * Math.sin(angle);
                o.x = x;
                o.z = z;
            }
            var edges = [
                [0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]
            ];
            var faces = [
                [0, 1, 2, 3], [4, 5, 6, 7], [2, 3, 7, 6], [0, 1, 5, 4], [1, 2, 6, 5], [0, 3, 7, 4]
            ];
            var faceCoordinates = [];
            var faceZValues = [];
            for (var face of faces) {
                var point1 = vertices[face[0]];
                var point2 = vertices[face[1]];
                var point3 = vertices[face[2]];
                var point4 = vertices[face[3]];
                var avgX = (point1.x + point2.x + point3.x + point4.x) / 4;
                var avgY = (point1.y + point2.y + point3.y + point4.y) / 4;
                var avgZ = (point1.z + point2.z + point3.z + point4.z) / 4;
                faceZValues.push(avgZ);
                faceCoordinates.push({ x: avgX, y: avgY, z: avgZ });
            }
            var sortedZValues = [...faceZValues].sort((a, b) => b - a);
            var faceOrder = [];
            for (var n = 0; n < faceZValues.length; n++) {
                var e = faceZValues[n];
                var order = sortedZValues.indexOf(e);
                while (faceOrder.includes(order)) order++;
                faceOrder.push(order);
            }
            ctx.strokeStyle = "black";
            ctx.lineWidth = 8;
            ctx.lineCap = "round";
            for (var edge of edges) {
                if (data.border === false) break;
                ctx.beginPath();
                ctx.moveTo(vertices[edge[0]].x, vertices[edge[0]].y);
                ctx.lineTo(vertices[edge[1]].x, vertices[edge[1]].y);
                ctx.stroke();
            }
            for (var n = faceOrder.length - 3; n < faceOrder.length; n++) {
                var index = faceOrder.indexOf(n);
                var face = faces[index];
                var position = faceCoordinates[index];
                var x = (position.x + 50) / 100;
                var y = (position.y + 50) / 100;
                var z = (position.z + 50) / 100;
                ctx.fillStyle = data.colorFunction(x, y, z, n);
                ctx.beginPath();
                ctx.moveTo(vertices[face[0]].x, vertices[face[0]].y);
                ctx.lineTo(vertices[face[1]].x, vertices[face[1]].y);
                ctx.lineTo(vertices[face[2]].x, vertices[face[2]].y);
                ctx.lineTo(vertices[face[3]].x, vertices[face[3]].y);
                ctx.fill();
            }
        }

        var noise = function (x, y, z) {
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y, z) {
                var h = hash & 15;
                var u = h < 8 ? x : y,
                    v = h < 4 ? y : h == 12 || h == 14 ? x : z;
                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
            }
            function scale(n) { return (1 + n) / 2; }

            var p = new Array(512)
            var permutation = [151, 160, 137, 91, 90, 15,
                131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
                190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
                88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
                77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
                102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
                135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
                5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
                223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
                129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
                251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
                49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
                138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
            ];
            for (var i = 0; i < 256; i++)
                p[256 + i] = p[i] = permutation[i];

            var X = Math.floor(x) & 255,
                Y = Math.floor(y) & 255,
                Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            var u = fade(x),
                v = fade(y),
                w = fade(z);
            var A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z,
                B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;

            return scale(lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
                grad(p[BA], x - 1, y, z)),
                lerp(u, grad(p[AB], x, y - 1, z),
                    grad(p[BB], x - 1, y - 1, z))),
                lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1),
                    grad(p[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
                        grad(p[BB + 1], x - 1, y - 1, z - 1)))));
        }

        var saveData = false;
        var saveDataStored = false;
        if (localStorage.getItem("oppositeday2savedata") !== null) {
            saveData = JSON.parse(localStorage.getItem("oppositeday2savedata"));
            saveDataStored = true;
        }

        function updateSaveData() {
            localStorage.setItem("oppositeday2savedata", JSON.stringify(saveData));
            saveDataStored = true;
        }

        function deleteSaveData() {
            localStorage.removeItem("oppositeday2savedata");
            saveDataStored = false;
        }

        /*menu.titleScreen = 0;
        menu.titleScreenAnimation = 0;
        game.newGame();
        Loading.intro = false;
        Loading.loaded = true;
        /*
        Level 1: Classic intro scene
        Level 2: Stepping stones
        Level 3: Mountain of persistence
        Level 4: The pit
        Level 5: Don't press the button
        Level 6: Passcode
        Level 7: 
        Level 8: Short and Simple:
            Normal Level
            Jump
            Sokoban
            Snake
            Pac Man
            Ping Pong
            Circles
            Opposite Day 1
        Level 9: Boss Battle
        Level 10: No tricks here
        */
    </script>
</body>

</html>