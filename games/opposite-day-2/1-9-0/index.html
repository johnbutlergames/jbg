<!DOCTYPE HTML>
<html>

<body>
    <canvas id="canvas"></canvas>
    <script src="https://johnbutlergames.w3spaces.com/game-setup.js"></script>
    <script src="levels.js"></script>
    <style>
        @font-face {
            font-family: rubik;
            src: url("fonts/Rubik-Regular.ttf");
        }

        @font-face {
            font-family: rubikbold;
            src: url("fonts/Rubik-SemiBold.ttf");
        }

        @font-face {
            font-family: rubikitalic;
            src: url("fonts/Rubik-Italic.ttf");
        }

        @font-face {
            font-family: rubikbolditalic;
            src: url("fonts/Rubik-SemiBoldItalic.ttf");
        }
    </style>
    <script>
        var title = "Opposite Day 2";
        var dimensions = { width: 1000, height: 1000 };
        var images = {
            "demon": "images/demon.png",
            "skull": "images/skull.png",
            "skull": "images/skull.png",
            "botBody": "images/bot-body.png",
            "gravitySwitcher3": "images/gravity-switcher3.png",
            "gravitySwitcher2": "images/gravity-switcher2.png",
            "gravitySwitcher": "images/gravity-switcher.png",
            "gravitySwitch2": "images/gravity-switch2.png",
            "gravitySwitch": "images/gravity-switch.png",
            "coinDashBackground": "images/coin-dash-background.png",
            "circlesBackground": "images/circles-background.png",
            "pingPongBackground": "images/ping-pong-background.png",
            "snakeBackground": "images/snake-background.png",
            "sokobanBackground": "images/sokoban-background.png",
            "sokobanCubeBackground": "images/sokoban-cube-background.png",
            "pacmanBackground": "images/pacman-background.png",
            "pacmanRedCubeBackground": "images/pacman-red-cube-background.png",
            "pacmanRedCubeWonBackground": "images/pacman-red-cube-won-background.png",
            "ghostSpritesheet": "images/ghost-spritesheet.png",
            "pacmanDeath": "images/pacman-death.png",
            "sokobanBox": "images/sokoban-box.png",
            "sokobanBlueBox": "images/sokoban-blue-box.png",
            "sokobanBlueBoxLit": "images/sokoban-blue-box-lit.png",
            "jumpEnemy": "images/jump-enemy.png",
            "greenSparkle": "images/green-sparkle.png",
            "arrows": "images/keys-arrows.png",
            "wasd": "images/keys-wasd.png",
            "circuitRed": "images/circuit-red.png",
            "circuitBlack": "images/circuit-black.png",
            "circuitPurple": "images/circuit-purple.png",
            "bossSpritesheet": "images/boss-spritesheet.png",
            "heartsSpritesheet": "images/hearts-spritesheet.png",
            "checkmark": "images/checkmark.png",
            "shortcutDiscovered": "images/shortcut-discovered.png",
            "shortcutTaken": "images/shortcut-taken.png",
            "redCube": "images/red-cube.png",
            "blueCube": "images/blue-cube.png",
            "uncollectedCube": "images/uncollected-cube.png",
            "lock": "images/lock.png",
            "level1": "images/level1.png",
            "level2": "images/level2.png",
            "level3": "images/level3.png",
            "level4": "images/level4.png",
            "level5": "images/level5.png",
            "level6": "images/level6.png",
            "level7": "images/level7.png",
            "level8": "images/level8.png",
            "level9": "images/level9.png",
            "level10": "images/level10.png"
        };
        var audios = {
            "collectBlueCube": "sound-effects/collect-blue-cube.mp3",
            "recollectBlueCube": "sound-effects/recollect-blue-cube.mp3",
            "blueCubeClue": "sound-effects/blue-cube-clue.mp3",
            "blueCubePreClue": "sound-effects/blue-cube-pre-clue.mp3",
            "shortcut": "sound-effects/shortcut.mp3",
            "preShortcut": "sound-effects/pre-shortcut.mp3",
            "collectRedCube": "sound-effects/collect-red-cube.mp3",
            "recollectRedCube": "sound-effects/recollect-red-cube.mp3",
            "redCubeClue": "sound-effects/red-cube-clue.mp3",
            "redCubePreClue": "sound-effects/red-cube-pre-clue.mp3",
            "sokobanBox1": "sound-effects/sokoban-box-1.mp3",
            "sokobanBox2": "sound-effects/sokoban-box-2.mp3",
            "sokobanBox3": "sound-effects/sokoban-box-3.mp3",
            "sokobanBox4": "sound-effects/sokoban-box-4.mp3",
            "sokobanBox5": "sound-effects/sokoban-box-5.mp3",
            "sokobanBox6": "sound-effects/sokoban-box-6.mp3",
            "sokobanBox7": "sound-effects/sokoban-box-7.mp3",
            "sokobanBox8": "sound-effects/sokoban-box-8.mp3",
            "pressButton": "sound-effects/press-button.mp3",
            "doorSlam": "sound-effects/door-slam.mp3",
            "gravitySwitch": "sound-effects/gravity-switch.mp3",
            "buzzer": "sound-effects/buzzer.mp3",
            "eatDot1": "sound-effects/eat-dot1.mp3",
            "eatDot2": "sound-effects/eat-dot2.mp3",
            "collectCoin": "sound-effects/collect-coin.mp3",
            "death": "sound-effects/death.mp3",
            "jump1": "sound-effects/jump1.mp3",
            "jump2": "sound-effects/jump2.mp3",
            "jump3": "sound-effects/jump3.mp3",
            "wallJump": "sound-effects/wall-jump.mp3",
            "land1": "sound-effects/land1.mp3",
            "land2": "sound-effects/land2.mp3",
            "land3": "sound-effects/land3.mp3",
            "wallHit": "sound-effects/wall-hit.mp3",
            "heavyLand": "sound-effects/heavy-land.mp3",
            "heaviestLand": "sound-effects/heaviest-land.mp3",
            "whoosh": "sound-effects/whoosh.mp3",
            "reverseWhoosh": "sound-effects/reverse-whoosh.mp3",
            "bubblesStart": "sound-effects/bubbles-start.mp3",
            "bubblesEnd": "sound-effects/bubbles-end.mp3",
            "bubbles": "sound-effects/bubbles.mp3",
            "killJumpEnemy": "sound-effects/kill-jump-enemy.mp3",
            "pingPongHit": "sound-effects/ping-pong-hit.mp3",
            "bossFireballExplosion": "sound-effects/boss-fireball-explosion.mp3",
            "bossShootFireball": "sound-effects/boss-shoot-fireball.mp3",
            "bossHurt": "sound-effects/boss-hurt.mp3",
            "landGlass1": "sound-effects/land-glass1.mp3",
            "landGlass2": "sound-effects/land-glass2.mp3",
            "landGlass3": "sound-effects/land-glass3.mp3",
            "platformMove": "sound-effects/platform-move.mp3",
        };

        initialize();
        audios.bubbles.volume = 0;
        window.setInterval(update, 10);
        var t = 0;
        var frame = 0;
        var frameRate = 1;
        var ppougjgaming = false;
        var notobiv = false;
        var kribit = false;
        var johnbutlergames = false;
        var larrythehamster = false;
        function clearCharSfx() {
            ppougjgaming = false;
            notobiv = false;
            kribit = false;
            larrythehamster = false;
        }

        function main() {
            if (word.toLowerCase().endsWith("johnbutlergames")) {
                clearCharSfx();
                word = "";
                johnbutlergames = !johnbutlergames;
                updateSaveData();
            }
            if (word.toLowerCase().endsWith("ppougjgaming")) {
                clearCharSfx();
                word = "";
                ppougjgaming = !ppougjgaming;
                updateSaveData();
            }
            if (word.toLowerCase().endsWith("notobiv")) {
                clearCharSfx();
                word = "";
                notobiv = !notobiv;
                updateSaveData();
            }
            if (word.toLowerCase().endsWith("kribit")) {
                clearCharSfx();
                word = "";
                kribit = !kribit;
                updateSaveData();
            }
            if (word.toLowerCase().endsWith("larrythehamster")) {
                clearCharSfx();
                word = "";
                larrythehamster = !larrythehamster;
                updateSaveData();
            }
            menu.tick();
            t++;
        }

        var menu = {
            titleScreen: true,
            levelSelectScreen: false,
            levelSelectAnimation: 0,
            wipeSaveScreen: false,
            wipeSaveAnimation: 0,
            titleScreenAnimation: 0,
            firstButtonAnimation: 0,
            secondButtonAnimation: 0,
            backButtonAnimation: 0,
            newGameAnimation: 0,
            loadingLevel: false,
            loadingLevelAnimation: 0,
            levelSelectAnimations: [],
            creditsScreen: false,
            creditsScreenAnimation: 0,
            creditsContinueButtonAnimation: 0,
            movedCreditsScreen: false,
            tick: function () {
                this.update();
                this.draw();
            },
            update: function () {
                if (this.creditsScreen) {
                    this.updateCreditsScreen();
                    game.background.update();
                } else if (this.titleScreen) {
                    this.updateTitleScreen();
                    game.background.update();
                } else {
                    if (t % frameRate == 0) {
                        frame++;
                        game.update();
                    }
                }
            },
            draw: function () {
                if (this.creditsScreen) {
                    this.drawCreditsScreen();
                } else if (this.titleScreen) {
                    this.drawTitleScreen();
                } else {
                    game.draw();
                }
            },
            updateTitleScreen: function () {
                if (this.levelSelectScreen) {
                    this.levelSelectAnimation++;
                } else {
                    this.levelSelectAnimation--;
                }
                this.levelSelectAnimation = Math.max(Math.min(this.levelSelectAnimation, 40), 0);

                if (this.wipeSaveScreen) {
                    this.wipeSaveAnimation++;
                } else {
                    this.wipeSaveAnimation--;
                }
                this.wipeSaveAnimation = Math.max(Math.min(this.wipeSaveAnimation, 40), 0);

                if (this.newGameAnimation) {
                    this.newGameAnimation++;
                    var speed = Math.min(this.newGameAnimation, (-180 - game.cam.y) / 10);
                    game.cam.y += speed;
                    game.cam.y = Math.min(game.cam.y, -200);
                    game.cam.x = 0 * 0.05 + game.cam.x * 0.95;
                    if (this.newGameAnimation > 80) {
                        this.titleScreen = false;
                    }
                    return;
                }
                if (this.loadingLevelAnimation) {
                    this.loadingLevelAnimation++;
                    if (this.loadingLevelAnimation > 80) {
                        this.titleScreen = false;
                        game.level.load(this.loadingLevel);
                        game.level.levelTransition = game.level.levelTransitionCap;
                        game.ui.timer.newLevel();
                    }
                }
                if (this.loadingLevelAnimation < 80) {
                    this.titleScreenAnimation++;
                    game.cam.x = (t / 5 % (350 * 2 / 0.8));
                    game.cam.y = -2000 + (t % (350 * 2 / 0.8));
                }

                var text1 = "Not New Game";
                var text2 = false;
                if (saveDataStored) {
                    text1 = "Don't Continue";
                    text2 = "Not New Game";
                }
                ctx.font = "70px rubik";
                var width = ctx.measureText(text1).width;
                if (Mouse.inBox(500 - width / 2, 460 - 70 / 2 - 10, width, 70 + 20) && !this.levelSelectAnimation) {
                    this.firstButtonAnimation++;
                    if (Mouse.click) {
                        if (this.wipeSaveScreen) {
                            game.newGameFromMenu = true;
                            game.newGame();
                            this.newGameAnimation = 1;
                        } else {
                            if (text1 == "Don't Continue") {
                                this.levelSelectScreen = true;
                                Mouse.click = false;
                            } else {
                                game.newGameFromMenu = true;
                                game.newGame();
                                this.newGameAnimation = 1;
                            }
                        }
                    }
                } else {
                    this.firstButtonAnimation--;
                }
                var width = ctx.measureText(text2).width;
                if (Mouse.inBox(500 - width / 2, 600 - 70 / 2 - 10, width, 70 + 20) && (text2 || this.wipeSaveAnimation) && !this.levelSelectAnimation) {
                    this.secondButtonAnimation++;
                    if (Mouse.click) {
                        this.wipeSaveScreen = !this.wipeSaveScreen;
                    }
                } else {
                    this.secondButtonAnimation--;
                }
                var width = ctx.measureText("Not Back").width;
                if (Mouse.inBox(500 - width / 2, 900 - 70 / 2 - 10, width, 70 + 20) && this.levelSelectAnimation && !this.loadingLevel) {
                    this.backButtonAnimation++;
                    if (Mouse.click) {
                        this.levelSelectScreen = false;
                    }
                } else {
                    this.backButtonAnimation--;
                }
                this.firstButtonAnimation = Math.min(Math.max(0, this.firstButtonAnimation), 15);
                this.secondButtonAnimation = Math.min(Math.max(0, this.secondButtonAnimation), 15);
                this.backButtonAnimation = Math.min(Math.max(0, this.backButtonAnimation), 15);

                this.updateLevelSelectScreen();
                this.updateWipeSaveScreen();
            },
            drawTitleScreen: function () {
                game.draw();

                ctx.save();
                if (this.levelSelectAnimation) {
                    var a = easeInOut(this.levelSelectAnimation / 40);
                    ctx.translate(-a * 1000, 0);
                }
                if (this.wipeSaveAnimation) {
                    var a = easeInOut(this.wipeSaveAnimation / 40);
                    ctx.translate(a * 1000, 0);
                }

                if (this.titleScreenAnimation < 20) {
                    ctx.save();
                    ctx.fillStyle = "white";
                    ctx.globalAlpha = 1 - this.titleScreenAnimation / 20;
                    ctx.fillRect(0, 0, 1000, 1000);
                    ctx.restore();
                }

                ctx.fillStyle = "black";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "100px rubikbold";

                var fade = 1 - easeInOut(this.newGameAnimation / 40);

                var a = easeInOut((this.titleScreenAnimation - 20) / 40) * fade;
                ctx.save();
                ctx.translate(500, 200);
                ctx.scale(a, a);
                ctx.fillText("Opposite Day 2", 0, 0);
                ctx.restore();

                var text1 = "Not New Game";
                var text2 = false;
                if (saveDataStored) {
                    text1 = "Don't Continue";
                    text2 = "Not New Game";
                }
                ctx.font = "70px rubik";
                var a = easeInOut((this.titleScreenAnimation - 70) / 40) * (1 + easeInOut(this.firstButtonAnimation / 15) * 0.1) * fade;
                ctx.save();
                ctx.translate(500, 460);
                ctx.scale(a, a);
                ctx.fillText(text1, 0, 0);
                ctx.globalAlpha = this.firstButtonAnimation / 15;
                ctx.fillText(`[  ${text1}  ]`, 0, 0);
                ctx.restore();

                if (text2) {
                    var a = easeInOut((this.titleScreenAnimation - 90) / 40) * (1 + easeInOut(this.secondButtonAnimation / 15) * 0.1) * fade;
                    ctx.save();
                    ctx.translate(500, 600);
                    ctx.scale(a, a);
                    ctx.fillText(text2, 0, 0);
                    ctx.globalAlpha = this.secondButtonAnimation / 15;
                    ctx.fillText(`[  ${text2}  ]`, 0, 0);
                    ctx.restore();
                }

                ctx.font = "40px rubik";
                var a = easeInOut((this.titleScreenAnimation - 120) / 40) * fade;
                ctx.save();
                ctx.translate(500, 940);
                ctx.scale(a, a);
                ctx.fillText("Not by John Butler", 0, 0);
                ctx.restore();

                this.drawLevelSelectScreen(fade);
                this.drawWipeSaveScreen(fade);

                ctx.restore();
            },
            updateWipeSaveScreen: function () {
            },
            drawWipeSaveScreen: function (fade) {
                ctx.font = "100px rubikbold";
                ctx.save();
                ctx.translate(-500, 200);
                ctx.scale(fade, fade);
                ctx.fillText("Aren't You Sure?", 0, 0);
                ctx.restore();

                ctx.font = "40px rubik";
                ctx.save();
                ctx.translate(-500, 305);
                ctx.scale(fade, fade);
                ctx.fillText("This action will permanently", 0, -25);
                ctx.fillText("undelete your past progress.", 0, 25);
                ctx.restore();

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.firstButtonAnimation / 15) * 0.1) * fade;
                ctx.save();
                ctx.translate(-500, 460);
                ctx.scale(a, a);
                ctx.fillText("Unproceed", 0, 0);
                ctx.globalAlpha = this.firstButtonAnimation / 15;
                ctx.fillText(`[  Unproceed  ]`, 0, 0);
                ctx.restore();

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.secondButtonAnimation / 15) * 0.1) * fade;
                ctx.save();
                ctx.translate(-500, 600);
                ctx.scale(a, a);
                ctx.fillText("Uncancel", 0, 0);
                ctx.globalAlpha = this.secondButtonAnimation / 15;
                ctx.fillText(`[  Uncancel  ]`, 0, 0);
                ctx.restore();
            },
            updateLevelSelectScreen: function () {
                if (this.levelSelectAnimations.length == 0) {
                    for (var n = 0; n < 10; n++) {
                        this.levelSelectAnimations.push({ shake: 0, selected: 0, hover: 0 });
                    }
                }
                if (this.loadingLevel === false) {
                    if (this.levelSelectScreen) {
                        for (var n = 0; n < 10; n++) {
                            var x = n % 5;
                            var y = Math.floor(n / 5);
                            var box = { x: 150 + x * 150, y: 430 + y * 200, w: 100, h: 100 };
                            if (Mouse.inBox(box.x, box.y, box.w, box.h)) {
                                if (saveData.levelsBeaten > n - 1) {
                                    if (Mouse.click) {
                                        this.levelSelectAnimations[n].selected = 1;
                                        this.loadingLevel = n;
                                        this.loadingLevelAnimation = 1;
                                    } else {
                                        this.levelSelectAnimations[n].hover++;
                                    }
                                } else {
                                    this.levelSelectAnimations[n].hover += 0.3;
                                    if (Mouse.click) {
                                        this.levelSelectAnimations[n].shake = 40;
                                    }
                                }
                            } else {
                                this.levelSelectAnimations[n].hover -= 0.1;
                            }
                        }
                    } else {
                        for (var n = 0; n < 10; n++) {
                            this.levelSelectAnimations[n].hover--;
                        }
                    }
                }
                for (var n = 0; n < 10; n++) {
                    if (this.levelSelectAnimations[n].selected) {
                        this.levelSelectAnimations[n].selected++;
                    }
                    if (this.loadingLevel === false) {
                        this.levelSelectAnimations[n].hover *= 0.85;
                        this.levelSelectAnimations[n].hover = Math.max(this.levelSelectAnimations[n].hover, 0);
                    }
                    this.levelSelectAnimations[n].shake--;
                    this.levelSelectAnimations[n].shake = Math.max(this.levelSelectAnimations[n].shake, 0);
                }
            },
            drawLevelSelectScreen: function (fade) {
                ctx.font = "100px rubikbold";
                ctx.fillText("Level Deselect", 1500, 200);

                ctx.font = "40px rubik";
                var percentComplete;
                var barPercent;
                if (!saveData) {
                    barPercent = 0;
                    percentComplete = 0;
                } else {
                    var levelAmount = 10;
                    var levelsComplete = saveData.levelsBeaten / levelAmount;
                    var blueCubes = saveData.cubesCollected.filter(e => e === true).length / levelAmount;
                    var redCubes = saveData.redCubesCollected.filter(e => e === true).length / levelAmount;
                    var shortcuts = saveData.shortcutsTaken.filter(e => e === true).length / levelAmount;
                    percentComplete = levelsComplete * 0.5 + blueCubes * 0.2 + redCubes * 0.2 + shortcuts * 0.1;
                    barPercent = percentComplete;
                }
                if (isNaN(percentComplete)) percentComplete = 0;
                var percentCompleteText = Math.floor(percentComplete * 100);
                ctx.fillText(percentCompleteText + "% Incomplete", 1500, 350);

                ctx.lineCap = "round";
                ctx.strokeStyle = "black";
                ctx.lineWidth = 20;
                ctx.beginPath();
                ctx.moveTo(1200, 300);
                ctx.lineTo(1800, 300);
                ctx.stroke();
                ctx.strokeStyle = "rgb(100,100,255)";
                ctx.lineWidth = 10;
                ctx.beginPath();
                ctx.moveTo(1200, 300);
                ctx.lineTo(1200 + 600 * barPercent, 300);
                ctx.stroke();

                for (var n = 0; n < levelAmount; n++) {
                    var x = n % 5;
                    var y = Math.floor(n / 5);
                    ctx.save();
                    ctx.translate(1150 + x * 150, 430 + y * 200);
                    var a = this.levelSelectAnimations[n];
                    if (a === undefined) {
                        a = {
                            hover: 0,
                            selected: 0,
                            shake: 0
                        }
                    }
                    var s = 1 + a.hover * 0.03;
                    s -= 0.5 * easeInOut(a.selected / 20);
                    ctx.translate(50, 50);
                    ctx.scale(s, s);
                    if (a.shake) {
                        ctx.rotate(Math.sin(t / 3) * a.shake / 3 * Math.PI / 180);
                    }
                    ctx.translate(-50, -50);

                    if (saveData.levelsBeaten > n - 1) {
                        ctx.fillStyle = "white";
                    } else {
                        ctx.fillStyle = "rgb(200,200,200)";
                    }
                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 4;
                    ctx.lineJoin = "round";
                    ctx.lineCap = "round";
                    ctx.fillRect(0, 0, 100, 100);
                    if (saveData.levelsBeaten > n - 1) {
                        if (images["level" + (n + 1)]) ctx.drawImage(images["level" + (n + 1)], 0, 0, 100, 100);
                    } else {
                        ctx.drawImage(images.lock, 0, 0, 100, 100);
                    }
                    ctx.strokeRect(0, 0, 100, 100);

                    if (saveData.levelsBeaten > n) {
                        ctx.drawImage(images.checkmark, 80, -20, 40, 40);
                    }
                    if (saveData.shortcutsTaken[n]) {
                        ctx.drawImage(images.shortcutTaken, 60, -40, 40, 40);
                    } else if (saveData.shortcutsDiscovered[n]) {
                        ctx.drawImage(images.shortcutDiscovered, 60, -40, 40, 40);
                    }

                    if (saveData.levelsBeaten > n - 1) {
                        if (saveData.redCubesCollected[n] || saveData.redCubesDiscovered[n]) {
                            if (saveData.redCubesCollected[n]) {
                                ctx.drawImage(images.redCube, 55, 110, 45, 45);
                            } else {
                                ctx.drawImage(images.uncollectedCube, 55, 110, 45, 45);
                            }
                            if (saveData.cubesCollected[n]) {
                                ctx.drawImage(images.blueCube, 5, 110, 45, 45);
                            } else {
                                ctx.drawImage(images.uncollectedCube, 5, 110, 45, 45);
                            }
                        } else {
                            if (saveData.cubesCollected[n]) {
                                ctx.drawImage(images.blueCube, 27.5, 110, 45, 45);
                            } else {
                                ctx.drawImage(images.uncollectedCube, 27.5, 110, 45, 45);
                            }
                        }
                    }

                    ctx.restore();
                }

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.backButtonAnimation / 15) * 0.1);
                ctx.save();
                ctx.translate(1500, 900);
                ctx.scale(a, a);
                ctx.fillText("Not Back", 0, 0);
                ctx.globalAlpha = this.backButtonAnimation / 15;
                ctx.fillText(`[  Not Back  ]`, 0, 0);
                ctx.restore();

                if (this.loadingLevelAnimation) {
                    var a = easeInOut(this.loadingLevelAnimation / 80);
                    var radius = (1 - a) * 1500;
                    var cors = {};
                    var n = this.loadingLevel;
                    cors.x = 1150 + n % 5 * 150 + 50;
                    cors.y = 430 + Math.floor(n / 5) * 200 + 50;
                    var grd = ctx.createRadialGradient(cors.x, cors.y, radius, cors.x, cors.y, radius + 20);
                    grd.addColorStop(0, "rgba(0,0,0,0)");
                    grd.addColorStop(1, "rgba(0,0,0,1)");
                    ctx.fillStyle = grd;
                    ctx.fillRect(1000, 0, 1000, 1000);

                    ctx.save();
                    ctx.fillStyle = "black";
                    ctx.globalAlpha = easeInOut((a - 0.99) * 100);
                    ctx.fillRect(1000, 0, 1000, 1000);
                    ctx.restore();
                }
            },
            updateCreditsScreen: function () {
                if (!this.movedCreditsScreen) this.creditsScreenAnimation++;
                if (this.creditsScreenAnimation < 50) return;
                if (Keys.keys[38] || Keys.keys[87]) {
                    this.creditsScreenAnimation -= 40;
                    this.movedCreditsScreen = true;
                }
                if (Keys.keys[40] || Keys.keys[83]) {
                    this.creditsScreenAnimation += 40;
                    this.movedCreditsScreen = true;
                }
                if (Mouse.scrollY) {
                    this.creditsScreenAnimation += Mouse.scrollY * 5;
                    this.movedCreditsScreen = true;
                }
                this.creditsScreenAnimation = Math.min(Math.max(this.creditsScreenAnimation, 50), 7740);

                var y = Math.max((this.creditsScreenAnimation - 200) / 4, 0);
                ctx.font = "70px rubik"
                var width = ctx.measureText("Don't Continue").width;
                if (Mouse.inBox(500 - width / 2, 2790 - y - 70 / 2 - 10, width, 70 + 20)) {
                    this.creditsContinueButtonAnimation++;
                    if (Mouse.click) {
                        this.creditsScreen = false;
                        this.titleScreen = true;
                        this.levelSelectScreen = true;
                        this.levelSelectAnimation = 40;
                        this.newGameAnimation = 0;
                        this.loadingLevel = false;
                        this.loadingLevelAnimation = 0;
                        game.level.load(0);
                        game.ui.timer.newLevel();
                    }
                } else {
                    this.creditsContinueButtonAnimation--;
                }
                this.creditsContinueButtonAnimation = Math.min(Math.max(0, this.creditsContinueButtonAnimation), 15);
            },
            drawCreditsScreen: function () {
                var a = easeInOut(this.creditsScreenAnimation / 50);
                ctx.fillStyle = `rgb(${50 + a * 100},${50 + a * 130},255)`;
                ctx.fillRect(0, 0, 1000, 1000);
                ctx.fillStyle = "black";

                var y = Math.max((this.creditsScreenAnimation - 200) / 4, 0);
                ctx.save();
                ctx.translate(0, -y);
                ctx.globalAlpha = a;

                ctx.font = "120px rubikbold";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("You Lose!", 500, 180);
                ctx.font = "40px rubik";
                ctx.fillText("Degratulations!", 500, 260);
                ctx.translate(0, 400);

                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = `rgb(${50 + a * 80},${50 + a * 110},255)`;
                ctx.roundRect(160, -50, 680, 160, 10);
                ctx.fill();
                ctx.restore();

                ctx.fillStyle = "black";
                ctx.font = "40px rubik";
                ctx.fillText("You didn't complete this game in", 500, 0);
                ctx.font = "50px rubikbold";
                ctx.fillText(createTimeText(game.ui.timer.gameTime), 500, 60);
                ctx.translate(0, 180);

                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = `rgb(${50 + a * 80},${50 + a * 110},255)`;
                ctx.roundRect(160, -50, 680, 200, 10);
                ctx.fill();
                ctx.fillStyle = `rgb(${50 + a * 65},${50 + a * 95},255)`;
                ctx.roundRect(180, -30, 160, 160, 10);
                ctx.fill();
                ctx.restore();

                ctx.textAlign = "left";
                ctx.font = "40px rubik";
                ctx.fillText("You haven't collected", 380, 0);
                ctx.font = "50px rubikbold";
                var width1 = ctx.measureText("0 / 10").width;
                ctx.font = "50px rubikbold";
                var blueCubesCollected = saveData.cubesCollected.filter(e => e).length;
                ctx.fillText(blueCubesCollected + " / 10", 380, 60);
                ctx.font = "40px rubik";
                ctx.fillText("blue cubes", 380, 110);
                ctx.save();
                ctx.translate(260, 50);
                ctx.globalAlpha = 1;
                ctx.scale(a, a);
                drawRotatingCube({
                    size: 30,
                    xAngle: t / 150,
                    yAngle: t / 170,
                    zAngle: t / 180,
                    colorFunction: function (x, y, z, n) {
                        var l = (1 - y) * 150 + x * 50;
                        var r = 20 + l;
                        var g = 20 + l * 1.2;
                        var b = 220 + l / 3;
                        return `rgb(${r},${g},${b})`;
                    }
                });
                ctx.restore();
                ctx.translate(0, 220);

                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = `rgb(${50 + a * 80},${50 + a * 110},255)`;
                ctx.roundRect(160, -50, 680, 200, 10);
                ctx.fill();
                ctx.fillStyle = `rgb(${50 + a * 65},${50 + a * 95},255)`;
                ctx.roundRect(180, -30, 160, 160, 10);
                ctx.fill();
                ctx.restore();

                ctx.textAlign = "left";
                ctx.font = "40px rubik";
                ctx.fillText("You haven't collected", 380, 0);
                ctx.font = "50px rubikbold";
                var width1 = ctx.measureText("0 / 10").width;
                ctx.font = "50px rubikbold";
                var redCubesCollected = saveData.redCubesCollected.filter(e => e).length;
                ctx.fillText(redCubesCollected + " / 10", 380, 60);
                ctx.font = "40px rubik";
                ctx.fillText("red cubes", 380, 110);
                ctx.save();
                ctx.translate(260, 50);
                ctx.globalAlpha = 1;
                ctx.scale(a, a);
                if (redCubesCollected > 0) {
                    drawRotatingCube({
                        size: 30,
                        xAngle: (t + 200) / 150,
                        yAngle: (t + 200) / 170,
                        zAngle: (t + 200) / 180,
                        colorFunction: function (x, y, z, n) {
                            var l = (1 - y) * 150 + x * 50;
                            var r = 220 + l / 3;
                            var g = 20 + l;
                            var b = 20 + l;
                            return `rgb(${r},${g},${b})`;
                        }
                    });
                } else {
                    ctx.textAlign = "center";
                    ctx.font = "100px rubikbold";
                    ctx.fillText("?", 0, 5);
                }
                ctx.restore();
                ctx.translate(0, 220);

                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = `rgb(${50 + a * 80},${50 + a * 110},255)`;
                ctx.roundRect(160, -50, 680, 200, 10);
                ctx.fill();
                ctx.fillStyle = `rgb(${50 + a * 65},${50 + a * 95},255)`;
                ctx.roundRect(180, -30, 160, 160, 10);
                ctx.fill();
                ctx.restore();

                ctx.textAlign = "left";
                ctx.font = "40px rubik";
                ctx.fillText("You haven't taken", 380, 0);
                ctx.font = "50px rubikbold";
                var width1 = ctx.measureText("0 / 10").width;
                ctx.font = "50px rubikbold";
                var shortcutsTaken = saveData.shortcutsTaken.filter(e => e).length;
                ctx.fillText(shortcutsTaken + " / 10", 380, 60);
                ctx.font = "40px rubik";
                ctx.fillText("shortcuts", 380, 110);
                ctx.save();
                ctx.translate(260, 50);
                ctx.globalAlpha = 1;
                ctx.scale(a, a);
                if (shortcutsTaken > 0) {
                    var time = t;
                    var s = 0.7 + Math.max(Math.sin(time / 40) - 0.93, 0) * 3;
                    ctx.save();
                    ctx.translate(-20, -15);
                    ctx.rotate(time * 0.8 * Math.PI / 180);
                    ctx.scale(s, s);
                    ctx.drawImage(images.greenSparkle, -30, -30, 60, 60);
                    ctx.restore();
                    var time = t - 10;
                    var s = 0.7 + Math.max(Math.sin(time / 40) - 0.93, 0) * 3;
                    ctx.save();
                    ctx.translate(35, -10);
                    ctx.rotate(time * 0.9 * Math.PI / 180);
                    ctx.scale(s, s);
                    ctx.drawImage(images.greenSparkle, -20, -20, 40, 40);
                    ctx.restore();
                    var time = t - 20;
                    var s = 0.7 + Math.max(Math.sin(time / 40) - 0.93, 0) * 3;
                    ctx.save();
                    ctx.translate(10, 30);
                    ctx.rotate(time * Math.PI / 180);
                    ctx.scale(s, s);
                    ctx.drawImage(images.greenSparkle, -15, -15, 30, 30);
                    ctx.restore();
                } else {
                    ctx.textAlign = "center";
                    ctx.font = "100px rubikbold";
                    ctx.fillText("?", 0, 5);
                }
                ctx.restore();
                ctx.translate(0, 250);

                ctx.textAlign = "center";
                ctx.fillStyle = "black";
                ctx.font = "40px rubik";
                ctx.fillText("No thanks for playing.", 500, 0);
                ctx.fillText("Not by John Butler.", 500, 60);
                ctx.fillText("Don't go play Opposite Day 1 if you haven't.", 500, 180);
                ctx.translate(0, 300);

                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = `rgb(${50 + a * 65},${50 + a * 95},255)`;
                ctx.roundRect(140, -50, 720, 200, 10);
                ctx.fill();
                ctx.fillStyle = `rgb(${50 + a * 80},${50 + a * 110},255)`;
                ctx.roundRect(70, 40, 860, 690, 10);
                ctx.fill();
                ctx.restore();

                ctx.font = "40px rubik";
                ctx.fillText("No thanks to any of my beta testers:", 500, 0);
                ctx.font = "30px rubik";
                for (var n = 0; n < betaTesters.length; n++) {
                    var name = betaTesters[n];
                    var y = Math.floor(n / 3) * 50 + 90;
                    ctx.textAlign = "center";
                    if (n % 3 === 0) {
                        ctx.fillText(name, 235, y);
                    } else if (n % 3 === 1) {
                        ctx.fillText(name, 500, y);
                    } else {
                        ctx.fillText(name, 765, y);
                    }
                }
                ctx.font = "40px rubik";
                ctx.fillText("or anyone else that helped along the way.", 500, 680);
                ctx.translate(0, 820);

                ctx.save();
                ctx.globalAlpha = 1;
                ctx.fillStyle = `rgb(${50 + a * 80},${50 + a * 110},255)`;
                ctx.roundRect(70, -50, 860, 330, 10);
                ctx.fill();
                ctx.fillStyle = `rgb(230,242,255)`;
                ctx.roundRect(110, 110, 780, 140, 10);
                ctx.fill();
                ctx.restore();

                ctx.fillText("If you didn't like this game, don't", 500, 0);
                ctx.fillText("consider supporting me on Patreon.", 500, 60);
                ctx.drawImage(Loading.logoImage, 100, -200, 800, 800);

                ctx.font = "70px rubik";
                var a = (1 + easeInOut(this.creditsContinueButtonAnimation / 15) * 0.1);
                ctx.save();
                ctx.translate(500, 400);
                ctx.scale(a, a);
                ctx.fillText("Don't Continue", 0, 0);
                ctx.globalAlpha = this.creditsContinueButtonAnimation / 15;
                ctx.fillText(`[  Don't Continue  ]`, 0, 0);
                ctx.restore();

                ctx.restore();
            },
            resetCreditsScreen: function () {
                this.creditsScreenAnimation = 0;
                this.movedCreditsScreen = false;
            }
        }

        var game = {
            newGameFromMenu: false,
            backgroundOffset: {
                x: 0,
                y: 0,
            },
            backgroundPatternOffset: {
                x: 0,
                y: 0
            },
            backgroundOpacity: 1,
            update: function () {
                var transitionPercent = this.level.levelTransition / this.level.levelTransitionCap;
                if (transitionPercent < 0.5) {
                    this.objects.update();
                    this.input.update();
                    this.cam.update();
                    this.particles.update();
                }
                this.level.update();
                this.ui.update();

                this.backgroundOffset.x %= 700;
                this.backgroundOffset.y %= 700;
                this.background.update();
                this.soundEffects.update();

                if (this.input.exitToMenu) {
                    menu.titleScreen = true;
                    menu.levelSelectScreen = true;
                    menu.wipeSaveScreen = false;
                    menu.wipeSaveAnimation = 0;
                    menu.newGameAnimation = 0;
                    menu.loadingLevelAnimation = 0;
                    menu.loadingLevel = false;
                    menu.levelSelectAnimation = 40;
                    menu.levelSelectAnimations = [];
                    this.background.effect.end("all");
                    this.input.exitToMenu = false;
                    this.level.levelTransition = 0;
                    this.level.load(0);
                }
            },
            draw: function () {
                this.cam.updateRealCoordinates();

                ctx.save();
                this.cam.alignViewport();

                this.background.draw();
                this.objects.draw();
                this.particles.draw();

                ctx.restore();

                this.level.drawLevelTransition();
                this.ui.draw();
            },
            newGame: function () {
                saveData = {
                    levelsBeaten: 0,
                    cubesCollected: [],
                    redCubesCollected: [],
                    redCubesDiscovered: [],
                    shortcutsDiscovered: [],
                    shortcutsTaken: [],
                    bestLevelSplits: [],
                    time: 0
                };
                this.ui.timer.newGame();
                deleteSaveData();
                this.level.load(0);
                this.ui.timer.newGame();
            },
            soundEffects: {
                update: function () {
                    var volume = audios.bubbles.volume;
                    volume -= 0.004;
                    if (!game.objects.objects.find(e => e.type == "player eye")) volume -= 0.05;
                    volume = Math.max(volume, 0);
                    audios.bubbles.volume = volume;
                    if (volume) audios.bubbles.play();
                },
                landNumber: 0,
                collectBlueCube: function () {
                    audios.collectBlueCube.currentTime = 0;
                    audios.collectBlueCube.play();
                },
                recollectBlueCube: function () {
                    audios.recollectBlueCube.currentTime = 0;
                    audios.recollectBlueCube.play();
                },
                blueCubeClue: function () {
                    audios.blueCubeClue.currentTime = 0;
                    audios.blueCubeClue.play();
                },
                blueCubePreClue: function () {
                    audios.blueCubePreClue.currentTime = 0;
                    audios.blueCubePreClue.play();
                },
                shortcut: function () {
                    audios.shortcut.currentTime = 0;
                    audios.shortcut.play();
                },
                preShortcut: function () {
                    audios.preShortcut.currentTime = 0;
                    audios.preShortcut.play();
                },
                collectRedCube: function () {
                    audios.collectRedCube.currentTime = 0;
                    audios.collectRedCube.play();
                },
                recollectRedCube: function () {
                    audios.recollectRedCube.currentTime = 0;
                    audios.recollectRedCube.play();
                },
                redCubeClue: function () {
                    audios.redCubeClue.currentTime = 0;
                    audios.redCubeClue.play();
                },
                redCubePreClue: function () {
                    audios.redCubePreClue.currentTime = 0;
                    audios.redCubePreClue.play();
                },
                sokobanCubeBox: function (n) {
                    var name = "sokobanBox" + n;
                    audios[name].currentTime = 0;
                    audios[name].play();
                },
                pressButton: function () {
                    audios.pressButton.currentTime = 0;
                    audios.pressButton.play();
                },
                doorSlam: function () {
                    audios.doorSlam.currentTime = 0;
                    audios.doorSlam.play();
                },
                jump: function () {
                    var name = "jump" + Math.floor(Math.random() * 3 + 1);
                    audios[name].currentTime = 0;
                    audios[name].play();
                },
                wallJump: function () {
                    audios.wallJump.currentTime = 0;
                    audios.wallJump.play();
                },
                wallHit: function () {
                    audios.wallHit.currentTime = 0;
                    audios.wallHit.play();
                },
                land: function () {
                    this.landNumber++;
                    this.landNumber %= 3;
                    var name = "land" + (this.landNumber + 1);
                    audios[name].currentTime = 0;
                    audios[name].play();
                },
                landGlass: function () {
                    this.landNumber++;
                    this.landNumber %= 3;
                    var name = "landGlass" + (this.landNumber + 1);
                    audios[name].currentTime = 0;
                    audios[name].play();
                },
                heavyLand: function () {
                    audios.heavyLand.currentTime = 0;
                    audios.heavyLand.play();
                },
                heaviestLand: function () {
                    audios.heaviestLand.currentTime = 0;
                    audios.heaviestLand.play();
                },
                death: function () {
                    audios.death.currentTime = 0;
                    audios.death.play();
                },
                switchGravity: function () {
                    audios.gravitySwitch.currentTime = 0;
                    audios.gravitySwitch.play();
                },
                buzzer: function () {
                    audios.buzzer.currentTime = 0;
                    audios.buzzer.play();
                },
                eatDot: function (n) {
                    var name = "eatDot" + n;
                    audios[name].currentTime = 0;
                    audios[name].play();
                },
                collectCoin: function (n) {
                    audios.collectCoin.currentTime = 0;
                    audios.collectCoin.play();
                },
                whoosh: function () {
                    audios.whoosh.currentTime = 0;
                    audios.whoosh.play();
                },
                reverseWhoosh: function () {
                    audios.reverseWhoosh.currentTime = 0;
                    audios.reverseWhoosh.play();
                },
                bubblesStart: function () {
                    audios.bubblesStart.currentTime = 0;
                    audios.bubblesStart.play();
                },
                bubblesEnd: function () {
                    audios.bubblesEnd.currentTime = 0;
                    audios.bubblesEnd.play();
                },
                bubbles: function () {
                    var volume = audios.bubbles.volume;
                    volume += 0.1;
                    volume = Math.min(volume, 1);
                    audios.bubbles.volume = volume;
                },
                killJumpEnemy: function () {
                    audios.killJumpEnemy.currentTime = 0;
                    audios.killJumpEnemy.play();
                },
                pingPongHit: function () {
                    audios.pingPongHit.currentTime = 0;
                    audios.pingPongHit.play();
                },
                bossFireballExplosion: function () {
                    audios.bossFireballExplosion.currentTime = 0;
                    audios.bossFireballExplosion.play();
                },
                bossShootFireball: function () {
                    audios.bossShootFireball.currentTime = 0;
                    audios.bossShootFireball.play();
                },
                bossHurt: function () {
                    audios.bossHurt.currentTime = 0;
                    audios.bossHurt.play();
                },
                platformMove: function () {
                    audios.platformMove.currentTime = 0;
                    audios.platformMove.play();
                }
            },
            background: {
                effect: {
                    effects: [],
                    start: function (type, origin) {
                        var effect = {};
                        effect.type = type;
                        effect.active = true;
                        effect.time = 0;
                        var color = type;
                        if (color == "blue") {
                            game.soundEffects.blueCubeClue();
                            color = "rgba(50,120,255,0.3)";
                        } else if (color == "red") {
                            game.soundEffects.redCubeClue();
                            color = "rgba(255,100,100,0.4)";
                        } else if (color == "green") {
                            game.soundEffects.shortcut();
                            color = "rgba(0,200,50,0.3)";
                        } else if (color == "purple") {
                            color = "rgba(170,80,255,0.5)";
                        }
                        effect.color = color;
                        effect.alpha = 1;
                        effect.radius = 20;
                        if (origin) {
                            effect.origin = { x: origin.x, y: origin.y };
                        } else {
                            var player = game.objects.objects.find(e => e.type == "player");
                            if (player) {
                                var x = player.x + player.w / 2;
                                var y = player.y + player.h / 2;
                                effect.origin = { x: x, y: y };
                            }
                        }
                        this.effects.push(effect);
                    },
                    end: function (type) {
                        if (type == "all") {
                            this.effects = [];
                            return;
                        }
                        var effects = this.effects.filter(e => e.type == type);
                        effects.forEach(function (e) {
                            e.active = false;
                        });
                    },
                    active: function (type) {
                        return Boolean(this.effects.find(e => e.type == type));
                    },
                    time: function (type) {
                        return this.effects.find(e => e.type == type)?.time || 0;
                    }
                },
                update: function () {
                    for (var effect of this.effect.effects) {
                        if (effect.active) {
                            effect.radius *= 1.1;
                            effect.radius = Math.min(effect.radius, 5000);
                            effect.alpha -= 0.02;
                            effect.alpha = Math.max(effect.alpha, 0);
                            effect.time = Math.max(effect.time, 0);
                            effect.time++;
                        } else {
                            effect.time = Math.min(effect.time, 40);
                            effect.time--;
                        }
                        if (!effect.active && !effect.time) effect.delete = true;
                    }
                    this.effect.effects = this.effect.effects.filter(e => !e.delete);
                },
                draw: function () {
                    if (game.backgroundOpacity == 0) return;

                    var distance = 0.2;
                    var tileSize = 700;
                    var viewportSize = 1000 / game.cam.realZoom;
                    var tileCount = Math.ceil(viewportSize / tileSize) * 2;
                    var xOffsetDigit = Math.floor((game.cam.realX * (1 - distance)) / (tileSize * 2)) - tileCount / 4 + game.backgroundPatternOffset.x;
                    var yOffsetDigit = Math.floor((game.cam.realY * (1 - distance)) / (tileSize * 2)) - tileCount / 4 + game.backgroundPatternOffset.y;
                    var xOffset = Math.floor(game.cam.realX * (1 - distance) / (tileSize * 2)) * tileSize * 2 + game.cam.realX * distance + game.backgroundOffset.x;
                    var yOffset = Math.floor(game.cam.realY * (1 - distance) / (tileSize * 2)) * tileSize * 2 + game.cam.realY * distance + game.backgroundOffset.y;

                    ctx.save();
                    ctx.translate(xOffset, yOffset);
                    ctx.translate(-tileCount / 2 * tileSize, -tileCount / 2 * tileSize);
                    ctx.globalAlpha = game.backgroundOpacity;

                    for (var x = -2; x < tileCount + 2; x++) {
                        for (var y = -2; y < tileCount + 2; y++) {
                            var xCor = x + xOffsetDigit * 2;
                            var yCor = y + yOffsetDigit * 2;

                            ctx.save();
                            ctx.translate(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2);
                            ctx.fillStyle = "rgb(245,245,245)";

                            for (var x2 = 0; x2 < 2; x2++) {
                                for (var y2 = 0; y2 < 2; y2++) {
                                    ctx.save();
                                    ctx.translate(x2 * tileSize / 2, y2 * tileSize / 2);
                                    if ((x2 + y2) % 2 == 0) {
                                        ctx.scale(0.4, 0.4);
                                        ctx.rotate(45 * Math.PI / 180);
                                        if (this.effect.active("red")) {
                                            var animateIn = easeInOut(this.effect.time("red") / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.rotate(90 * Math.PI / 180 * s);
                                        }
                                        ctx.fillRect(-tileSize / 2.5, -tileSize / 2.5, tileSize / 1.25, tileSize / 1.25);
                                        if (this.effect.active("red")) {
                                            var animateIn = easeInOut(this.effect.time("red") / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.globalAlpha = easeInBack(s);
                                            ctx.fillStyle = "rgba(255,100,100,0.4)";
                                            ctx.fillRect(-tileSize / 2.5, -tileSize / 2.5, tileSize / 1.25, tileSize / 1.25);
                                            ctx.globalAlpha = 1;
                                            ctx.fillStyle = "black";
                                            ctx.font = "50px Arial";
                                        }
                                        if (this.effect.active("green")) {
                                            var animateIn = easeInOut(this.effect.time("green") / 40);
                                            var time = t + x2 * 56 + y2 * 78 + Math.floor(Math.sin(xCor / 3) * 100) + Math.floor(Math.sin(yCor / 3) * 150);
                                            var a = Math.min(Math.max(Math.sin(time / 30) - 0.6, 0) * 1.5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 20;
                                            ctx.strokeStyle = "rgba(0,255,0,0.4)";
                                            ctx.strokeRect(-tileSize / 2.5 - 10, -tileSize / 2.5 - 10, tileSize / 1.25 + 20, tileSize / 1.25 + 20);
                                        }
                                        if (this.effect.active("blue")) {
                                            var animateIn = easeInOut(this.effect.time("blue") / 40);
                                            var time = t + x2 * 30 + y2 * 10 + xCor * 60 + yCor * 20;
                                            var a = Math.min(Math.max(Math.sin(time / 60) - 0.8, 0) * 5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 20;
                                            ctx.strokeStyle = "rgba(0,50,255,0.5)";
                                            ctx.strokeRect(-tileSize / 2.5 - 10, -tileSize / 2.5 - 10, tileSize / 1.25 + 20, tileSize / 1.25 + 20);
                                            ctx.fillStyle = "rgba(0,50,255,0.1)";
                                            ctx.fillRect(-tileSize / 2.5, -tileSize / 2.5, tileSize / 1.25, tileSize / 1.25);
                                        }
                                    } else {
                                        ctx.scale(0.3, 0.3);
                                        if (this.effect.active("red")) {
                                            var animateIn = easeInOut(this.effect.time("red") / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.rotate(-90 * Math.PI / 180 * s);
                                        }
                                        ctx.fillRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        if (this.effect.active("red")) {
                                            var animateIn = easeInOut(this.effect.time("red") / 40);
                                            var time = t + (noise((xCor + x2 / 2) / 1.05, (yCor + y2 / 2) / 1.05, 0) - 0.2) * 7 * 600;
                                            var s = Math.max((Math.sin((time / 600) % (Math.PI / 2)) - 0.975) * 40, 0);
                                            s *= animateIn;
                                            ctx.globalAlpha = easeInBack(s);
                                            ctx.fillStyle = "rgba(255,100,100,0.4)";
                                            ctx.fillRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        }
                                        if (this.effect.active("green")) {
                                            var animateIn = easeInOut(this.effect.time("green") / 40);
                                            var time = t + x2 * 56 + y2 * 78 + Math.floor(Math.sin(xCor / 3) * 100) + Math.floor(Math.sin(yCor / 3) * 150);
                                            var a = Math.min(Math.max(Math.sin(time / 30) - 0.6, 0) * 1.5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 25;
                                            ctx.strokeStyle = "rgba(0,255,0,0.4)";
                                            ctx.strokeRect(-tileSize / 2 - 12.5, -tileSize / 2 - 12.5, tileSize + 25, tileSize + 25);
                                        }
                                        if (this.effect.active("blue")) {
                                            var animateIn = easeInOut(this.effect.time("blue") / 40);
                                            var time = t + x2 * 30 + y2 * 10 + xCor * 60 + yCor * 20 + 200;
                                            var a = Math.min(Math.max(Math.sin(time / 60) - 0.8, 0) * 5, 1);
                                            a *= animateIn;
                                            ctx.globalAlpha *= a;
                                            ctx.lineWidth = 25;
                                            ctx.strokeStyle = "rgba(0,50,255,0.5)";
                                            ctx.strokeRect(-tileSize / 2 - 12.5, -tileSize / 2 - 12.5, tileSize + 25, tileSize + 25);
                                            ctx.fillStyle = "rgba(0,50,255,0.1)";
                                            ctx.fillRect(-tileSize / 2, -tileSize / 2, tileSize, tileSize);
                                        }
                                    }
                                    ctx.restore();
                                }
                            }

                            if (this.effect.active("green")) {
                                for (var n = 0; n < 4; n++) {
                                    var x3 = n % 2;
                                    var y3 = Math.floor(n / 2);
                                    ctx.fillStyle = "rgba(0,255,0,0.4)";
                                    var animateIn = easeInOut(this.effect.time("green") / 40);
                                    var time = t + x3 * 56 + y3 * 78 + Math.floor(Math.sin(xCor / 3) * 100) + Math.floor(Math.sin(yCor / 3) * 150);
                                    var s = 0.7 + Math.max(Math.sin(time / 10) - 0.6, 0) * 1.5;
                                    s *= animateIn;
                                    ctx.save();
                                    ctx.translate(175 + x3 * 350, 175 + y3 * 350);
                                    ctx.scale(s, s);
                                    ctx.rotate(time * Math.PI / 180);
                                    ctx.fillRect(-10, -10, 20, 20);
                                    ctx.restore();
                                }
                            }

                            ctx.restore();
                        }
                    }

                    ctx.restore();

                    for (var effect of this.effect.effects) {
                        if (!effect.active) continue;
                        ctx.save();
                        ctx.globalAlpha = effect.alpha;
                        ctx.beginPath();
                        ctx.fillStyle = effect.color;
                        ctx.arc(effect.origin.x, effect.origin.y, effect.radius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.restore();
                    }
                }
            },
            input: {
                keys: {
                    left: [37, 65],
                    right: [39, 68],
                    up: [38, 87],
                    down: [40, 83],
                    skip: [32],
                    restartLevel: [82],
                    restartGame: [89],
                    exitToMenu: [27]
                },
                left: false,
                right: false,
                up: false,
                down: false,
                leftStart: false,
                rightStart: false,
                upStart: false,
                downStart: false,
                leftHold: 0,
                rightHold: 0,
                upHold: 0,
                downHold: 0,
                skip: false,
                restartLevel: false,
                restartGame: false,
                exitToMenu: false,
                update: function () {
                    this.left = this.keys.left.some(e => Keys.keys[e]);
                    this.right = this.keys.right.some(e => Keys.keys[e]);
                    this.up = this.keys.up.some(e => Keys.keys[e]);
                    this.down = this.keys.down.some(e => Keys.keys[e]);
                    if (bot) {
                        this.left = bot[frame * 5] == "1";
                        this.right = bot[frame * 5 + 1] == "1";
                        this.up = bot[frame * 5 + 2] == "1";
                        this.down = bot[frame * 5 + 3] == "1";
                    }
                    this.skip = false;//this.keys.skip.some(e => Keys.keys[e]);
                    this.restartLevel = this.keys.restartLevel.some(e => Keys.keys[e]);
                    this.restartGame = this.keys.restartGame.some(e => Keys.keys[e]);
                    this.exitToMenu = this.keys.exitToMenu.some(e => Keys.keys[e]);
                    if (game.level.playerControlDelay) {
                        this.left = false;
                        this.right = false;
                        this.up = false;
                        this.down = false;
                    }
                    var directions = ["left", "right", "up", "down"];
                    for (var n = 0; n < 4; n++) {
                        var dir = directions[n];
                        if (this[`${dir}Start`]) {
                            this[`${dir}Start`]++;
                        } else if (this[dir]) {
                            this[`${dir}Start`] = 1;
                        }
                        if (this[dir]) {
                            this[`${dir}Hold`]++;
                        } else {
                            this[`${dir}Hold`] = 0;
                            this[`${dir}Start`] = 0;
                        }
                    }
                }
            },
            objects: {
                objects: [],
                ghostNodes: [],
                update: function () {
                    var player = this.objects.find(e => e.type == "player");
                    for (var o of this.objects) {
                        if (o.type == "player") {
                            this.updatePlayer(o);
                            continue;
                        }
                        this.updateObject(o, player);
                    }
                    this.objects = this.objects.filter(e => !e.delete);
                },
                draw: function () {
                    var player = game.objects.objects.find(e => e.type == "player");
                    if (game.level.playerInPortal) {
                        var o = game.objects.objects.find(e => e.portalNumber == game.level.portalNumber);
                        ctx.save();
                        ctx.translate(o.x, o.y);
                        ctx.rotate(o.angle * Math.PI / 180);
                        ctx.beginPath();
                        ctx.rect(0, 0, o.length, -100);
                        ctx.clip();
                        ctx.rotate(-o.angle * Math.PI / 180);
                        ctx.translate(-o.x, -o.y);
                        this.drawPlayer(player);
                        ctx.restore();
                    }
                    for (var o of this.objects) {
                        if (o.type == "player") {
                            if (game.level.playerInPortal) continue;
                            if (o.explodeAnimation) {
                                this.drawPlayerExplosion(o);
                                continue;
                            }
                            this.drawPlayer(o);
                            continue;
                        }
                        if (o.type == "player copy") {
                            if (!player) continue;
                            if (o.rotate) {
                                var dist = distTo(player.x + player.w / 2, player.y + player.h / 2, o.rotate.x, o.rotate.y);
                                var dir = dirTo(player.x + player.w / 2, player.y + player.h / 2, o.rotate.x, o.rotate.y);
                                ctx.save();
                                ctx.translate(o.rotate.x, o.rotate.y);
                                ctx.rotate((o.rotate.angle + dir) * Math.PI / 180);
                                ctx.translate(0, dist);
                                ctx.rotate(-dir * Math.PI / 180);
                                ctx.translate(-player.w / 2, - player.h / 2);
                                this.drawPlayer(player, true, o.onlyDrawTrail);
                                ctx.restore();
                            } else {
                                ctx.save();
                                ctx.translate(o.offsetX, o.offsetY);
                                this.drawPlayer(player, false, o.onlyDrawTrail);
                                ctx.restore();
                            }
                        }
                        this.drawObject(o, player);
                    }
                    if (!game.level.showWireframes) return;
                    ctx.strokeStyle = "lime";
                    ctx.lineWidth = 3;
                    for (var o of this.objects) {
                        if (o.w !== undefined && o.h !== undefined) {
                            ctx.strokeRect(o.x, o.y, o.w, o.h);
                        } else {
                            if (o.type == "cube") {
                                ctx.beginPath();
                                ctx.arc(o.x, o.y, 40, 0, 2 * Math.PI);
                                ctx.stroke();
                            } else if (o.type == "clue") {
                                ctx.save();
                                ctx.translate(o.x, o.y);
                                ctx.rotate(45 * Math.PI / 180);
                                ctx.strokeRect(-15, -15, 30, 30);
                                ctx.restore();
                            } else if (o.type == "text") {
                                ctx.font = o.font;
                                var width = ctx.measureText(o.content).width;
                                var height = o.font.split("px")[0];
                                if (height.includes(" ")) {
                                    height = height.split(" ");
                                    height = height[height.length - 1];
                                }
                                height = Number(height);
                                if (isNaN(height)) {
                                    ctx.beginPath();
                                    ctx.arc(o.x, o.y, 20, 0, 2 * Math.PI);
                                    ctx.stroke();
                                } else {
                                    ctx.save();
                                    ctx.translate(o.x, o.y);
                                    if (o.textAlign == "left") {
                                        ctx.translate(width / 2, 0);
                                    }
                                    if (o.textAlign == "right") {
                                        ctx.translate(-width / 2, 0);
                                    }
                                    if (o.textBaseline == "top") {
                                        ctx.translate(0, height / 2);
                                    }
                                    if (o.textBaseline == "bottom") {
                                        ctx.translate(0, -height / 2);
                                    }
                                    ctx.strokeRect(-width / 2, -height / 2, width, height);
                                    ctx.restore();
                                }
                            } else if (o.type == "circle") {
                                ctx.beginPath();
                                ctx.arc(o.x, o.y, o.r, 0, 2 * Math.PI);
                                ctx.stroke();
                            } else {
                                ctx.beginPath();
                                ctx.arc(o.x, o.y, 20, 0, 2 * Math.PI);
                                ctx.stroke();
                            }
                        }
                        if (o.type == "player") {
                            ctx.beginPath();
                            ctx.arc(o.x + o.w / 2, o.y + o.h / 2, 30, 0, 2 * Math.PI);
                            ctx.stroke();
                        }
                    }
                },
                switchGravity: function (angle) {
                    if (game.level.levelComplete) return;
                    game.soundEffects.switchGravity();
                    for (var o of game.objects.objects) {
                        if (o.type != "gravity switcher") continue;
                        o.targetAngle = angle;
                    }
                    var player = game.objects.objects.find(e => e.type == "player");
                    if (player) {
                        player.updateAngle = angle;
                        player.eyeAngleTarget = angle;
                        player.swapControls = false;
                    }
                    var o = {
                        type: "image",
                        image: "gravitySwitch",
                        collide: false,
                        alpha: 0,
                        animation: 0,
                        angle: (angle + 180) % 360,
                        x: game.cam.x - 500,
                        y: game.cam.y - 700,
                        w: 1400,
                        h: 1400
                    }
                    if (angle == 270) {
                        o.x += o.w - 400;
                    }
                    if (angle == 0) {
                        o.x += o.w;
                        o.y += o.h - 400;
                    }
                    if (angle == 90) {
                        o.y += o.h;
                        o.x += 400;
                    }
                    if (angle == 180) {
                        o.y += 500;
                    }
                    game.objects.objects.push(o);
                    var o = {
                        type: "image",
                        image: "gravitySwitch2",
                        collide: false,
                        alpha: 0,
                        animation: 0,
                        angle: (angle + 180) % 360,
                        x: game.cam.x - 500,
                        y: game.cam.y - 700,
                        w: 1000,
                        h: 1000
                    }
                    if (angle == 270) {
                        o.x += o.w - 200;
                    }
                    if (angle == 0) {
                        o.x += o.w;
                        o.y += o.h - 200;
                    }
                    if (angle == 90) {
                        o.y += o.h;
                        o.x += 200;
                    }
                    if (angle == 180) {
                        o.y += 300;
                    }
                    game.objects.objects.push(o);
                },
                updatePlayerEye: function (o) {
                    if (o.controlDelay) {
                        o.controlDelay--;
                        return;
                    }
                    if (game.level.autoSkipCutscenes) o.controlDelay = 0;
                    var o2;
                    if (o.id == "player eye 1") {
                        o2 = game.objects.objects.find(e => e.id == "player eye 2");
                    }
                    if (o.id == "player eye 2") {
                        o2 = game.objects.objects.find(e => e.id == "player eye 1");
                    }
                    if (!o2) return;
                    if (!o.xmove) o.xmove = 0;
                    if (!o.ymove) o.ymove = 0;
                    var speed = 0.4 * game.level.playerSpeedMultiplier;
                    if (game.input.left) {
                        o.xmove -= speed;
                        game.soundEffects.bubbles();
                    }
                    if (game.input.right) {
                        o.xmove += speed;
                        game.soundEffects.bubbles();
                    }
                    if (game.input.up) {
                        if (o.y < 200) {
                            o.ymove -= speed / 4;
                        } else {
                            o.ymove -= speed;
                        }
                        game.soundEffects.bubbles();
                    }
                    if (game.input.down) {
                        o.ymove += speed;
                        game.soundEffects.bubbles();
                    }
                    var a1 = t;
                    var a2 = t + 10000;
                    if (o.id == "player eye 2") {
                        a1 = t + 847634;
                        a2 = t + 857634;
                    }
                    var closeToSurface = o.y < 700 && o2.y < 700;
                    var start = 400;
                    var end = 200;
                    var distanceToSurface = Math.max(Math.min(1 - (o.y / 2 + o2.y / 2 - start) / (start - end), 1), 0);
                    if (!closeToSurface && !game.level.triggers.tripped("red cube")) {
                        o.xmove += Math.sin(t / 100) / 90 + Math.sin(t / 435) / 90 + Math.sin(t / 34) / 90;
                        o.ymove += Math.sin(a2 / 100) / 90 + Math.sin(a2 / 435) / 90 + Math.sin(a2 / 34) / 90;
                    }
                    var dir = dirTo(o.x, o.y, o2.x, o2.y);
                    var dist = distTo(o.x, o.y, o2.x, o2.y);
                    var distance = 200;
                    if (closeToSurface) {
                        var percent = distanceToSurface * 0.05;
                        o.y = o.y * (1 - percent) + o2.y * percent;
                        distance = 200 - (200 - 15) * distanceToSurface;
                        var move = distToMove(dist - distance, dir);
                        o.xmove += move.x / (1000 - 980 * distanceToSurface);
                        o.ymove += move.y / (1000 - 980 * distanceToSurface);
                    } else {
                        var speed = dist - distance;
                        if (speed < 0) {
                            speed *= 0.5;
                            speed = Math.max(speed, -30);
                        }
                        var move = distToMove(speed, dir);
                        o.xmove += move.x / 1000;
                        o.ymove += move.y / 1000;
                    }
                    var a3 = t + 20000;
                    var rotation = Math.sin(a3 / 100) / 90 + Math.sin(a3 / 435) / 90 + Math.sin(a3 / 34) / 90;
                    var move = distToMove(rotation, dir + 90);
                    if (!closeToSurface && !game.level.triggers.tripped("red cube")) {
                        o.xmove += move.x;
                        o.ymove += move.y;
                    }
                    o.xmove *= 0.9;
                    o.ymove *= 0.9;

                    var player = o;
                    var axises = ["x", "y"];
                    var dims = ["w", "h"];
                    for (var n = 0; n < 2; n++) {
                        if (game.level.playerFlightMode) break;
                        var axis = axises[n];
                        var dim = dims[n];
                        player[axis] += player[`${axis}move`];
                        for (var o of game.objects.objects) {
                            if (!o.eyeCollide) continue;
                            if (!blocksCollidingEdge(player, o)) continue;
                            if (o.type == "lava" && !game.level.playerInvincible) {
                                player.delete = true;
                                game.soundEffects.death();
                            }
                            if (!blocksColliding(player, o)) continue;
                            if (player[axis] + player[dim] / 2 < o[axis] + o[dim] / 2) {
                                player[axis] = o[axis] - player[dim];
                            } else {
                                player[axis] = o[axis] + o[dim];
                            }
                            player[`${axis}move`] = 0;
                        }
                    }

                    for (var o of game.objects.objects) {
                        if (o.type != "cube") continue;
                        if (o.collected) continue;
                        var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                        if (dist > 50) continue;
                        o.collectedAnimation = 20;
                        o.collected = true;
                        game.particles.createEffect("collect cube", o);
                        if (o.red) {
                            saveData.redCubesCollected[game.level.level] = true;
                            game.soundEffects.collectRedCube();
                        } else {
                            saveData.cubesCollected[game.level.level] = true;
                            game.soundEffects.collectBlueCube();
                        }
                        updateSaveData();
                    }

                    if (player.delete && player.noDeathEffect !== true) {
                        game.particles.createEffect("eye death", player);
                        game.cam.screenshake = 20;
                    }
                },
                updateOldPlayer: function (o) {
                    var level8SpeedMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 10 : 1;
                    var level8JumpMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 5 : 1;
                    var level8FallMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 5 : 1;
                    if (game.level.levelComplete) {
                        o.x--;
                        return;
                    }
                    for (var o2 of game.objects.objects) {
                        if (game.level.playerInvincible || game.level.playerFlightMode) break;
                        if (!o2.collide) continue;
                        if (o2.type != "lava") continue;
                        if (!blocksColliding(o, o2)) continue;
                        o.delete = true;
                        game.soundEffects.death();
                        game.particles.createEffect("player death", o);
                        game.cam.screenshake = 20;
                    }

                    if (game.level.playerFlightMode) {
                        if (game.input.left) {
                            o.xmove -= 0.15 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.right) {
                            o.xmove += 0.15 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.up) {
                            o.ymove -= 0.15 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.down) {
                            o.ymove += 0.15 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        o.xmove *= 0.96;
                        o.ymove *= 0.96;
                        o.x += o.xmove;
                        o.y += o.ymove;
                        return;
                    }

                    o.x += o.xmove;
                    for (var o2 of game.objects.objects) {
                        if (!o2.collide) continue;
                        if (o2.type != "block") continue;
                        if (!blocksColliding(o, o2)) continue;
                        if (o.x + o.w / 2 < o2.x + o2.w / 2) {
                            o.x = o2.x - o.w;
                        } else {
                            o.x = o2.x + o2.w;
                        }
                        o.xmove = 0;
                    }
                    var touchingGround = false;
                    o.y += o.ymove;
                    for (var o2 of game.objects.objects) {
                        if (!o2.collide) continue;
                        if (o2.type != "block") continue;
                        if (!blocksColliding(o, o2)) continue;
                        if (o.y + o.h / 2 < o2.y + o2.h / 2) {
                            touchingGround = true;
                            o.y = o2.y - o.h;
                        } else {
                            o.y = o2.y + o2.h;
                        }
                        o.ymove = 0;
                    }

                    if (game.input.left) {
                        o.xmove += 0.15 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                    }
                    if (game.input.right) {
                        o.xmove -= 0.15 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                    }
                    if (game.input.down && touchingGround) {
                        o.ymove = -6 * game.level.playerJumpMultiplier * level8JumpMultiplier;
                    }
                    o.ymove += 0.08 * level8FallMultiplier;

                    o.xmove *= 0.96;
                    o.ymove *= 0.98;
                },
                updateCirclesPlayer: function (o) {
                    var level8SpeedMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 10 : 1;
                    var level8JumpMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 3 : 1;
                    var level8FallMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 4 : 1;
                    if (game.level.playerFlightMode) {
                        if (game.input.left) {
                            o.xmove -= 0.12 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.right) {
                            o.xmove += 0.12 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.up) {
                            o.ymove -= 0.12 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.down) {
                            o.ymove += 0.12 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        o.x += o.xmove;
                        o.y += o.ymove;
                        o.xmove *= 0.98;
                        o.ymove *= 0.98;
                        return;
                    }

                    if (game.input.left) {
                        o.xmove -= 0.12 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                    }
                    if (game.input.right) {
                        o.xmove += 0.12 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                    }
                    o.turn *= 0.95;
                    o.turn += o.xmove * 0.05;
                    o.angle += o.turn;

                    var collide = false;
                    for (var o2 of game.objects.objects) {
                        if (o2.type != "circle") continue;
                        if (o2.circlesCollide === false) continue;
                        var dist = distTo(o.x, o.y, o2.x, o2.y);
                        if (dist > o.r + o2.r) continue;
                        collide = true;

                        var energy = 1.6;
                        var distX = o2.x - o.x;
                        var distY = o2.y - o.y;
                        var nx = distX / dist;
                        var ny = distY / dist;
                        var penetration = o.r + o2.r - dist;
                        var k = o.xmove * nx + o.ymove * ny;
                        o.xmove -= k * nx * energy;
                        o.turn += k * nx * 5;
                        o.ymove -= k * ny * energy;
                        o.x -= nx * penetration;
                        o.y -= ny * penetration;
                    }

                    if (game.input.up && collide) {
                        o.ymove = -6 * game.level.playerJumpMultiplier * level8JumpMultiplier;
                    }

                    o.ymove += 0.15 * level8FallMultiplier;
                    o.xmove *= 0.98;
                    o.ymove *= 0.98;

                    o.x += o.xmove;
                    o.y += o.ymove;
                },
                updatePingPongPlayer: function (o) {
                    var level8SpeedMultiplier = game.level.triggers.tripped("shortcut") ? 4 : 0;
                    if (game.level.playerFlightMode) {
                        if (game.input.left) {
                            o.x -= 4 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.right) {
                            o.x += 4 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.up) {
                            o.y -= 4 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        if (game.input.down) {
                            o.y += 4 * game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                        }
                        return;
                    }
                    o.x += o.xmove * game.level.playerSpeedMultiplier;
                    o.y += o.ymove * game.level.playerSpeedMultiplier;
                    if (o.y <= -4500) {
                        o.y = -4500;
                        o.ymove *= -1;
                        game.soundEffects.pingPongHit();
                    }
                    if (o.y >= -3500 - o.h) {
                        o.y = -3500 - o.h;
                        o.ymove *= -1;
                        game.soundEffects.pingPongHit();
                    }
                    var o2 = game.objects.objects.find(e => e.id == "player score");
                    if (o2.scoreTime) o2.scoreTime--;
                    var o2 = game.objects.objects.find(e => e.id == "opponent score");
                    if (o2.scoreTime) o2.scoreTime--;
                    if (o.x < -500) {
                        var o2 = game.objects.objects.find(e => e.id == "player score");
                        if (!o2.scoreTime) {
                            o2.content = String(Number(o2.content) + 1);
                            o2.scoreTime = 10;
                        }
                    }
                    var playerPaddle = game.objects.objects.find(e => e.id == "player paddle");
                    if (o.xmove > 0 && blocksColliding(o, playerPaddle)) {
                        o.xmove *= -1.1;
                        o.ymove *= 1.1;
                        o.x = playerPaddle.x - o.w;
                        game.soundEffects.pingPongHit();
                    }
                    var opponentPaddle = game.objects.objects.find(e => e.id == "opponent paddle");
                    if (o.xmove < 0 && blocksColliding(o, opponentPaddle)) {
                        o.xmove *= -1.1;
                        o.ymove *= 1.1;
                        o.x = opponentPaddle.x + opponentPaddle.w;
                        game.soundEffects.pingPongHit();
                    }
                    if (o.x > 500 - o.w) {
                        game.particles.createEffect("ping pong death", o);
                        o.delete = true;
                        game.soundEffects.death();
                        game.cam.screenshake = 20;
                        var o2 = game.objects.objects.find(e => e.id == "opponent score");
                        if (!o2.scoreTime) {
                            o2.content = String(Number(o2.content) + 1);
                            o2.scoreTime = 10;
                        }
                    }
                },
                updatePacmanGhost: function (o) {
                    if (!game.level.triggers.tripped("room 5")) return;
                    if (!o.color) o.color = "cyan";
                    if (!o.direction) o.direction = 0;
                    if (!o.animation) o.animation = 0;
                    o.animation++;
                    var player = game.objects.objects.find(e => e.type == "pacman player");
                    if (!player) return;
                    if (player.dead) return;
                    if (!game.level.triggers.tripped("red cube")) {
                        var move = distToMove(0.5, o.direction);
                        o.x += move.x;
                        o.y += move.y;
                        if (o.animation % 80 == 0) {
                            o.direction += 180;
                            o.direction %= 360;
                        }
                    } else {
                        o.animation++;
                        if (!o.targetNode) {
                            var smallestDist = Infinity;
                            for (var n = 0; n < game.objects.ghostNodes.length; n++) {
                                var node = game.objects.ghostNodes[n];
                                var dist = distTo(o.x, o.y, node.x, node.y);
                                if (dist < smallestDist) {
                                    o.targetNode = node;
                                    smallestDist = dist;
                                }
                            }
                        }
                        if (o.targetNode) {
                            var speedMultiplier = 0.4;
                            if (o.color == "red") speed = 7;
                            if (o.color == "orange") speed = 10;
                            if (o.color == "cyan") speed = 10;
                            if (o.color == "pink") speed = 10;
                            speed *= speedMultiplier;
                            var dir = dirTo(o.x, o.y, o.targetNode.x, o.targetNode.y);
                            var dist = distTo(o.x, o.y, o.targetNode.x, o.targetNode.y);
                            var move = distToMove(speed, dir);
                            o.x += move.x;
                            o.y += move.y;
                            if (dist < speed) {
                                o.x = o.targetNode.x;
                                o.y = o.targetNode.y;
                                this.pathfindForGhost(o);
                            }
                            if (o.color == "cyan") {
                                if (!o.targetAngle) o.targetAngle = 0;
                                if (!o.targetDistTime) o.targetDistTime = 0;
                                if (o.targetDistTime % 2000 < 1000) {
                                    o.targetAngle += 0.7 * speedMultiplier;
                                } else {
                                    o.targetAngle -= 0.7 * speedMultiplier;
                                }
                                o.targetDistTime += 1 * speedMultiplier;
                                o.targetDist = 550;
                                var move = distToMove(o.targetDist, o.targetAngle);
                                o.targetX = 1000 + move.x;
                                o.targetY = -4000 + move.y;
                            }
                            if (o.color == "pink") {
                                if (!o.targetAngle) o.targetAngle = 0;
                                if (!o.targetDistTime) o.targetDistTime = 0;
                                if (o.targetDistTime % 1400 < 900) {
                                    o.targetAngle += 0.5 * speedMultiplier;
                                } else {
                                    o.targetAngle -= 0.5 * speedMultiplier;
                                }
                                o.targetDistTime += 1 * speedMultiplier;
                                o.targetDist = Math.sin(o.targetDistTime / 20) * 100 + 350;
                                var move = distToMove(o.targetDist, o.targetAngle);
                                o.targetX = 1000 + move.x;
                                o.targetY = -4000 + move.y;
                            }
                            if (o.color == "orange") {
                                if (!o.targetAngle) o.targetAngle = 0;
                                if (!o.targetDistTime) o.targetDistTime = 0;
                                o.targetAngle += 0.05 * speedMultiplier;
                                o.targetDistTime += 1 * speedMultiplier;
                                o.targetDist = Math.sin(o.targetDistTime / 50) * 700;
                                var move = distToMove(o.targetDist, o.targetAngle);
                                o.targetX = 1000 + move.x;
                                o.targetY = -4000 + move.y;
                            }
                        }
                    }
                },
                pathfindForGhost: function (o) {
                    var player = game.objects.objects.find(e => e.type == "pacman player");
                    if (!player) return;
                    var directions = [];
                    if (o.targetNode.left !== undefined && o.direction != 90) directions.push("left");
                    if (o.targetNode.right !== undefined && o.direction != 270) directions.push("right");
                    if (o.targetNode.top !== undefined && o.direction != 180) directions.push("top");
                    if (o.targetNode.bottom !== undefined && o.direction != 0) directions.push("bottom");
                    var direction = directions[0];
                    if (o.color == "red") {
                        var minDist = Infinity;
                        for (var n = 0; n < directions.length; n++) {
                            var node = game.objects.ghostNodes[o.targetNode[directions[n]].id];
                            var dist = node.distToPlayer + distTo(node.x, node.y, player.x, player.y) / 100;
                            if (dist < minDist) {
                                minDist = dist;
                                direction = directions[n];
                            }
                        }
                    } else if (o.color == "cyan" || o.color == "pink" || o.color == "orange") {
                        var minDist = Infinity;
                        for (var n = 0; n < directions.length; n++) {
                            var node = game.objects.ghostNodes[o.targetNode[directions[n]].id];
                            var dist = distTo(node.x + node.w / 2, node.y + node.h / 2, o.targetX, o.targetY);
                            if (o.color == "cyan") {
                                var ghostDistToCenter = distTo(o.x + o.w / 2, o.y + o.h / 2, 1000, -4000);
                                if (ghostDistToCenter < 350) {
                                    var nodeDistToCenter = distTo(node.x + node.w / 2, node.y + node.h / 2, 1000, -4000);
                                    dist = -nodeDistToCenter;
                                }
                            }
                            var distToPlayer = distTo(node.x, node.y, player.x, player.y);
                            if (dist < minDist) {
                                minDist = dist;
                                direction = directions[n];
                            }
                        }
                    }
                    o.direction = [270, 0, 90, 180][["left", "top", "right", "bottom"].indexOf(direction)];
                    o.targetNode = game.objects.ghostNodes[o.targetNode[direction].id];
                },
                updateBoss: function (o) {
                    if (o.unstunnedTime === undefined) o.unstunnedTime = 0;
                    if (o.leftFireTime === undefined) o.leftFireTime = 500;
                    if (o.rightFireTime === undefined) o.rightFireTime = 1000;
                    if (o.leftFireAnimation === undefined) o.leftFireAnimation = 0;
                    if (o.rightFireAnimation === undefined) o.rightFireAnimation = 0;
                    if (o.idle) return;
                    if (o.leftFireAnimation) o.leftFireAnimation--;
                    if (o.rightFireAnimation) o.rightFireAnimation--;
                    if (o.leftFireAnimation == 29) game.soundEffects.bossShootFireball();
                    if (o.rightFireAnimation == 29) game.soundEffects.bossShootFireball();
                    if (o.rightFireAnimation === 1) {
                        var o2 = {
                            type: "boss fireball",
                            x: o.x + o.w + o.w * 0.25,
                            y: o.y + o.h * 0.95
                        }
                        game.objects.objects.unshift(o2);
                    }
                    if (o.leftFireAnimation === 1) {
                        var o2 = {
                            type: "boss fireball",
                            x: o.x - o.w * 0.25,
                            y: o.y + o.h * 0.95
                        }
                        game.objects.objects.unshift(o2);
                    }
                    if (o.stunnedTime) {
                        o.unstunnedTime = 0;
                        o.stunnedTime--;
                        if (!game.level.triggers.tripped("boss dead")) {
                            if (o.xOrigin + o.w / 2 > -2100) {
                                o.x = o.x * 0.99 + -2450 * 0.01;
                            } else {
                                o.x = o.x * 0.99 + -2150 * 0.01;
                            }
                            o.y += Math.min(-1 + (200 - o.stunnedTime) * 0.01, 0);
                        }
                    } else {
                        o.unstunnedTime++;
                        o.y = Math.max(o.y, -699.5 + 49.5 * easeInOut(o.unstunnedTime / 50));
                        o.rightFireTime--;
                        o.leftFireTime--;
                        if (o.rightFireTime == 0) {
                            o.rightFireTime = 1000;
                            o.rightFireAnimation = 30;
                        }
                        if (o.leftFireTime == 0) {
                            o.leftFireTime = 1000;
                            o.leftFireAnimation = 30;
                        }
                        o.x += o.direction / 2;
                        if (o.x > -2150) o.direction = -1;
                        if (o.x < -2450) o.direction = 1;
                    }
                },
                updatePacmanPlayer: function (o) {
                    if (o.dead) {
                        if (o.deathAnimation === undefined) o.deathAnimation = 0;
                        o.deathAnimation++;
                        o.animation = 0;
                        return;
                    }
                    if (game.level.triggers.tripped("red cube") && !(game.level.playerInvincible || game.level.playerFlightMode) && !o.dead) {
                        var ghosts = game.objects.objects.filter(e => e.type == "pacman ghost");
                        for (var o2 of ghosts) {
                            var dist = distTo(o2.x + o2.w / 2, o2.y + o2.h / 2, o.x + o.w / 2, o.y + o.h / 2);
                            if (dist > 30) continue;
                            game.soundEffects.death();
                            o.dead = true;
                            game.cam.screenshake = 20;
                            break;
                        }
                    }
                    o.animation = ((o.x + o.y) / 40 * Math.PI + Math.PI * 0.2) * 2;
                    var move = distToMove(2, o.angle);
                    if (game.level.triggers.tripped("shortcut")) {
                        move = distToMove(10, o.angle);
                    }
                    if (game.level.triggers.tripped("red cube")) {
                        move = distToMove(4, o.angle);
                    }
                    if (game.level.playerSpeedMultiplier !== 1) {
                        var move = distToMove(game.level.playerSpeedMultiplier, o.angle);
                    }
                    o.touchingLeft = false;
                    o.touchingRight = false;
                    o.touchingTop = false;
                    o.touchingBottom = false;
                    o.x += move.x;
                    o.x = Math.round(o.x);
                    for (var o2 of game.objects.objects) {
                        if (game.level.playerFlightMode) break;
                        if (o2.type == "cube" && o2.red && !o2.collected) {
                            var dist = distTo(o.x + o.w / 2, o.y + o.h / 2, o2.x, o2.y);
                            if (dist < 70) {
                                o2.collectedAnimation = 20;
                                o2.collected = true;
                                game.particles.createEffect("collect cube", o2);
                                saveData.redCubesCollected[game.level.level] = true;
                                game.soundEffects.collectRedCube();
                                updateSaveData();
                            }
                        }
                        if (!o2.pacmanCollide) continue;
                        if (!blocksCollidingEdge(o, o2)) continue;
                        if (o.y == o2.y + o2.h || o.y == o2.y - o.h) continue;
                        if (o.x + o.w / 2 < o2.x + o2.w / 2) {
                            o.touchingRight = true;
                        } else {
                            o.touchingLeft = true;
                        }
                        if (!blocksColliding(o, o2)) continue;
                        if (o.x + o.w / 2 < o2.x + o2.w / 2) {
                            o.x = o2.x - o.w;
                            o.y = Math.round((o.y - 20) / 40) * 40 + 20;
                        } else {
                            o.x = o2.x + o2.w;
                            o.y = Math.round((o.y - 20) / 40) * 40 + 20;
                        }
                    }
                    o.y += move.y;
                    o.y = Math.round(o.y);
                    for (var o2 of game.objects.objects) {
                        if (game.level.playerFlightMode) break;
                        if (!o2.pacmanCollide) continue;
                        if (!blocksCollidingEdge(o, o2)) continue;
                        if (o.x == o2.x + o2.w || o.x == o2.x - o.w) continue;
                        if (o.y + o.h / 2 < o2.y + o2.h / 2) {
                            o.touchingBottom = true;
                        } else {
                            o.touchingTop = true;
                        }
                        if (!blocksColliding(o, o2)) continue;
                        if (o.y + o.h / 2 < o2.y + o2.h / 2) {
                            o.y = o2.y - o.h;
                            o.x = Math.round((o.x - 20) / 40) * 40 + 20;
                        } else {
                            o.y = o2.y + o2.h;
                            o.x = Math.round((o.x - 20) / 40) * 40 + 20;
                        }
                    }
                    if (o.nextDirection == 0 && !o.touchingTop) o.angle = 0;
                    if (o.nextDirection == 90 && !o.touchingRight) o.angle = 90;
                    if (o.nextDirection == 180 && !o.touchingBottom) o.angle = 180;
                    if (o.nextDirection == 270 && !o.touchingLeft) o.angle = 270;
                    if (game.input.upHold === 1) {
                        o.nextDirection = 0;
                    }
                    if (game.input.downHold === 1) {
                        o.nextDirection = 180;
                    }
                    if (game.input.rightHold === 1) {
                        o.nextDirection = 90;
                    }
                    if (game.input.leftHold === 1) {
                        o.nextDirection = 270;
                    }
                    for (var o2 of game.objects.objects) {
                        if (o2.type != "pacman dot") continue;
                        if (o2.collected) continue;
                        if (!blocksColliding(o, o2)) continue;
                        var n = -Math.round((o2.x + o2.y) / 40) % 2 + 1;
                        game.soundEffects.eatDot(n);
                        o2.collected = true;
                        o2.alpha = 0;
                    }
                },
                updateSnakePlayer: function (o) {
                    if (o.deathAnimation) {
                        o.deathAnimation++;
                        return;
                    }
                    var speed = Math.round(Math.max(15 - o.length / 12, 8)) / game.level.playerSpeedMultiplier;
                    if (game.level.level === 7 && game.level.triggers.tripped("shortcut")) speed = 4;
                    o.move.time++;
                    var p = o.move.time / speed;
                    o.x = o.move.origin.x + o.move.direction.x * p;
                    o.y = o.move.origin.y + o.move.direction.y * p;
                    if (o.move.time > speed * 0.6) {
                        for (var o2 of game.objects.objects) {
                            if (o2.type != "apple") continue;
                            if (!blocksColliding(o, o2)) continue;
                            o2.delete = true;
                            o.length += 4;
                            for (var o3 of game.objects.objects) {
                                if (o3.type != "snake body") continue;
                                o3.time += speed * 4;
                            }
                        }
                        var collide = false;
                        for (var o2 of game.objects.objects) {
                            if (!o2.snakeCollide) continue;
                            if (o2.noCollideTime) continue;
                            if (!blocksColliding(o, o2)) continue;
                            collide = true;
                            break;
                        }
                        if (collide && !game.level.playerInvincible && !game.level.playerFlightMode) {
                            for (var o2 of game.objects.objects) {
                                if (o2.type != "snake body" && o2.type != "snake player") continue;
                                o2.deathAnimation = 1;
                                game.soundEffects.death();
                            }
                            game.cam.screenshake = 20;
                        }
                    }
                    if (o.move.time >= speed) {
                        o.move.lastDirection.x = o.move.direction.x;
                        o.move.lastDirection.y = o.move.direction.y;
                        var body = {
                            x: o.x,
                            y: o.y,
                            w: 40,
                            h: 40,
                            type: "snake body",
                            time: o.length * speed - speed,
                            snakeCollide: true,
                            noCollideTime: speed,
                            move: {
                                direction: {
                                    x: o.move.direction.x,
                                    y: o.move.direction.y
                                },
                                origin: {
                                    x: o.move.origin.x,
                                    y: o.move.origin.y
                                },
                                speed: speed
                            }
                        };
                        game.objects.objects.splice(game.objects.objects.length - 1, 0, body);
                        o.move.origin.x = o.x;
                        o.move.origin.y = o.y;
                        o.move.time = 0;
                        o.turned = false;
                        if (o.preserveTurnedStatus) {
                            o.preserveTurnedStatus = false;
                            o.turned = true;
                        }

                        if (o.move.directionQueue.length > 0) {
                            var direction = o.move.directionQueue.shift();
                            var opposed = o.move.lastDirection.x == -direction.x || o.move.lastDirection.y == -direction.y;
                            if (!opposed) {
                                o.move.direction = direction;
                            }
                        }
                    }
                    o.angle = dirTo(0, 0, o.move.direction.x, o.move.direction.y);
                    var move = false;
                    if (game.input.leftHold === 1) {
                        move = { x: -40, y: 0 }
                    }
                    if (game.input.rightHold === 1) {
                        move = { x: 40, y: 0 }
                    }
                    if (game.input.upHold === 1) {
                        move = { x: 0, y: -40 }
                    }
                    if (game.input.downHold === 1) {
                        move = { x: 0, y: 40 }
                    }
                    if (!move) return;
                    if (o.turned) {
                        if (o.move.directionQueue.length < 4) o.move.directionQueue.push(move);
                    } else {
                        o.turned = true;
                        if (o.move.time > speed * 0.6) {
                            if (o.move.directionQueue.length < 4) {
                                o.move.directionQueue.push(move);
                                o.preserveTurnedStatus = true;
                            }
                        } else {
                            var opposedX = o.move.lastDirection.x && o.move.lastDirection.x == -move.x;
                            var opposedY = o.move.lastDirection.y && o.move.lastDirection.y == -move.y;
                            var opposed = opposedX || opposedY;
                            if (!opposed) {
                                o.move.direction = move;
                            }
                        }
                    }
                },
                updateSokobanPlayer: function (o) {
                    var delay = 17;
                    var time = 5 / game.level.playerSpeedMultiplier;
                    if (game.level.level === 7 && game.level.triggers.tripped("shortcut")) {
                        time = 1;
                        delay = 0;
                    }
                    if (o.move) {
                        o.move.time++;
                        var p = o.move.time / time;
                        o.x = o.move.origin.x + o.move.direction.x * p;
                        o.y = o.move.origin.y + o.move.direction.y * p;
                        if (o.move.time >= time) {
                            o.x = o.move.origin.x + o.move.direction.x;
                            o.y = o.move.origin.y + o.move.direction.y;
                            o.move = false;
                        }
                    } else {
                        if (game.input.leftStart === 1 || game.input.leftHold > delay) {
                            o.move = {
                                direction: { x: -40, y: 0 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (game.input.rightStart === 1 || game.input.rightHold > delay) {
                            o.move = {
                                direction: { x: 40, y: 0 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (game.input.upStart === 1 || game.input.upHold > delay) {
                            o.move = {
                                direction: { x: 0, y: -40 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (game.input.downStart === 1 || game.input.downHold > delay) {
                            o.move = {
                                direction: { x: 0, y: 40 },
                                origin: { x: o.x, y: o.y },
                                time: 0
                            }
                        }
                        if (o.move && !game.level.playerFlightMode) {
                            var newPos = {
                                x: o.move.origin.x + o.move.direction.x,
                                y: o.move.origin.y + o.move.direction.y,
                                w: 40,
                                h: 40
                            }
                            var cor = newPos;
                            var moveBox = false;
                            while (game.objects.objects.find(function (e) {
                                if (e.type !== "sokoban box") return false;
                                if (e.x != cor.x) return false;
                                if (e.y != cor.y) return false;
                                return true;
                            })) {
                                var box = game.objects.objects.find(function (e) {
                                    if (e.type !== "sokoban box") return false;
                                    if (e.x != cor.x) return false;
                                    if (e.y != cor.y) return false;
                                    return true;
                                });
                                box.move = structuredClone(o.move);
                                box.move.origin.x = box.x;
                                box.move.origin.y = box.y;
                                cor.x += o.move.direction.x;
                                cor.y += o.move.direction.y;
                                cor.x = Math.round(cor.x);
                                cor.y = Math.round(cor.y);
                                moveBox = true;
                            }
                            var collide = game.objects.objects.some(function (e) {
                                if (!e.sokobanCollide && !(moveBox && e.sokobanBoxCollide)) return false;
                                if (blocksColliding(e, cor)) return true;
                            });
                            if (collide) {
                                o.move = false;
                                for (var box of game.objects.objects) {
                                    if (box.type != "sokoban box") continue;
                                    box.move = false;
                                }
                            }
                        }
                    }

                    var player = o;
                    for (var o of game.objects.objects) {
                        if (o.type != "cube") continue;
                        if (!o.collide) continue;
                        if (o.collected) continue;
                        var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                        if (dist > 50) continue;
                        o.collectedAnimation = 20;
                        o.collected = true;
                        game.particles.createEffect("collect cube", o);
                        saveData.cubesCollected[game.level.level] = true;
                        game.soundEffects.collectBlueCube();
                        updateSaveData();
                    }
                },
                updatePlayer: function (o) {
                    if (o.updatePlayer === false) return;
                    if (game.level.playerInPortal) {
                        this.updatePlayerInPortal(o);
                    } else if (o.updateMovement !== false) {
                        this.updateControlsForUpdateAngle(o);
                        this.updatePlayerMovement(o);
                        this.revertControlsForUpdateAngle(o);
                        this.updatePlayerCollisions(o);
                        this.updatePlayerPortalCollisions(o);
                    }
                    this.updatePlayerCubeCollection(o);
                    this.updatePlayerCoyoteTime(o);
                    this.updatePlayerAnimations(o);
                },
                updatePlayerInPortal: function (player) {
                    var portal = game.objects.objects.find(e => e.portalNumber == game.level.portalNumber);
                    var box = { x: portal.collideX, y: portal.collideY, w: portal.collideW, h: portal.collideH };
                    player.againstBottom = { current: false, last: 10000, time: 0 };
                    player.againstLeft = { current: false, last: 10000, time: 0 };
                    player.againstRight = { current: false, last: 10000, time: 0 };
                    player.againstTop = { current: false, last: 10000, time: 0 };
                    if (game.level.playerExitingPortal) {
                        var move = distToMove(5, portal.angle);
                        player.xmove = move.x;
                        player.ymove = move.y;
                        player.x += player.xmove;
                        player.y += player.ymove;
                        if (!blocksCollidingEdge(box, player)) {
                            game.level.playerInPortal = false;
                            game.level.playerExitingPortal = false;
                            game.level.portalNumber = false;
                            portal.teleportTime = 50;
                        }
                    } else if (blocksCollidingEdge(box, player)) {
                        var move = distToMove(5, 180 + portal.angle);
                        player.xmove = player.xmove * 0.9 + move.x * 0.1;
                        player.ymove = player.ymove * 0.9 + move.y * 0.1;
                        player.x += player.xmove;
                        player.y += player.ymove;
                    } else {
                        var pair = game.objects.objects.find(e => e.portalNumber == portal.pair);
                        if (pair) {
                            player.positionHistory = [];
                            game.level.playerExitingPortal = true;
                            game.level.portalNumber = pair.portalNumber;
                            var playerSize = player.w / 2 + player.h / 2;
                            var cor = rotate(pair.x, pair.y, pair.x + pair.length / 2, pair.y + playerSize / 2, -pair.angle);
                            player.x = cor.x - playerSize / 2;
                            player.y = cor.y - playerSize / 2;
                        }
                    }
                },
                swapPlayerAttributes: function (o, swap, swapControls) {
                    swapControls = swapControls || swap;
                    if (swap.left != "left" || swap.right != "right" || swap.top != "top" || swap.bottom != "bottom") {
                        var dirs = {
                            left: structuredClone(o.againstLeft),
                            right: structuredClone(o.againstRight),
                            top: structuredClone(o.againstTop),
                            bottom: structuredClone(o.againstBottom)
                        }
                        o.againstLeft = dirs[swap.left];
                        o.againstRight = dirs[swap.right];
                        o.againstTop = dirs[swap.top];
                        o.againstBottom = dirs[swap.bottom];
                        var dirs = {
                            left: structuredClone(o.touchingLeft),
                            right: structuredClone(o.touchingRight),
                            top: structuredClone(o.touchingTop),
                            bottom: structuredClone(o.touchingBottom)
                        }
                        o.touchingLeft = dirs[swap.left];
                        o.touchingRight = dirs[swap.right];
                        o.touchingTop = dirs[swap.top];
                        o.touchingBottom = dirs[swap.bottom];
                    }
                    if (swapControls.left != "left" || swapControls.right != "right" || swapControls.top != "top" || swapControls.bottom != "bottom") {
                        var dirs = {
                            left: game.input.left,
                            right: game.input.right,
                            top: game.input.up,
                            bottom: game.input.down
                        }
                        game.input.left = dirs[swapControls.left];
                        game.input.right = dirs[swapControls.right];
                        game.input.up = dirs[swapControls.top];
                        game.input.down = dirs[swapControls.bottom];
                        var dirs = {
                            left: game.input.leftHold,
                            right: game.input.rightHold,
                            top: game.input.upHold,
                            bottom: game.input.downHold
                        }
                        game.input.leftHold = dirs[swapControls.left];
                        game.input.rightHold = dirs[swapControls.right];
                        game.input.upHold = dirs[swapControls.top];
                        game.input.downHold = dirs[swapControls.bottom];
                        var dirs = {
                            left: game.input.leftStart,
                            right: game.input.rightStart,
                            top: game.input.upStart,
                            bottom: game.input.downStart
                        }
                        game.input.leftStart = dirs[swapControls.left];
                        game.input.rightStart = dirs[swapControls.right];
                        game.input.upStart = dirs[swapControls.top];
                        game.input.downStart = dirs[swapControls.bottom];
                    }
                },
                updateControlsForUpdateAngle: function (o) {
                    var swap = {
                        left: "left",
                        right: "right",
                        top: "top",
                        bottom: "bottom"
                    };
                    if (o.updateAngle == 270) {
                        var xmove = o.xmove;
                        var ymove = o.ymove;
                        o.ymove = xmove;
                        o.xmove = -ymove;
                        swap = {
                            left: "bottom",
                            right: "top",
                            top: "left",
                            bottom: "right"
                        }
                    }
                    if (o.updateAngle == 180) {
                        var xmove = o.xmove;
                        var ymove = o.ymove;
                        o.ymove = -ymove;
                        o.xmove = -xmove;
                        swap = {
                            left: "right",
                            right: "left",
                            top: "bottom",
                            bottom: "top"
                        }
                    }
                    if (o.updateAngle == 90) {
                        var xmove = o.xmove;
                        var ymove = o.ymove;
                        o.ymove = -xmove;
                        o.xmove = ymove;
                        swap = {
                            left: "top",
                            right: "bottom",
                            top: "right",
                            bottom: "left"
                        }
                    }
                    this.swapPlayerAttributes(o, swap, o.swapControls);
                },
                revertControlsForUpdateAngle: function (o) {
                    var swap = {
                        left: "left",
                        right: "right",
                        top: "top",
                        bottom: "bottom"
                    };
                    if (o.updateAngle == 270) {
                        var xmove = o.xmove;
                        var ymove = o.ymove;
                        o.xmove = ymove;
                        o.ymove = -xmove;
                        swap = {
                            left: "top",
                            right: "bottom",
                            top: "right",
                            bottom: "left"
                        }
                    }
                    if (o.updateAngle == 180) {
                        var xmove = o.xmove;
                        var ymove = o.ymove;
                        o.xmove = -xmove;
                        o.ymove = -ymove;
                        swap = {
                            left: "right",
                            right: "left",
                            top: "bottom",
                            bottom: "top"
                        }
                    }
                    if (o.updateAngle == 90) {
                        var xmove = o.xmove;
                        var ymove = o.ymove;
                        o.xmove = -ymove;
                        o.ymove = xmove;
                        swap = {
                            left: "bottom",
                            right: "top",
                            top: "left",
                            bottom: "right"
                        }
                    }
                    this.swapPlayerAttributes(o, swap, o.swapControls);
                },
                updatePlayerAnimations: function (o) {
                    var angle = 0;
                    var x = o.x + o.w / 2;
                    var y = o.y + o.h / 2;
                    if (o.positionHistory.length > 0) {
                        angle = dirTo(o.positionHistory[0].x, o.positionHistory[0].y, x, y);
                    }
                    o.positionHistory.unshift({ x: x, y: y, angle: angle });
                    if (game.background.effect.active("green")) {
                        while (o.positionHistory.length > 30) o.positionHistory.pop();
                    } else {
                        if (o.positionHistory.length > 11) o.positionHistory.pop();
                        if (o.positionHistory.length > 10) o.positionHistory.pop();
                    }
                    if (o.spawnTime > 0) o.spawnTime--;
                    if (o.spawnAnimation > 0) o.spawnAnimation--;
                    if (!o.eyeAngle) o.eyeAngle = 0;
                    var t = turn(o.eyeAngle, o.eyeAngleTarget);
                    if (t) o.eyeAngle += t / 4;

                    if (o.delete && !o.noDeathEffect) {
                        game.particles.createEffect("player death");
                        game.cam.screenshake = 20;
                    }

                    if (o.updateAngle) {
                        o.targetEyeHeight = 0;
                        o.eyeHeight = 0;
                        o.wallSlideAnimation = 0;
                        o.targetStretch = 0;
                        o.stretchAnimation = 0;
                        o.eyeDirection = 0;
                        o.runSkew = 0;
                        o.eyePositions[0] = { x: o.x + o.w / 2 + o.eyeDirection * 1.5 - 7, y: o.y + o.h / 2 + o.eyeHeight - 7 };
                        o.eyePositions[1] = { x: o.x + o.w / 2 + o.eyeDirection * 1.5 + 7, y: o.y + o.h / 2 + o.eyeHeight - 7 };
                        return;
                    }
                    if (game.input.up) {
                        o.targetEyeHeight--;
                        o.targetEyeHeight = Math.max(o.targetEyeHeight, -5);
                    } else {
                        o.targetEyeHeight++;
                        o.targetEyeHeight = Math.min(o.targetEyeHeight, 5);
                        if (o.ymove <= 0) {
                            if (o.targetEyeHeight > 0) o.targetEyeHeight -= 2;
                        }
                    }
                    o.eyeHeight = o.eyeHeight * 0.9 + o.targetEyeHeight * 0.1;
                    if (o.againstLeft.current && game.input.left && !o.againstBottom.current) {
                        o.wallSlideAnimation++;
                        o.wallSlideAnimationDirection = "left";
                        if (game.background.effect.active("green")) {
                            if (Math.random() < 0.06 && o.emitParticles !== false) game.particles.createEffect("player wall slide");
                        } else {
                            if (Math.random() < 0.03 && o.emitParticles !== false) game.particles.createEffect("player wall slide");
                        }
                    } else if (o.againstRight.current && game.input.right && !o.againstBottom.current) {
                        o.wallSlideAnimation++;
                        o.wallSlideAnimationDirection = "right";
                        if (game.background.effect.active("green")) {
                            if (Math.random() < 0.06 && o.emitParticles !== false) game.particles.createEffect("player wall slide");
                        } else {
                            if (Math.random() < 0.03 && o.emitParticles !== false) game.particles.createEffect("player wall slide");
                        }
                    } else {
                        o.wallSlideAnimation--;
                    }
                    o.wallSlideAnimation = Math.max(Math.min(o.wallSlideAnimation, 15), 0);
                    var targetStretch = Math.max(o.ymove, 0) * 2;
                    o.stretchAnimation = o.stretchAnimation * 0.8 + targetStretch * 0.2;
                    if (o.againstBottom.current) {
                        o.splatAnimation++;
                    } else {
                        o.splatAnimation = 0;
                    }
                    if (o.againstBottom.current) {
                        o.runSkew = o.runSkew * 0.9 + (-o.xmove / 50) * 0.05;
                    } else {
                        o.runSkew *= 0.9;
                    }
                    var target = o.xmove * 0.9;
                    if (o.wallSlideAnimation) {
                        if (o.wallSlideAnimationDirection == "right") {
                            target = 5;
                        } else {
                            target = -5;
                        }
                    }
                    target = Math.min(Math.max(target, -5), 5);
                    o.eyeDirection = o.eyeDirection * 0.9 + target * 0.1;

                    if (o.againstBottom.time == 1 && o.emitParticles !== false) game.particles.createEffect("player land");

                    if (game.background.effect.active("green")) {
                        var speed = distTo(0, 0, o.xmove, o.ymove);
                        if (t % 10 == 0 && speed > 2 && o.emitParticles !== false) game.particles.createEffect("player speed effect");
                        if ((t + 5) % 10 == 0 && speed > 8 && o.emitParticles !== false) game.particles.createEffect("player speed effect");
                    }

                    o.eyePositions[0] = { x: o.x + o.w / 2 + o.eyeDirection * 1.5 - 7, y: o.y + o.h / 2 + o.eyeHeight - 7 };
                    o.eyePositions[1] = { x: o.x + o.w / 2 + o.eyeDirection * 1.5 + 7, y: o.y + o.h / 2 + o.eyeHeight - 7 };
                },
                updatePlayerCoyoteTime: function (o) {
                    var properties = ["againstLeft", "againstRight", "againstTop", "againstBottom", "touchingLeft", "touchingRight", "touchingTop", "touchingBottom"]
                    for (var p of properties) {
                        if (o[p].current) {
                            o[p].last = 0;
                            o[p].time++;
                        } else {
                            o[p].last++;
                            o[p].time = 0;
                        }
                    }
                },
                updatePlayerMovement: function (o) {
                    if (game.level.levelComplete) {
                        o.ymove = 0;
                        return;
                    }
                    var level8SpeedMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 5 : 1;
                    var level8JumpMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 3 : 1;
                    var level8FallMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 2 : 1;
                    var speedMultiplier = game.level.playerSpeedMultiplier * level8SpeedMultiplier;
                    var jumpMultiplier = game.level.playerJumpMultiplier * level8JumpMultiplier;
                    var fallMultiplier = game.level.playerFallMultiplier * level8FallMultiplier;
                    var againstWall = o.againstLeft.current || o.againstRight.current;
                    if (game.input.left) {
                        o.xmove -= 0.4 * speedMultiplier;
                        if (game.input.leftHold > 15) o.xmove -= 0.1 * speedMultiplier;
                        if (game.background.effect.active("green")) {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.3 && !o.updateAngle && o.emitParticles !== false) game.particles.createEffect("player run");
                        } else {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.1 && !o.updateAngle && o.emitParticles !== false) game.particles.createEffect("player run");
                        }
                    }
                    if (game.input.right) {
                        o.xmove += 0.4 * speedMultiplier;
                        if (game.input.rightHold > 15) o.xmove += 0.1 * speedMultiplier;
                        if (game.background.effect.active("green")) {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.3 && !o.updateAngle && o.emitParticles !== false) game.particles.createEffect("player run");
                        } else {
                            if (o.againstBottom.current && !againstWall && Math.random() < 0.1 && !o.updateAngle && o.emitParticles !== false) game.particles.createEffect("player run");
                        }
                    }
                    if (o.againstTop.current) {
                        o.againstLeft.last = 10;
                        o.againstRight.last = 10;
                    }

                    if (game.level.playerFlightMode) {
                        if (game.input.up) {
                            o.ymove -= 0.4 * speedMultiplier;
                        }
                        if (game.input.down) {
                            o.ymove += 0.4 * speedMultiplier;
                        }
                        o.xmove *= 0.95;
                        o.ymove *= 0.95;
                        return;
                    }

                    if (game.input.up && o.ymove >= 0 && !o.touchingTop.current && o.roomToJump && !o.jumpDisabled) {
                        if (o.againstBottom.last < 5) {
                            o.ymove = -10 * jumpMultiplier;
                            o.lastJumpType = "ground";
                            o.xmove *= 1.1 * jumpMultiplier;
                            game.soundEffects.jump();
                        } else if (o.againstRight.last < 10 && (!o.wallJumpDisabled || game.level.playerGlobalWallJump)) {
                            o.ymove = -10 * jumpMultiplier;
                            o.xmove = -10 * jumpMultiplier;
                            o.lastJumpType = "wall";
                            if (!o.updateAngle && o.emitParticles !== false) game.particles.createEffect("player wall jump");
                            game.soundEffects.wallJump();
                        } else if (o.againstLeft.last < 10 && (!o.wallJumpDisabled || game.level.playerGlobalWallJump)) {
                            o.ymove = -10 * jumpMultiplier;
                            o.xmove = 10 * jumpMultiplier;
                            o.lastJumpType = "wall";
                            if (!o.updateAngle && o.emitParticles !== false) game.particles.createEffect("player wall jump");
                            game.soundEffects.wallJump();
                        }
                    }

                    if (o.againstBottom.current) {
                        if (game.input.right || game.input.left) {
                            o.xmove *= 0.9;
                        } else {
                            o.xmove *= 0.8;
                        }
                    } else {
                        o.xmove *= 0.93;
                    }
                    o.ymove *= 0.98;

                    if (o.againstRight.current && game.input.right && (!o.wallJumpDisabled || game.level.playerGlobalWallJump)) {
                        o.ymove *= 0.8;
                    }
                    if (o.againstLeft.current && game.input.left && (!o.wallJumpDisabled || game.level.playerGlobalWallJump)) {
                        o.ymove *= 0.8;
                    }


                    if (o.ymove >= 0) {
                        o.ymove += 0.3 * fallMultiplier;
                        if (game.input.up) {
                            o.ymove -= 0.05;
                        }
                    } else {
                        if (o.againstBottom.last < 20) {
                            o.ymove += 0.5 * fallMultiplier;
                            if (game.input.up) o.ymove -= 0.3;
                        } else {
                            o.ymove += 0.3 * fallMultiplier;
                            if (game.input.up) o.ymove -= 0.15;
                        }
                    }
                    if (game.input.down) {
                        if (!o.againstBottom.current) {
                            o.xmove *= 1.005;
                        }
                        if (o.ymove < 0 && o.againstBottom.last > 20) {
                            o.ymove *= 0.5;
                            o.ymove += 0.2 * speedMultiplier;
                        } else {
                            o.ymove += 0.2 * speedMultiplier;
                        }
                    }
                },
                updatePlayerCollisions: function (o) {
                    if (game.level.playerFlightMode) {
                        o.x += o.xmove;
                        o.y += o.ymove;
                        return;
                    }
                    var player = o;
                    player.againstLeft.current = false;
                    player.againstRight.current = false;
                    player.againstTop.current = false;
                    player.againstBottom.current = false;
                    player.touchingLeft.current = false;
                    player.touchingRight.current = false;
                    player.touchingTop.current = false;
                    player.touchingBottom.current = false;
                    player.roomToJump = true;
                    player.touchingSurfaces = {};
                    var oldX = player.x;
                    var oldY = player.y;
                    var oldXmove = player.xmove;
                    var oldYmove = player.ymove;
                    var axises = ["x", "y"];
                    var dims = ["w", "h"];
                    var directions = [["Left", "Right"], ["Top", "Bottom"]];
                    for (var n = 0; n < 2; n++) {
                        var axis = axises[n];
                        var altAxis = axises[(n + 1) % 2];
                        var dim = dims[n];
                        var altDim = dims[(n + 1) % 2];
                        player[axis] += player[`${axis}move`];
                        for (var o of game.objects.objects) {
                            if (o.collide === false) continue;
                            if (o.type == "player") continue;
                            var enlargedPlayer = { x: player.x, y: player.y, w: player.w, h: player.h };
                            enlargedPlayer[altAxis] += 1;
                            enlargedPlayer[altDim] -= 2;
                            if (axis == "y") {
                                this.checkForPlayerRoomToJump(player, o);
                            }
                            if (blocksCollidingEdge(enlargedPlayer, o)) {
                                player.touchingSurfaces[o.type] = true;
                                player.touchingSurfaces[o.drawType] = true;
                                if (player[axis] + player[dim] / 2 < o[axis] + o[dim] / 2) {
                                    player[`touching${directions[n][1]}`].current = true;
                                } else {
                                    player[`touching${directions[n][0]}`].current = true;
                                }
                            }
                            if (!blocksCollidingEdge(player, o)) continue;
                            if (o.type == "lava" && !game.level.levelComplete && !game.level.playerInvincible) {
                                if (o.drawType == "lava glass") o.proximity = 1.5;
                                game.soundEffects.death();
                                player.delete = true;
                            }
                            if (o.type == "unstable" && !o.touched) {
                                o.touched = true;
                                o.alpha = 1;
                            }
                            if (o.type == "button") {
                                if (axis == "x" && player.y + player.h == o.y) {
                                    if (o.h == 30 && !o.pressing) {
                                        game.soundEffects.pressButton();
                                        o.pressing = true;
                                        continue;
                                    }
                                }
                                if (axis == "y" && o.pressing) {
                                    player.y = o.y - player.h;
                                    player.ymove = 3;
                                    continue;
                                }
                            }
                            var level8JumpMultiplier = (game.level.level === 7 && game.level.triggers.tripped("shortcut")) ? 3 : 1;
                            if (o.type == "platform") {
                                if (axis == "y") {
                                    if (player.ymove > 0 && player.y + player.h < o.y + o.h && !game.input.down) {
                                        player[axis] = o[axis] - player[dim];
                                        player[`against${directions[n][1]}`].current = true;
                                        player.ymove = 0;
                                    } else {
                                        if (game.input.up) {
                                            player.ymove = -9 * game.level.playerJumpMultiplier * level8JumpMultiplier;
                                            if (player.y + player.ymove + player.h < o.y) game.soundEffects.jump();
                                        }
                                        player[`against${directions[n][1]}`].current = true;
                                    }
                                }
                                continue;
                            }
                            if (!blocksColliding(player, o)) continue;
                            if (player[axis] + player[dim] / 2 < o[axis] + o[dim] / 2) {
                                player[axis] = o[axis] - player[dim];
                                player[`against${directions[n][1]}`].current = true;
                                if (o.slippery && !player.updateAngle && !game.level.playerGlobalWallJump && axis == "x") {
                                    player[`against${directions[n][1]}`].current = false;
                                }
                            } else {
                                player[axis] = o[axis] + o[dim];
                                player[`against${directions[n][0]}`].current = true;
                                if (o.slippery && !player.updateAngle && !game.level.playerGlobalWallJump && axis == "x") {
                                    player[`against${directions[n][0]}`].current = false;
                                }
                            }
                            if (o.type != "portal") player[`${axis}move`] = 0;
                        }
                    }

                    if (player.againstBottom.current && !player.againstBottom.time) {
                        if (player.touchingSurfaces.glass) {
                            game.soundEffects.landGlass();
                        } else {
                            if (player.againstBottom.last > 200 && oldYmove > 9) {
                                game.soundEffects.heaviestLand();
                            } else if (oldYmove > 8) {
                                game.soundEffects.heavyLand();
                            } else {
                                game.soundEffects.land();
                            }
                        }
                    }
                    if (player.touchingLeft.current && !player.touchingLeft.time) {
                        if (player.touchingSurfaces.glass) {
                            game.soundEffects.landGlass();
                        } else {
                            game.soundEffects.wallHit();
                        }
                    }
                    if (player.touchingRight.current && !player.touchingRight.time) {
                        if (player.touchingSurfaces.glass) {
                            game.soundEffects.landGlass();
                        } else {
                            game.soundEffects.wallHit();
                        }
                    }
                    if (player.againstTop.current && !player.againstTop.time) {
                        if (player.touchingSurfaces.glass) {
                            game.soundEffects.landGlass();
                        } else {
                            game.soundEffects.wallHit();
                        }
                    }
                },
                updatePlayerPortalCollisions: function (player) {
                    for (var o of game.objects.objects.filter(e => e.type == "portal")) {
                        var box = { x: o.collideX, y: o.collideY, w: o.collideW, h: o.collideH };
                        if (!blocksCollidingEdge(box, player)) continue;
                        var playerPoints = [
                            { x: player.x, y: player.y },
                            { x: player.x + player.w, y: player.y },
                            { x: player.x + player.w, y: player.y + player.h },
                            { x: player.x, y: player.y + player.h }
                        ];
                        var count = playerPoints.filter(function (e) {
                            return pointInBox(e.x, e.y, box);
                        }).length;
                        if (count < 2) continue;
                        o.teleportTime = 50;
                        game.soundEffects.switchGravity();
                        game.level.playerInPortal = true;
                        game.level.portalNumber = o.portalNumber;
                    }
                },
                checkForPlayerRoomToJump: function (player, o) {
                    var hitbox = { x: player.x + player.w / 2, y: player.y - 8, w: 0, h: player.h };
                    if (player.updateAngle == 270) {
                        hitbox = { x: player.x - 8, y: player.y + player.h / 2, w: player.w, h: 0 };
                    }
                    if (player.updateAngle == 180) {
                        hitbox = { x: player.x + player.w / 2, y: player.y + 8, w: 0, h: player.h };
                    }
                    if (player.updateAngle == 90) {
                        hitbox = { x: player.x + 8, y: player.y + player.h / 2, w: player.w, h: 0 };
                    }
                    if (blocksColliding(hitbox, o)) {
                        player.roomToJump = false;
                    }
                },
                updatePlayerCubeCollection: function (o) {
                    var player = o;
                    for (var o of game.objects.objects) {
                        if (o.type != "cube") continue;
                        if (o.collected) continue;
                        if (o.noCollect === true) continue;
                        var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                        if (dist > 70) continue;
                        o.collectedAnimation = 20;
                        o.collected = true;
                        game.particles.createEffect("collect cube", o);
                        if (o.grey) {
                            if (o.red) {
                                game.soundEffects.recollectRedCube();
                            } else {
                                game.soundEffects.recollectBlueCube();
                            }
                        } else {
                            if (o.red) {
                                saveData.redCubesCollected[game.level.level] = true;
                                game.soundEffects.collectRedCube();
                            } else {
                                saveData.cubesCollected[game.level.level] = true;
                                game.soundEffects.collectBlueCube();
                            }
                            updateSaveData();
                        }
                    }
                },
                drawPlayerExplosion: function (o) {
                    this.drawPlayerTrail(o);

                    ctx.save();
                    ctx.translate(o.x + o.w / 2, o.y + o.h / 2);
                    ctx.rotate((o.eyeAngleTarget - o.explodeAnimation * 0.7) * Math.PI / 180);
                    var directions = [0, 5, 2, 6, 1, 3, 7, 4];
                    for (var n = 0; n < 8; n++) {
                        if (o.explodeAnimation < n * 30 + 20) break;
                        var a = easeInOut((o.explodeAnimation - (n * 30 + 20)) / 50);
                        var dir = directions[n] * 360 / 8;
                        ctx.save();
                        ctx.rotate(dir * Math.PI / 180);
                        if (directions[n] % 2) {
                            ctx.fillStyle = "rgb(70,100,255)";
                        } else {
                            ctx.fillStyle = "rgb(220,230,255)";
                        }
                        ctx.beginPath();
                        ctx.lineTo(-6 * a, 0);
                        ctx.lineTo(-100 * a, -700);
                        ctx.lineTo(100 * a, -700);
                        ctx.lineTo(6 * a, 0);
                        ctx.closePath();
                        ctx.fill();
                        ctx.restore();
                    }
                    ctx.fillStyle = "rgb(50,50,255)";
                    ctx.beginPath();
                    ctx.roundRect(-20, -20, 40, 40, 2);
                    ctx.fill();
                    ctx.fillStyle = "black";
                    ctx.beginPath();
                    ctx.arc(-7, -7, 3.7, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(7, -7, 3.7, 0, 2 * Math.PI);
                    ctx.fill();
                    if (o.explodeAnimation > 200) {
                        var a = easeInOut((o.explodeAnimation - 350) / 100) * 0.96 + easeInOut((o.explodeAnimation - 200) / 100) * 0.02 + Math.max((o.explodeAnimation - 250) / 100, 0) * 0.06;
                        var r1 = a * 2000;
                        var r2 = Math.max(a * 1000 - 1, 0);
                        ctx.beginPath();
                        ctx.fillStyle = "white";
                        ctx.arc(0, 0, r1, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.arc(0, 0, r2, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    ctx.restore();
                },
                drawPlayerTrail: function (o, noTranslate) {
                    ctx.fillStyle = "rgba(200,200,255,0.1)";
                    if (ppougjgaming) {
                        ctx.fillStyle = "rgba(200,255,200,0.1)";
                    }
                    if (larrythehamster) {
                        ctx.fillStyle = "rgba(255,200,200,0.1)"
                    }
                    if (notobiv) {
                        ctx.fillStyle = "rgba(0,0,0,0.1)";
                    }
                    if (game.background.effect.active("green")) {
                        ctx.fillStyle = "rgba(100,100,255,0.3)";
                        if (ppougjgaming) {
                            ctx.fillStyle = "rgba(100,255,100,0.3)";
                        }
                        if (larrythehamster) {
                            ctx.fillStyle = "rgba(255,100,100,0.3)";
                        }
                        if (notobiv) {
                            ctx.fillStyle = "rgba(0,0,0,0.3)";
                        }
                    }
                    ctx.beginPath();
                    for (var n = 0; n < o.positionHistory.length; n++) {
                        var p = o.positionHistory[n];
                        var percent = (n + 1) / o.positionHistory.length;
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        if (noTranslate) ctx.translate(-o.x, -o.y);
                        ctx.rotate(p.angle * Math.PI / 180);
                        ctx.lineTo(-(1 - percent) * o.w / 2, 0);
                        ctx.restore();
                    }
                    for (var n = o.positionHistory.length - 1; n >= 0; n--) {
                        var p = o.positionHistory[n];
                        var percent = (n + 1) / o.positionHistory.length;
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        if (noTranslate) ctx.translate(-o.x, -o.y);
                        ctx.rotate(p.angle * Math.PI / 180);
                        ctx.lineTo((1 - percent) * o.w / 2, 0);
                        ctx.restore();
                    }
                    ctx.closePath();
                    ctx.fill();
                },
                drawPlayer: function (o, noTranslate, onlyDrawTrail) {
                    this.drawPlayerTrail(o, noTranslate);
                    if (onlyDrawTrail) return;

                    ctx.save();
                    if (!noTranslate) ctx.translate(o.x, o.y);
                    if (o.angle) {
                        ctx.translate(o.w / 2, o.h / 2);
                        ctx.rotate(o.angle * Math.PI / 180);
                        ctx.translate(-o.w / 2, -o.h / 2);
                    }
                    if (o.spawnTime) {
                        ctx.globalAlpha = t % 20 < 10 ? 1 : 0.7;
                    }
                    if (o.spawnAnimation) {
                        var s = easeInOut((20 - o.spawnAnimation) / 20);
                        ctx.translate(o.w / 2, o.h / 2);
                        ctx.scale(s, s);
                        ctx.translate(-o.w / 2, -o.h / 2);
                    }

                    var skew = o.wallSlideAnimation / 500;
                    if (o.wallSlideAnimationDirection == "right") skew = -skew;
                    if (skew) ctx.transform(1, skew, 0, 1, 0, 0);
                    ctx.transform(1, 0, o.runSkew, 1, 0, 0);
                    var stretch = o.stretchAnimation / 100;
                    if (stretch) {
                        ctx.translate(o.w / 2, 0);
                        ctx.scale(1, 1 + stretch);
                        ctx.translate(-o.w / 2, 0);
                    }
                    var splat = easeInBack(o.splatAnimation / 15) / 15;
                    if (splat) {
                        ctx.translate(o.w / 2, o.h);
                        ctx.scale(1 + splat, 1 - splat);
                        ctx.translate(-o.w / 2, -o.h);
                    }
                    ctx.fillStyle = "rgb(50,50,255)";
                    if (ppougjgaming) ctx.fillStyle = "green";
                    if (larrythehamster) ctx.fillStyle = "red";
                    if (notobiv) ctx.fillStyle = "black";
                    if (kribit) {
                        ctx.drawImage(images.botBody, 0, 0, o.w, o.h);
                    } else {
                        ctx.roundRect(0, 0, o.w, o.h, 2);
                        ctx.fill();
                    }

                    ctx.translate(o.w / 2, o.h / 2);
                    if (o.eyeAngle) {
                        ctx.rotate(o.eyeAngle * Math.PI / 180);
                    }

                    if (!notobiv) {
                        ctx.fillStyle = "black";
                        if (ppougjgaming) ctx.fillStyle = "blue";
                        ctx.beginPath();
                        ctx.arc(o.eyeDirection * 1.5 - 7, o.eyeHeight - 7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(o.eyeDirection * 1.5 + 7, o.eyeHeight - 7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = "white";
                        ctx.beginPath();
                        ctx.arc(0, 0, 16, 0, 2 * Math.PI);
                        ctx.fill();

                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(o.eyeDirection * 1.5, o.eyeHeight * 1.3 + 1, 8, 0, 2 * Math.PI);
                        ctx.fill();
                    }

                    ctx.restore();
                },
                updateObject: function (o, player) {
                    if (o.update) o.update();
                    if (o.spawnAnimation) o.spawnAnimation--;
                    if (o.decay) {
                        o.alpha -= o.decay;
                        o.alpha = Math.max(o.alpha, 0);
                        if (o.maxAlpha) o.alpha = Math.max(o.alpha, o.maxAlpha);
                    }
                    if (o.invisibleUntilTouched) {
                        if (o.lastTouchedTime === undefined) o.lastTouchedTime = 1000;
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (player && blocksCollidingEdge(o, player)) {
                            o.lastTouchedTime = 0;
                        } else {
                            o.lastTouchedTime++;
                        }
                    }
                    if (o.type == "cube") {
                        if (!o.animationSpeed) o.animationSpeed = 1;
                        if (!o.animation) o.animation = 0;
                        if (o.collected) {
                            o.animationSpeed *= 0.99;
                            o.animationSpeed += 0.002;
                        }
                        if (o.collectedAnimation) o.collectedAnimation--;
                        o.animation += o.animationSpeed;
                    }
                    if (o.type == "coin dash coin") {
                        if (o.alpha <= 0) return;
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (player && !o.collected) {
                            var dist = distTo(player.x + player.w / 2, player.y + player.h / 2, o.x, o.y);
                            if (dist < 40) {
                                o.collected = true;
                                o.collectTime = 1;
                                o.alpha = 1.5;
                                game.soundEffects.collectCoin();
                            }
                        }
                        if (o.collected) {
                            o.alpha -= 0.03;
                            o.y += (1 - easeInOut(o.collectTime / 15) - easeInOut((o.collectTime - 15) / 20) * 2) * 2;
                            o.animation += Math.max(1, Math.min(o.collectTime / 3, 12));
                            o.collectTime++;
                        } else {
                            o.animation++;
                        }
                    }
                    if (o.type == "button") {
                        if (o.pressing) {
                            o.h -= 3;
                            o.y += 3;
                        }
                        o.firstPress = false;
                        if (o.h >= o.originalHeight) {
                            o.pressed = false;
                            return;
                        }
                        if (o.h == 12) {
                            o.pressing = false;
                            if (!o.pressed) {
                                o.firstPress = true;
                            }
                            o.pressed = true;
                        }
                        if (o.pushBack === false || o.pressing) return;
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (!player) {
                            o.h += 3;
                            o.y -= 3;
                            return;
                        }
                        if (blocksCollidingEdge(o, player)) return;
                        o.h += 3;
                        o.y -= 3;
                        if (blocksColliding(o, player)) {
                            o.h -= 3;
                            o.y += 3;
                        }
                    }
                    if (o.type == "unstable") {
                        if (o.touched) {
                            o.decay = 0.02;
                            if (o.decayValue) o.decay = o.decayValue;
                            if (o.alpha <= 0) o.collide = false;
                        }
                    }
                    if (o.drawType == "phase in out") {
                        if (!o.animation) {
                            o.animation = { current: false, a: 0, max: 40 };
                        }
                        var startRange = o.startRange || 100;
                        var endRange = o.endRange || 200;
                        if (player && o.playerDistCheck !== false) {
                            var xDist = Math.max(player.x - o.x - o.w, o.x - player.x - player.w, 0);
                            if (xDist < startRange) {
                                o.animation.current = true;
                            }
                            if (xDist > endRange) o.animation.current = false;
                        }
                        if (o.animation.current) {
                            o.animation.a++;
                            o.animation.a = Math.min(o.animation.a, o.animation.max);
                        } else {
                            o.animation.a--;
                            o.animation.a = Math.max(o.animation.a, 0);
                        }
                    }
                    if (o.type == "player eye") {
                        this.updatePlayerEye(o);
                    }
                    if (o.type == "sokoban player") {
                        this.updateSokobanPlayer(o);
                    }
                    if (o.type == "snake player") {
                        this.updateSnakePlayer(o);
                    }
                    if (o.type == "pacman player") {
                        this.updatePacmanPlayer(o);
                    }
                    if (o.type == "ping pong player") {
                        this.updatePingPongPlayer(o);
                    }
                    if (o.type == "circles player") {
                        this.updateCirclesPlayer(o);
                    }
                    if (o.type == "old player") {
                        this.updateOldPlayer(o);
                    }
                    if (o.type == "snake body") {
                        if (o.deathAnimation) {
                            o.deathAnimation++;
                            return;
                        }
                        if (o.noCollideTime >= 0) {
                            o.noCollideTime--;
                        } else {
                            o.noCollideTime = 0;
                        }
                        o.time--;
                        if (o.time < o.move.speed) {
                            o.moving = true;
                            var percent = 1 - (o.time / o.move.speed);
                            o.x = o.move.origin.x + o.move.direction.x * percent;
                            o.y = o.move.origin.y + o.move.direction.y * percent;
                        }
                        if (o.time <= 0) o.delete = true;
                    }
                    if (o.type == "sokoban box") {
                        var time = 5 / game.level.playerSpeedMultiplier;
                        if (game.level.level === 7 && game.level.triggers.tripped("shortcut")) {
                            time = 1;
                        }
                        if (o.move) {
                            o.move.time++;
                            var p = o.move.time / time;
                            o.x = o.move.origin.x + o.move.direction.x * p;
                            o.y = o.move.origin.y + o.move.direction.y * p;
                            if (o.move.time >= time) {
                                o.move = false;
                            }
                        }
                        var count = game.objects.objects.filter(e => e.type == "sokoban box" && e.blue).map(e => e.lit).reduce((a, b) => a + b);
                        if (o.blue) {
                            var lit = game.objects.objects.some(e => e.type == "clue" && e.x == o.x + 20 && e.y == o.y + 20);
                            if (!o.lit && lit) {
                                o.lit = lit;
                                game.soundEffects.sokobanCubeBox(count + 1);
                            }
                            o.lit = lit
                        }
                    }
                    if (o.type == "jump enemy") {
                        o.x += o.xmove;
                        if (o.x > 1460) {
                            o.xmove *= -1;
                            o.x = 1460;
                        }
                        if (o.x < 1310) {
                            o.xmove *= -1;
                            o.x = 1310;
                        }
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (player && blocksCollidingEdge(o, player)) {
                            if (player.y + player.h < o.y + o.h / 2) {
                                o.delete = true;
                                game.particles.createEffect("jump enemy death", o);
                                player.ymove = -20;
                                game.soundEffects.killJumpEnemy();
                            } else {
                                if (!game.level.playerInvincible) {
                                    player.delete = true;
                                    game.soundEffects.death();
                                }
                            }
                        }
                    }
                    if (o.drawType == "glass" || o.drawType == "lava glass" && o.collide) {
                        if (!o.proximity) o.proximity = 0;
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (player) {
                            if (blocksCollidingEdge(o, player)) {
                                o.proximity = 1.5;
                            } else {
                                o.proximity -= 0.01;
                            }
                            o.proximity = Math.max(Math.min(o.proximity, 1.5), 0);
                        }
                    }
                    if (o.type == "image" && o.image == "gravitySwitch") {
                        var move = distToMove(40, o.angle);
                        o.x += move.x;
                        o.y += move.y;
                        o.animation++;
                        o.alpha = easeInBack(o.animation / 30) * 0.3;
                        if (o.animation == 30) o.delete = true;
                    }
                    if (o.type == "image" && o.image == "gravitySwitch2") {
                        var move = distToMove(10, o.angle);
                        o.x += move.x;
                        o.y += move.y;
                        o.animation++;
                        o.alpha = easeInBack(o.animation / 30) * 0.3;
                        if (o.animation == 30) o.delete = true;
                    }
                    if (o.type == "gravity switcher") {
                        if (!o.innerAngle) o.innerAngle = 0;
                        if (!o.targetAngle) o.targetAngle = 0;
                        var t = turn(o.innerAngle, o.targetAngle);
                        o.innerAngle += t / 10;
                    }
                    if (o.type == "pacman dot") {
                        if (o.redTime) {
                            o.redTime--;
                            if (o.redTime < 10) {
                                o.alpha = 1;
                                o.collected = false;
                                o.red = true;
                                var p = o.redTime / 3;
                                o.x = o.originalX - p;
                                o.y = o.originalY - p;
                                o.w = o.originalW + p * 2;
                                o.h = o.originalH + p * 2;
                            }
                        }
                    }
                    if (o.type == "pacman ghost") {
                        this.updatePacmanGhost(o);
                    }
                    if (o.type == "boss") {
                        this.updateBoss(o);
                    }
                    if (o.type == "boss fireball") {
                        o.y++;
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (player) {
                            var dist = distTo(o.x, o.y, player.x + player.w / 2, player.y + player.h / 2);
                            if (dist < 30) {
                                player.spawnTime = 200;
                                game.cam.screenshake = 30;
                                o.delete = true;
                                for (var n = 4; n >= 0; n--) {
                                    var o2 = game.objects.objects.find(e => e.id == "player heart " + n);
                                    if (!o2.full) continue;
                                    o2.full = false;
                                    game.particles.createEffect("lose heart", o2);
                                    break;
                                }
                            }
                        }
                        if (o.y >= 95) o.delete = true;
                        if (o.delete) {
                            game.particles.createEffect("boss fireball explosion", o);
                            game.soundEffects.bossFireballExplosion();
                        }
                    }
                    if (o.type == "portal") {
                        var coordinates = [{ x: o.x, y: o.y }, { x: o.x + o.length, y: o.y }, { x: o.x + o.length, y: o.y + 5 }, { x: o.x, y: o.y + 5 }];
                        coordinates = coordinates.map(function (e) {
                            return rotate(o.x, o.y, e.x, e.y, -o.angle);
                        });
                        o.collideX = Math.min(...coordinates.map(e => e.x));
                        o.collideY = Math.min(...coordinates.map(e => e.y));
                        o.collideW = Math.max(...coordinates.map(e => e.x)) - o.collideX;
                        o.collideH = Math.max(...coordinates.map(e => e.y)) - o.collideY;
                        if (o.teleportTime) {
                            o.teleportTime--;
                        }
                    }
                },
                drawObject: function (o, player) {
                    if (o.alpha <= 0) return;
                    ctx.save();
                    ctx.translate(o.x, o.y);
                    if (o.rotate) {
                        ctx.translate(-o.x, -o.y);
                        ctx.translate(o.rotate.x, o.rotate.y);
                        ctx.rotate(o.rotate.angle * Math.PI / 180);
                        ctx.scale(o.rotate.scale, o.rotate.scale);
                        ctx.translate(-o.rotate.x, -o.rotate.y);
                        ctx.translate(o.x, o.y);
                    }
                    if (o.drawType == "snake player" || o.drawType == "pacman player") ctx.translate(o.w / 2, o.h / 2);
                    if (o.angle) ctx.rotate(o.angle * Math.PI / 180);
                    if (o.alpha) ctx.globalAlpha = o.alpha;
                    if (o.spawnAnimation) {
                        var a = 1 - easeInOut(o.spawnAnimation / o.spawnAnimationDuration);
                        ctx.globalAlpha = a;
                        ctx.scale(a, a);
                    }
                    if (o.invisibleUntilTouched) {
                        var a = Math.min(1, Math.max(0, 1.1 - o.lastTouchedTime / 100)) * 0.2;
                        ctx.globalAlpha = a;
                    }
                    if (!o.drawType) o.drawType = o.type;
                    if (o.drawType == "clue") {
                        var color = { r: 30, g: 30, b: 30, a: 1 };
                        if (o.lava) {
                            color = { r: 245, g: 0, b: 0, a: 1 };
                        }
                        if (o.air) {
                            color = { r: 0, g: 0, b: 0, a: 0.05 };
                        }
                        if (o.blue) {
                            color = { r: 0, g: 0, b: 0, a: 0.1 };
                        }
                        if (o.white) {
                            color = { r: 255, g: 255, b: 255, a: 1 };
                        }
                        if (o.proximity !== undefined) {
                            var distToPlayer;
                            var player = game.objects.objects.find(e => e.type == "player");
                            var distToPlayer;
                            if (player) {
                                distToPlayer = distTo(o.x, o.y, player.x, player.y);
                            } else {
                                distToPlayer = 10000;
                            }
                            var a = Math.max(Math.min((distToPlayer - o.radius) / o.proximity, 1), 0);
                            if (o.activated) a = 0;
                            var blue = { r: 50, g: 120, b: 255, a: 1 };
                            if (o.color) {
                                blue = o.color;
                                blue.a = 1;
                            }
                            if (color.a == 1 || a == 1) {
                                color.r = color.r * a + blue.r * (1 - a);
                                color.g = color.g * a + blue.g * (1 - a);
                                color.b = color.b * a + blue.b * (1 - a);
                            } else {
                                color.r = blue.r;
                                color.g = blue.g;
                                color.b = blue.b;
                            }
                            color.a = color.a * a + blue.a * (1 - a);
                            ctx.shadowColor = `rgba(${color.r},${color.g},${color.b},${color.a})`;
                            ctx.shadowBlur = (1 - a) * 40;
                        }
                        ctx.fillStyle = `rgba(${color.r},${color.g},${color.b},${color.a})`;
                        if (o.down) {
                            ctx.beginPath();
                            ctx.moveTo(-20, -7);
                            ctx.lineTo(20, -7);
                            ctx.lineTo(0, 15);
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.fillRect(-15, -15, 30, 30);
                        }
                    } else if (o.drawType == "cube") {
                        if (o.collected) {
                            var colorFunction = function (x, y, z, n) {
                                return `rgba(200,200,200,0.5)`;
                            }
                            if (o.onBlue) {
                                colorFunction = function (x, y, z, n) {
                                    return `rgba(0,0,0,0.1)`;
                                }
                            }
                            if (o.onRed) {
                                colorFunction = function (x, y, z, n) {
                                    return `rgba(100,100,100,0.1)`;
                                }
                            }
                            drawRotatingCube({
                                size: 30,
                                xAngle: o.animation / 150,
                                yAngle: o.animation / 170,
                                zAngle: o.animation / 180,
                                border: false,
                                colorFunction: colorFunction
                            });
                        }
                        if ((!o.collected || o.collectedAnimation) && !o.grey) {
                            if (o.collectedAnimation) {
                                ctx.globalAlpha *= o.collectedAnimation / 20;
                            }
                            var s = 1 + Math.sin(o.animation / 40) * 0.1;
                            ctx.scale(s, s);
                            var grd = ctx.createRadialGradient(0, 0, 30, 0, 0, 150);
                            if (o.red) {
                                grd.addColorStop(0, "rgba(255,0,0,0.24)");
                                grd.addColorStop(0.33, "rgba(255,0,0,0.12)");
                                grd.addColorStop(0.66, "rgba(255,0,0,0.036)");
                                grd.addColorStop(1, "rgba(255,0,0,0)");
                            } else {
                                grd.addColorStop(0, "rgba(0,0,255,0.24)");
                                grd.addColorStop(0.33, "rgba(0,0,255,0.12)");
                                grd.addColorStop(0.66, "rgba(0,0,255,0.036)");
                                grd.addColorStop(1, "rgba(0,0,255,0)");
                            }
                            ctx.fillStyle = grd;
                            ctx.beginPath();
                            ctx.arc(0, 0, 150, 0, 2 * Math.PI);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                        if (!o.collected) {
                            var s = easeInOut(o.alpha);
                            ctx.scale(s, s);
                            if (o.grey) {
                                if (o.red) {
                                    drawRotatingCube({
                                        size: 30,
                                        xAngle: o.animation / 150,
                                        yAngle: o.animation / 170,
                                        zAngle: o.animation / 180,
                                        dashedBorder: true,
                                        grey: true,
                                        red: true,
                                        colorFunction: function (x, y, z, n) {
                                            var l = (1 - y) * 150 + x * 50;
                                            var r = 200 + l;
                                            var g = 70 + l;
                                            var b = 70 + l;
                                            return `rgb(${r},${g},${b})`;
                                        }
                                    });
                                } else {
                                    drawRotatingCube({
                                        size: 30,
                                        xAngle: o.animation / 150,
                                        yAngle: o.animation / 170,
                                        zAngle: o.animation / 180,
                                        dashedBorder: true,
                                        grey: true,
                                        colorFunction: function (x, y, z, n) {
                                            var l = (1 - y) * 150 + x * 50;
                                            var r = 70 + l;
                                            var g = 70 + l;
                                            var b = 200 + l;
                                            return `rgb(${r},${g},${b})`;
                                        }
                                    });
                                }
                            } else if (o.red) {
                                drawRotatingCube({
                                    size: 30,
                                    xAngle: o.animation / 150,
                                    yAngle: o.animation / 170,
                                    zAngle: o.animation / 180,
                                    red: true,
                                    colorFunction: function (x, y, z, n) {
                                        var l = (1 - y) * 150 + x * 50;
                                        var r = 220 + l / 3;
                                        var g = 20 + l;
                                        var b = 20 + l;
                                        return `rgb(${r},${g},${b})`;
                                    }
                                });
                            } else {
                                drawRotatingCube({
                                    size: 30,
                                    xAngle: o.animation / 150,
                                    yAngle: o.animation / 170,
                                    zAngle: o.animation / 180,
                                    colorFunction: function (x, y, z, n) {
                                        var l = (1 - y) * 150 + x * 50;
                                        var r = 20 + l;
                                        var g = 20 + l * 1.2;
                                        var b = 220 + l / 3;
                                        return `rgb(${r},${g},${b})`;
                                    }
                                });
                            }
                        }
                    } else if (o.drawType == "text") {
                        ctx.fillStyle = o.color || "black";
                        ctx.font = o.font || "50px rubik";
                        ctx.textAlign = o.textAlign || "center";
                        ctx.textBaseline = o.textBaseline || "middle";
                        ctx.fillText(o.content, 0, 0);
                    } else if (o.drawType == "gravity switcher") {
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(0, 0, o.w, o.h);
                        ctx.clip();
                        ctx.translate(o.w / 2, o.h / 2);
                        ctx.rotate(o.innerAngle * Math.PI / 180);
                        ctx.drawImage(images.gravitySwitcher, -o.w, -o.h, o.w * 2, o.h * 2);
                        ctx.restore();
                        ctx.drawImage(images.gravitySwitcher3, 0, 0, o.w, o.h);
                        ctx.save();
                        ctx.translate(o.w / 2, o.h / 2);
                        ctx.rotate(o.innerAngle * Math.PI / 180);
                        var targetDistance = Math.abs(turn(o.innerAngle, o.targetAngle));
                        var s = 1 + Math.min(1, targetDistance / 90) * 0.4;
                        ctx.scale(s, s);
                        ctx.drawImage(images.gravitySwitcher2, -o.w, -o.h, o.w * 2, o.h * 2);
                        ctx.restore();
                    } else if (o.drawType == "image") {
                        ctx.drawImage(images[o.image], 0, 0, o.w, o.h);
                    } else if (o.drawType == "jump enemy") {
                        ctx.drawImage(images.jumpEnemy, 0, 0, o.w, o.h);
                    } else if (o.drawType == "arrow") {
                        ctx.strokeStyle = o.color || "black";
                        ctx.lineWidth = o.lineWidth || 12;
                        ctx.lineCap = "round";
                        ctx.lineJoin = "round";
                        var totalWidth = o.totalWidth || 200;
                        var height = o.height || 25;
                        var headWidth = o.headWidth || 40;
                        ctx.beginPath();
                        ctx.moveTo(-totalWidth / 2, 0);
                        ctx.lineTo(totalWidth / 2, 0);
                        ctx.lineTo(totalWidth / 2 - headWidth, height);
                        ctx.moveTo(totalWidth / 2, 0);
                        ctx.lineTo(totalWidth / 2 - headWidth, -height);
                        ctx.stroke();
                    } else if (o.drawType == "block") {
                        ctx.fillStyle = "black";
                        if (o.color) ctx.fillStyle = o.color;
                        if (o.blueAnimation && o.blueAnimation > 0) {
                            var x = o.blueAnimationOrigin.x;
                            var y = o.blueAnimationOrigin.y;
                            var r1 = o.blueAnimation ** 1.8 - 500;
                            var r2 = r1 + 500;
                            r1 = Math.max(r1, 0);
                            var grd = ctx.createRadialGradient(x, y, r1, x, y, r2);
                            grd.addColorStop(0, "rgb(50,50,255)");
                            grd.addColorStop(1, "black");
                            ctx.fillStyle = grd;
                        }
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "coin dash block") {
                        ctx.fillStyle = "rgb(40,20,0)";
                        ctx.fillRect(0, 0, o.w, o.h);
                        ctx.fillStyle = "rgb(0,255,0)";
                        ctx.fillRect(0, -1, o.w, 5);
                    } else if (o.drawType == "platform") {
                        ctx.fillStyle = "black";
                        if (o.color) ctx.fillStyle = o.color;
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "sokoban box") {
                        if (o.blue) {
                            if (o.lit) {
                                ctx.shadowColor = "rgb(50,120,255)";
                                ctx.shadowBlur = 40;
                                ctx.drawImage(images.sokobanBlueBoxLit, 0, 0, o.w, o.h);
                            } else {
                                ctx.drawImage(images.sokobanBlueBox, 0, 0, o.w, o.h);
                            }
                        } else {
                            ctx.drawImage(images.sokobanBox, 0, 0, o.w, o.h);
                        }
                    } else if (o.drawType == "unstable") {
                        ctx.strokeStyle = "black";
                        if (o.color) ctx.strokeStyle = o.color;
                        ctx.lineWidth = 5;
                        ctx.strokeRect(2.5, 2.5, o.w - 5, o.h - 5);
                    } else if (o.drawType == "lava") {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "red";
                        ctx.fillStyle = "red";
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "glass") {
                        var p = Math.min(o.proximity, 1);
                        ctx.fillStyle = `rgba(${p ** 0.2 * 150},${p ** 0.2 * 180},${p ** 0.2 * 255},${0.04 + p * 0.6})`;
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "lava glass") {
                        var p = Math.min(o.proximity, 1);
                        ctx.fillStyle = `rgba(255,0,0,${0.04 + p * 0.3})`;
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "button") {
                        ctx.fillStyle = "rgb(255,120,100)";
                        if (o.color) ctx.fillStyle = o.color;
                        if (o.glowing) {
                            ctx.shadowColor = "rgb(255,120,100)";
                            if (o.color) ctx.shadowColor = o.color;
                            ctx.shadowBlur = 5;
                        }
                        ctx.fillRect(0, 0, o.w, o.h - (o.glowing ? 5 : 0));
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = "rgb(50,50,50)";
                        ctx.fillRect(-10, o.h - 5, o.w + 20, 6);
                    } else if (o.drawType == "player eye") {
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(3.7, 3.7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.drawType == "sokoban player") {
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.fillRect(0, 0, 40, 40);
                        ctx.fillStyle = "black";
                        ctx.fillRect(9, 7, 7, 7);
                        ctx.fillRect(24, 7, 7, 7);
                    } else if (o.drawType == "snake player") {
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.translate(-20, -20);
                        ctx.fillStyle = "rgb(50,50,255)";
                        if (o.deathAnimation) {
                            if ((o.deathAnimation + 15) % 40 > 15) {
                                ctx.fillStyle = "rgb(50,50,200)";
                            }
                        }
                        ctx.fillRect(0, 0, 40, 40);
                        ctx.fillStyle = "black";
                        if (o.deathAnimation) {
                            ctx.save();
                            ctx.translate(9 + 7 / 2, 7 + 7 / 2);
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.fillRect(-6, -1, 12, 2);
                            ctx.fillRect(-1, -6, 2, 12);
                            ctx.restore();
                            ctx.save();
                            ctx.translate(24 + 7 / 2, 7 + 7 / 2);
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.fillRect(-6, -1, 12, 2);
                            ctx.fillRect(-1, -6, 2, 12);
                            ctx.restore();
                        } else {
                            ctx.fillRect(9, 7, 7, 7);
                            ctx.fillRect(24, 7, 7, 7);
                        }
                    } else if (o.drawType == "snake body") {
                        ctx.fillStyle = "rgb(50,50,255)";
                        if (o.deathAnimation) {
                            if ((o.deathAnimation + 15) % 40 > 15) {
                                ctx.fillStyle = "rgb(50,50,200)";
                            }
                        }
                        ctx.fillRect(0, 0, o.w, o.h);
                        if (o.moving) {
                            var percent = o.time / o.move.speed;
                            percent = Math.min(percent, 1);
                            var x = o.move.direction.x * percent;
                            var y = o.move.direction.y * percent;
                            ctx.fillRect(x, y, o.w, o.h);
                        }
                    } else if (o.drawType == "apple") {
                        ctx.fillStyle = "rgb(255,50,50)";
                        ctx.fillRect(0, 0, o.w, o.h);
                    } else if (o.drawType == "pacman player") {
                        var openDistance = Math.round((Math.sin(o.animation) * 0.5 + 0.5) * 2) / 2 * 30;
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.translate(-o.w / 2, -o.h / 2);
                        ctx.scale(o.w / 40, o.h / 40);
                        if (o.deathAnimation) {
                            var angle = Math.floor(Math.max(o.deathAnimation - 50, 0) / 10) * 90;
                            var scale = Math.max(1 - Math.floor(Math.max(o.deathAnimation - 70, 0) / 10) ** 1.2 * 0.08, 0);
                            if (scale == 0 && o.deathAnimation < 180) {
                                ctx.drawImage(images.pacmanDeath, 0, 0, 40, 40);
                            }
                            ctx.translate(o.w / 2, o.h / 2);
                            ctx.rotate(angle * Math.PI / 180);
                            ctx.scale(scale, scale);
                            ctx.translate(-o.w / 2, -o.h / 2);
                        }
                        ctx.beginPath();
                        ctx.moveTo(2 - openDistance / 5, 0);
                        ctx.lineTo(20 - openDistance / 2, 0);
                        ctx.lineTo(20, 25);
                        ctx.lineTo(20 + openDistance / 2, 0);
                        ctx.lineTo(38 + openDistance / 5, 0);
                        ctx.lineTo(40, 40);
                        ctx.lineTo(0, 40);
                        ctx.closePath();
                        ctx.fill();
                        if (o.angle == 270) {
                            ctx.translate(o.w / 2, o.h / 2);
                            ctx.scale(-1, 1);
                            ctx.translate(-o.w / 2, -o.h / 2);
                        }
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(10 - openDistance / 3.7, 8, 3.5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(11 - openDistance / 7, 20, 3.5, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.type == "pacman dot") {
                        ctx.fillStyle = "rgb(200,200,200)";
                        if (o.red) ctx.fillStyle = "rgb(255,150,150)";
                        if (o.clue) {
                            var dist = 200;
                            var player = game.objects.objects.find(e => e.type == "pacman player");
                            if (player) {
                                dist = distTo(o.x, o.y, player.x, player.y);
                            }
                            var p = easeInOut(1.2 - dist / 200);
                            ctx.fillStyle = `rgb(${200 + 55 * p},${200 - 150 * p},${200 - 150 * p})`;
                            ctx.translate(o.w / 2, o.h / 2);
                            ctx.rotate(45 * Math.PI / 180);
                            ctx.translate(-o.w / 2, -o.h / 2);
                            ctx.fillRect(0, 0, o.w, o.h);
                        } else {
                            ctx.fillRect(0, 0, o.w, o.h);
                        }
                    } else if (o.drawType == "ping pong player") {
                        ctx.scale(o.w / 40, o.h / 40);
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.fillRect(0, 0, 40, 40);
                        ctx.fillStyle = "black";
                        ctx.fillRect(9, 7, 7, 7);
                        ctx.fillRect(24, 7, 7, 7);
                    } else if (o.drawType == "circles player") {
                        ctx.scale(o.r / 40, o.r / 40);
                        ctx.fillStyle = "rgb(50,50,255)";
                        ctx.beginPath();
                        ctx.arc(0, 0, 40, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.arc(-14, -12, 7, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(14, -12, 7, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.drawType == "circle") {
                        ctx.fillStyle = o.color;
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 10;
                        ctx.beginPath();
                        ctx.arc(0, 0, o.r - 5, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    } else if (o.drawType == "old player") {
                        ctx.fillStyle = "blue";
                        ctx.fillRect(0, 0, o.w, o.h);

                        ctx.fillStyle = "black";
                        var dir = dirTo(0, 0, o.xmove, o.ymove);
                        var speed = distTo(0, 0, o.xmove, o.ymove);
                        speed = Math.min(speed, 5);
                        var move = distToMove(speed, dir);
                        ctx.beginPath();
                        ctx.arc(move.x * 1.5 + o.w / 2 - 7, move.y * 2 + o.h / 2 - 7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(move.x * 1.5 + o.w / 2 + 7, move.y * 2 + o.h / 2 - 7, 3.7, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.drawType == "pacman ghost") {
                        var x = o.direction / 90 * 200 + Math.floor(o.animation % 40 / 20) * 100;
                        var y = ["cyan", "red", "orange", "pink"].indexOf(o.color) * 100;
                        ctx.drawImage(images.ghostSpritesheet, x, y, 100, 100, -5, -5, o.w + 10, o.h + 10);
                        //ctx.restore();
                        //ctx.fillStyle = "lime";
                        //ctx.fillRect(o.targetX - 15, o.targetY - 15, 30, 30);
                        //return;
                    } else if (o.drawType == "ghost node") {
                        ctx.restore();
                        return;
                        ctx.fillStyle = "blue";
                        ctx.globalAlpha = Math.max(0, 1 - o.distToPlayer / 1000);
                        ctx.fillRect(-10, -10, 20, 20)
                    } else if (o.drawType == "coin dash coin") {
                        if (!o.animation) o.animation = 0;
                        ctx.scale(Math.abs(Math.sin(o.animation / 50)), 1);

                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;
                        ctx.fillStyle = "rgb(255,255,0)";
                        ctx.beginPath();
                        ctx.arc(0, 0, 20, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    } else if (o.drawType == "boss") {
                        var leftFireAnimation = easeInBack(o.leftFireAnimation / 30) || 0;
                        var rightFireAnimation = easeInBack(o.rightFireAnimation / 30) || 0;
                        ctx.save();
                        ctx.translate(o.w / 2, o.h / 2);
                        if (o.stunnedTime) {
                            ctx.drawImage(images.bossSpritesheet, 500, 0, 500, 500, - o.w / 2, -o.h / 2, o.w, o.h);
                            var move = distToMove(7, t * 5);
                            ctx.save();
                            ctx.translate(move.x, move.y);
                            ctx.drawImage(images.bossSpritesheet, 0, 500, 250, 500, - o.w / 2, -o.h / 2, o.w / 2, o.h);
                            ctx.restore();
                            var move = distToMove(7, -t * 5 + 180);
                            ctx.save();
                            ctx.translate(move.x, move.y);
                            ctx.drawImage(images.bossSpritesheet, 250, 500, 250, 500, 0, -o.h / 2, o.w / 2, o.h);
                            ctx.restore();
                        } else {
                            ctx.drawImage(images.bossSpritesheet, 0, 0, 500, 500, - o.w / 2, -o.h / 2, o.w, o.h);
                        }
                        ctx.drawImage(images.bossSpritesheet, 500, 700, 150, 200, -o.w * 0.9, o.h * (0.18 - leftFireAnimation * 0.05), o.w * 0.3, o.h * 0.4);
                        ctx.drawImage(images.bossSpritesheet, 500, 500, 150, 200, -o.w * 0.9, o.h * (-leftFireAnimation * 0.01), o.w * 0.3, o.h * 0.4);
                        ctx.drawImage(images.bossSpritesheet, 500, 700, 150, 200, o.w * 0.6, o.h * (0.18 - rightFireAnimation * 0.05), o.w * 0.3, o.h * 0.4);
                        ctx.drawImage(images.bossSpritesheet, 500, 500, 150, 200, o.w * 0.6, o.h * (-rightFireAnimation * 0.01), o.w * 0.3, o.h * 0.4);
                        ctx.restore();
                    } else if (o.drawType == "boss fireball") {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "rgb(220,32,32)";
                        ctx.fillStyle = "rgb(220,32,32)";
                        ctx.fillRect(-15, -15, 30, 30);
                    } else if (o.drawType == "heart") {
                        var x, y;
                        if (o.color == "blue") y = 0;
                        if (o.color == "black") y = 50;
                        if (o.color == "red") y = 100;
                        if (o.full) {
                            x = 0;
                        } else {
                            x = 100;
                        }
                        ctx.drawImage(images.heartsSpritesheet, x, y, 50, 50, 0, 0, o.w, o.h);
                    } else if (o.drawType == "phase in out") {
                        if (!o.animation) {
                            ctx.restore();
                            return;
                        }
                        var turn = o.turn || 180;
                        var a = o.animation.a / o.animation.max;
                        if (o.reverse) a = 1 - a;
                        var scale = easeInOut(a);
                        var angle = easeInOut(a) * turn;
                        ctx.translate(o.w / 2, o.h / 2);
                        ctx.rotate(angle * Math.PI / 180);
                        ctx.scale(scale, scale);
                        ctx.fillStyle = "black";
                        ctx.fillRect(-o.w / 2, -o.h / 2, o.w, o.h);
                    } else if (o.drawType == "portal") {
                        ctx.fillStyle = `rgb(${o.color.r},${o.color.g},${o.color.b})`;
                        ctx.fillRect(0, 0, o.length, 5);
                        var a = o.teleportTime || 0;
                        var alpha = 0.2 + a / 100;
                        var grd = ctx.createLinearGradient(0, 0, 0, -100 - a);
                        grd.addColorStop(0, `rgba(${o.color.r},${o.color.g},${o.color.b},${alpha})`);
                        grd.addColorStop(1, `rgba(${o.color.r},${o.color.g},${o.color.b},0)`);
                        ctx.fillStyle = grd;
                        ctx.fillRect(0, -200, o.length, 200);
                        var grd = ctx.createLinearGradient(0, 0, 0, -100 - a);
                        grd.addColorStop(0, `rgba(${o.color.r},${o.color.g},${o.color.b},${alpha / 2})`);
                        grd.addColorStop(1, `rgba(${o.color.r},${o.color.g},${o.color.b},0)`);
                        ctx.fillStyle = grd;
                        if (o.direction == "in") {
                            ctx.fillRect(0, -100 + 100 * easeInOut(t % 100 / 100), o.length, 10);
                        } else {
                            ctx.fillRect(0, -100 * easeInOut(t % 100 / 100), o.length, 10);
                        }
                    }
                    ctx.restore();
                }
            },
            particles: {
                objects: [],
                update: function () {
                    for (var o of this.objects) {
                        this.updateObject(o);
                    }
                    this.objects = this.objects.filter(e => !e.delete);
                },
                draw: function () {
                    for (var o of this.objects) {
                        this.drawObject(o);
                    }
                },
                updateObject: function (o) {
                    if (o.xmove) o.x += o.xmove;
                    if (o.ymove) o.y += o.ymove;
                    if (o.damping) {
                        o.xmove *= o.damping;
                        o.ymove *= o.damping;
                    }
                    if (o.type == "player death circle") {
                        o.r += 2;
                    }
                    if (o.type == "boss fireball explosion circle") {
                        o.r += 1.5;
                    }
                    if (o.type == "boss fireball explosion particle") {
                        o.ymove += 0.1;
                    }
                    if (o.type == "heart particle") {
                        o.ymove += 0.05;
                    }
                    if (o.type == "player eye death circle") {
                        o.r += 2;
                    }
                    if (o.type == "cube collect particle") {
                        o.r += 4;
                    }
                    if (o.type == "player speed effect particle") {
                        o.r++;
                        o.r = Math.min(o.r, 10);
                    }
                    if (o.type == "player explode particle") {
                        var move = distToMove(15, 180 + o.dir);
                        o.length += 7;
                        o.length = Math.min(o.length, 160)
                        o.x += move.x;
                        o.y += move.y;
                    }
                    if (o.rotate) {
                        o.angle += o.rotate;
                    }
                    if (o.gravity) o.ymove += o.gravity;
                    if (o.decay) o.alpha -= o.decay;
                    if (o.alpha <= 0) o.delete = true;
                },
                drawObject: function (o) {
                    if (o.r <= 0) return;
                    ctx.save();
                    if (o.alpha) ctx.globalAlpha = o.alpha;
                    if (o.drawType == "circle") {
                        ctx.translate(o.x, o.y);
                        ctx.fillStyle = o.color;
                        ctx.beginPath();
                        ctx.arc(0, 0, o.r, 0, 2 * Math.PI);
                        ctx.fill();
                    }
                    if (o.drawType == "square") {
                        ctx.translate(o.x, o.y);
                        ctx.fillStyle = o.color;
                        ctx.fillRect(-o.r, -o.r, o.r * 2, o.r * 2);
                    }
                    if (o.drawType == "image") {
                        ctx.translate(o.x, o.y);
                        if (o.angle) ctx.rotate(o.angle * Math.PI / 180);
                        ctx.drawImage(images[o.image], -o.r, -o.r, o.r * 2, o.r * 2);
                    }
                    if (o.drawType == "line") {
                        ctx.translate(o.x, o.y);
                        var move = distToMove(o.length, o.dir);
                        ctx.strokeStyle = o.color;
                        ctx.lineWidth = o.width;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(move.x, move.y);
                        ctx.stroke();
                    }
                    if (o.drawType == "heart particle") {
                        ctx.translate(o.x, o.y);
                        ctx.rotate(o.angle * Math.PI / 180);
                        ctx.scale(1.2, 1.2);
                        var x, y;
                        if (o.color == "blue") y = 0;
                        if (o.color == "black") y = 50;
                        if (o.color == "red") y = 100;
                        if (o.left) {
                            x = 50;
                        } else if (o.right) {
                            x = 75;
                        }
                        ctx.drawImage(images.heartsSpritesheet, x, y, 25, 50, - o.w / 2, -o.h / 2, o.w, o.h);
                    }
                    ctx.restore();
                },
                create: function (o) {
                    if (o.type == "player speed effect particle") {
                        o.drawType = "image";
                        o.image = "greenSparkle";
                        o.r = -5;
                        o.rotate = 3;
                        if (Math.random() < 0.5) o.rotate *= -1;
                        o.angle = Math.random() * 360;
                        o.alpha = 1 + Math.random();
                        o.gravity = 0.01;
                        o.decay = 0.02;
                    }
                    if (o.type == "player land particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,255,0.5)";
                        if (ppougjgaming) {
                            o.color = "rgba(0,128,0,0.5)";
                        }
                        if (larrythehamster) {
                            o.color = "rgba(255,0,0,0.5)";
                        }
                        if (notobiv) {
                            o.color = "rgba(0,0,0,0.5)";
                        }
                        o.alpha = 1 + Math.random();
                        if (game.background.effect.active("green")) {
                            o.color = "rgba(0,0,255,0.7)";
                            o.r = 4.5;
                            if (ppougjgaming) {
                                o.color = "rgba(0,128,0,0.7)";
                            }
                            if (larrythehamster) {
                                o.color = "rgba(255,0,0,0.7)";
                            }
                            if (notobiv) {
                                o.color = "rgba(0,0,0,0.7)";
                            }
                        }
                        o.gravity = 0.01;
                        o.decay = 0.05;
                    }
                    if (o.type == "player wall jump particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,255,0.5)";
                        if (ppougjgaming) {
                            o.color = "rgba(0,128,0,0.5)";
                        }
                        if (larrythehamster) {
                            o.color = "rgba(255,0,0,0.5)";
                        }
                        if (notobiv) {
                            o.color = "rgba(0,0,0,0.5)";
                        }
                        if (game.background.effect.active("green")) {
                            o.color = "rgba(0,0,255,0.7)";
                            o.r = 4.5;
                            if (ppougjgaming) {
                                o.color = "rgba(0,128,0,0.7)";
                            }
                            if (larrythehamster) {
                                o.color = "rgba(255,0,0,0.7)";
                            }
                            if (notobiv) {
                                o.color = "rgba(0,0,0,0.7)";
                            }
                        }
                        o.alpha = 1 + Math.random();
                        o.gravity = 0.03;
                        o.decay = 0.05;
                    }
                    if (o.type == "player run particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,255,0.1)";
                        if (ppougjgaming) {
                            o.color = "rgba(0,128,0,0.1)";
                        }
                        if (larrythehamster) {
                            o.color = "rgba(255,0,0,0.1)";
                        }
                        if (notobiv) {
                            o.color = "rgba(0,0,0,0.1)";
                        }
                        if (game.background.effect.active("green")) {
                            o.color = "rgba(0,0,255,0.3)";
                            o.r = 4.5;
                            if (ppougjgaming) {
                                o.color = "rgba(0,128,0,0.3)";
                            }
                            if (larrythehamster) {
                                o.color = "rgba(255,0,0,0.3)";
                            }
                            if (notobiv) {
                                o.color = "rgba(0,0,0,0.3)";
                            }
                        }
                        o.alpha = 3 + Math.random();
                        o.decay = 0.05;
                    }
                    if (o.type == "player death particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.damping = 0.99;
                        o.color = "rgba(0,0,255,0.5)";
                        if (ppougjgaming) {
                            o.color = "rgba(0,128,0,0.5)";
                        }
                        if (larrythehamster) {
                            o.color = "rgba(255,0,0,0.5)";
                        }
                        if (notobiv) {
                            o.color = "rgba(0,0,0,0.5)";
                        }
                        o.alpha = 3 + Math.random() * 3;
                        o.decay = 0.05;
                    }
                    if (o.type == "player eye death particle") {
                        o.drawType = "circle";
                        o.r = 2;
                        o.damping = 0.99;
                        o.color = "rgba(0,0,0,0.5)";
                        o.alpha = 3 + Math.random() * 3;
                        o.decay = 0.05;
                    }
                    if (o.type == "player death circle") {
                        o.drawType = "circle";
                        o.r = 10;
                        o.color = "rgba(0,0,255,0.3)";
                        if (ppougjgaming) {
                            o.color = "rgba(0,128,0,0.3)";
                        }
                        if (larrythehamster) {
                            o.color = "rgba(255,0,0,0.3)";
                        }
                        if (notobiv) {
                            o.color = "rgba(0,0,0,0.3)";
                        }
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "player eye death circle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.color = "rgba(0,0,0,0.1)";
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "cube collect particle") {
                        o.drawType = "circle";
                        o.r = 10;
                        o.color = "rgba(100,100,255,0.3)";
                        if (o.red) {
                            o.color = "rgba(255,100,100,0.3)";
                        }
                        if (o.grey) {
                            o.color = "rgba(200,200,200,0.3)";
                        }
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "jump enemy death particle") {
                        o.drawType = "square";
                        o.r = 5;
                        o.color = "red";
                        o.alpha = 1;
                        o.decay = 0.05;
                        var move = distToMove(1 + Math.random() * 2.5, Math.random() * 360);
                        o.xmove = move.x;
                        o.ymove = move.y;
                    }
                    if (o.type == "ping pong player death particle") {
                        o.drawType = "square";
                        o.r = 5;
                        o.color = "blue";
                        o.alpha = 50;
                        o.decay = 1;
                    }
                    if (o.type == "boss fireball explosion particle") {
                        o.drawType = "circle";
                        o.r = 3;
                        o.damping = 0.99;
                        o.color = "rgba(255,0,0,0.5)";
                        o.alpha = 3 + Math.random() * 3;
                        o.decay = 0.05;
                    }
                    if (o.type == "boss fireball explosion circle") {
                        o.drawType = "circle";
                        o.r = 10;
                        o.color = "rgba(255,0,0,0.3)";
                        o.alpha = 1.5;
                        o.decay = 0.05;
                    }
                    if (o.type == "heart particle") {
                        o.drawType = "heart particle";
                        o.alpha = 2;
                        o.decay = 0.04;
                        o.damping = 0.99;
                        o.angle = 0;
                        if (o.left) {
                            o.xmove = -1;
                            o.rotate = -0.8;
                        } else if (o.right) {
                            o.xmove = 1;
                            o.rotate = 0.8;
                        }
                        o.ymove = 1;
                    }
                    if (o.type == "player explode particle") {
                        o.drawType = "line";
                        o.width = 2;
                        o.color = "rgb(50,50,255)";
                        o.dir = Math.random() * 360;
                        o.length = 0;
                        o.alpha = 4;
                        o.decay = 0.05;
                    }
                    this.objects.push(o);
                },
                createEffect: function (effect, data) {
                    var player;
                    if (effect.includes("player") || effect == "boss fireball explosion") {
                        player = game.objects.objects.find(e => e.type == "player");
                        if (!player) {
                            if (data) {
                                player = data;
                            } else {
                                return;
                            }
                        }
                    }
                    if (effect == "player speed effect") {
                        var o = {};
                        o.type = "player speed effect particle";
                        o.x = player.x + player.w * Math.random();
                        o.y = player.y + player.h * Math.random();
                        o.xmove = 0;
                        o.ymove = - Math.random() * 1;
                        this.create(o);
                    }
                    if (effect == "player land") {
                        var amount = 5;
                        if (game.background.effect.active("green")) amount *= 2;
                        for (var n = 0; n < amount; n++) {
                            var percent = n / (amount - 1);
                            var o = {};
                            o.type = "player land particle";
                            o.x = player.x + player.w * percent;
                            o.y = player.y + player.h;
                            o.xmove = -2.5 + 5 * percent;
                            o.ymove = - Math.random() * 1;
                            this.create(o);
                        }
                    }
                    if (effect == "player run") {
                        var o = {};
                        o.type = "player run particle";
                        o.y = player.y + player.h * (0.7 + Math.random() * 0.3);
                        o.ymove = -0.2 - Math.random() * 0.3;
                        if (player.xmove > 0) {
                            o.x = player.x;
                            o.xmove = -0.5;
                        } else {
                            o.x = player.x + player.w;
                            o.xmove = 0.5;
                        }
                        this.create(o);
                    }
                    if (effect == "player wall jump") {
                        var count = 3;
                        if (game.background.effect.active("green")) amount *= 2;
                        for (var n = 0; n < count; n++) {
                            var percent = n / count;
                            var o = {};
                            o.type = "player wall jump particle";
                            o.y = player.y + player.h * percent;
                            o.ymove = -3 + 5 * percent;
                            if (player.xmove > 0) {
                                o.x = player.x;
                                o.xmove = Math.random() * 0.8 + 0.1;
                            } else {
                                o.x = player.x + player.w;
                                o.xmove = -Math.random() * 0.8 - 0.1;
                            }
                            this.create(o);
                        }
                    }
                    if (effect == "player wall slide") {
                        var o = {};
                        o.type = "player wall jump particle";
                        o.y = player.y;
                        o.ymove = -1;
                        if (player.wallSlideAnimationDirection == "left") {
                            o.x = player.x;
                            o.xmove = Math.random() * 1 + 0.3;
                        } else {
                            o.x = player.x + player.w;
                            o.xmove = -Math.random() * 1 - 0.3;
                        }
                        this.create(o);
                    }
                    if (effect == "player death") {
                        var count = 10;
                        for (var n = 0; n < count; n++) {
                            var o = {};
                            o.type = "player death particle";
                            o.y = player.y + player.h / 2;
                            o.x = player.x + player.w / 2;
                            var dir = Math.random() * 360;
                            var speed = 1 + Math.random();
                            var move = distToMove(speed, dir);
                            o.xmove = move.x;
                            o.ymove = move.y;
                            this.create(o);
                        }
                        var o = {};
                        o.type = "player death circle";
                        o.y = player.y + player.h / 2;
                        o.x = player.x + player.w / 2;
                        this.create(o);
                    }
                    if (effect == "eye death") {
                        var player = data;
                        var count = 5;
                        for (var n = 0; n < count; n++) {
                            var o = {};
                            o.type = "player eye death particle";
                            o.y = player.y + player.h / 2;
                            o.x = player.x + player.w / 2;
                            var dir = Math.random() * 360;
                            var speed = 1 + Math.random();
                            var move = distToMove(speed, dir);
                            o.xmove = move.x;
                            o.ymove = move.y;
                            this.create(o);
                        }
                        var o = {};
                        o.type = "player eye death circle";
                        o.y = player.y + player.h / 2;
                        o.x = player.x + player.w / 2;
                        this.create(o);
                    }
                    if (effect == "collect cube") {
                        var o = {};
                        o.x = data.x;
                        o.y = data.y;
                        o.grey = data.grey;
                        o.red = data.red;
                        o.type = "cube collect particle";
                        this.create(o);
                    }
                    if (effect == "jump enemy death") {
                        for (var n = 0; n < 40; n++) {
                            var o = {};
                            o.x = data.x;
                            o.y = data.y;
                            o.type = "jump enemy death particle";
                            this.create(o);
                        }
                    }
                    if (effect == "ping pong death") {
                        for (var n = 0; n < 8; n++) {
                            var angle = n / 8 * 360;
                            var move = distToMove(2, angle);
                            var o = {};
                            o.x = data.x;
                            o.y = data.y;
                            o.xmove = move.x;
                            o.ymove = move.y;
                            o.type = "ping pong player death particle";
                            this.create(o);
                        }
                    }
                    if (effect == "boss fireball explosion") {
                        var count = 6;
                        for (var n = 0; n < count; n++) {
                            var o = {};
                            o.type = "boss fireball explosion particle";
                            o.y = data.y - 15;
                            o.x = data.x;
                            var dir = Math.random() * 200 - 100;
                            var speed = 1 + Math.random();
                            var move = distToMove(speed, dir);
                            o.xmove = move.x;
                            o.ymove = move.y;
                            this.create(o);
                        }
                        var o = {};
                        o.type = "boss fireball explosion circle";
                        o.y = data.y - 15;
                        o.x = data.x;
                        this.create(o);
                    }
                    if (effect == "lose heart") {
                        var o = {
                            type: "heart particle",
                            x: data.x + data.w * 0.25,
                            y: data.y + data.h * 0.5,
                            w: data.w / 2,
                            h: data.h,
                            left: true,
                            color: data.color
                        }
                        this.create(o);
                        var o = {
                            type: "heart particle",
                            x: data.x + data.w * 0.75,
                            y: data.y + data.h * 0.5,
                            w: data.w / 2,
                            h: data.h,
                            right: true,
                            color: data.color
                        }
                        this.create(o);
                    }
                    if (effect == "player explode") {
                        var o = {
                            type: "player explode particle"
                        }
                        o.x = player.x + player.w / 2;
                        o.y = player.y + player.h / 2;
                        this.create(o);
                    }
                }
            },
            cam: {
                screenshake: 0,
                x: 0,
                y: 0,
                zoom: 1,
                angle: 0,
                realX: 0,
                realY: 0,
                realZoom: 1,
                realAngle: 0,
                origin: { x: 0, y: 0 },
                offset: { x: 0, y: 0 },
                shakeX: 0,
                shakeY: 0,
                viewportBoundary: false,
                followX: 0,
                followY: 0,
                updateRealCoordinates: function () {
                    if (game.level.lockedCamera) return;
                    if (game.level.lockedPlayerCamera) {
                        var player = game.objects.objects.find(e => e.type == "player");
                        if (!player) player = game.objects.objects.find(e => e.type.includes("player") && e.type != "player copy");
                        if (player) {
                            this.realX = player.x;
                            this.realY = player.y;
                            this.realAngle = 0;
                            this.realZoom = 0.8;
                        }
                        return;
                    }
                    this.realX = this.x;
                    this.realY = this.y;
                    this.realZoom = this.zoom;
                    this.realAngle = this.angle;
                },
                update: function () {
                    if (this.screenshake) this.screenshake--;
                    this.screenshake = Math.max(this.screenshake, 0);
                    this.shakeX = Math.random() * this.screenshake - this.screenshake / 2;
                    this.shakeY = Math.random() * this.screenshake - this.screenshake / 2;
                    var o = game.objects.objects.find(e => e.type == "player");
                    var eye1 = game.objects.objects.find(e => e.id == "player eye 1");
                    var eye2 = game.objects.objects.find(e => e.id == "player eye 2");
                    if (!o && eye1 && eye2) {
                        var o = { x: eye1.x / 2 + eye2.x / 2, y: eye1.y / 2 + eye2.y / 2, w: 0, h: 0 };
                    } else if (!o) {
                        o = game.objects.objects.find(e => e.type.includes("player") && e.type != "player copy");
                    }
                    if (o) {
                        var distToPlayer = distTo(this.x, this.y, o.x + this.offset.x, o.y + this.offset.y);
                        var followX = this.followX;
                        var followY = this.followY;
                        if (distToPlayer > 100) {
                            followX += (distToPlayer - 100) / 5000;
                            followY += (distToPlayer - 100) / 5000;
                        }
                        followX = Math.max(Math.min(followX, 1), 0);
                        followY = Math.max(Math.min(followY, 1), 0);
                        if (this.speedModifiers) {
                            if (this.speedModifiers.x !== undefined) {
                                followX *= this.speedModifiers.x;
                            }
                            if (this.speedModifiers.y !== undefined) {
                                followY *= this.speedModifiers.y;
                            }
                        }
                        this.x = this.x * (1 - followX) + (o.x + this.offset.x + o.w / 2) * followX;
                        this.y = this.y * (1 - followY) + (o.y + this.offset.y + o.h / 2) * followY;
                    }

                    if (this.viewportBoundary) {
                        var o = this.viewportBoundary;
                        this.x = Math.max(Math.min(this.x, o.x + o.w), o.x);
                        this.y = Math.max(Math.min(this.y, o.y + o.h), o.y);
                    }

                    if (this.levelFunction) this.levelFunction();
                },
                levelFunction: false,
                alignViewport: function () {
                    ctx.translate(500, 500);
                    ctx.rotate(this.realAngle * Math.PI / 180);
                    ctx.scale(this.realZoom, this.realZoom);
                    ctx.translate(-this.realX + this.shakeX, -this.realY + this.shakeY);
                },
                alignCoordinates: function (x, y) {
                    x = (x - this.realX + this.shakeX) * this.realZoom + 500;
                    y = (y - this.realY + this.shakeY) * this.realZoom + 500;
                    return { x: x, y: y };
                }
            },
            ui: {
                timer: {
                    gameTime: -1,
                    levelTime: -1,
                    newBestTime: false,
                    update: function () {
                        var transitionPercent = game.level.levelTransition / game.level.levelTransitionCap;
                        if (!game.level.levelComplete && transitionPercent < 0.5 || transitionPercent === 0) {
                            if (saveData.levelsBeaten < 10) this.gameTime++;
                            this.levelTime++;
                        }
                    },
                    draw: function () {
                        ctx.fillStyle = "black";
                        ctx.strokeStyle = "white";
                        ctx.lineWidth = 5;
                        ctx.textAlign = "left";
                        ctx.textBaseline = "middle";
                        ctx.font = "40px rubik";
                        var timeText = createTimeText(this.gameTime);
                        var chars = timeText.split("");
                        var x = 980;
                        for (var n = chars.length - 1; n >= 0; n--) {
                            var char = chars[n];
                            if (char == "." || char == ":") {
                                x -= 12;
                            } else {
                                x -= 25;
                            }
                            ctx.strokeText(char, x, 40);
                            ctx.fillText(char, x, 40);
                        }

                        x -= 50;
                        var timeText = createTimeText(this.levelTime);
                        var chars = timeText.split("");
                        for (var n = chars.length - 1; n >= 0; n--) {
                            var char = chars[n];
                            if (char == "." || char == ":") {
                                x -= 12;
                            } else {
                                x -= 25;
                            }
                            ctx.strokeText(char, x, 40);
                            ctx.fillText(char, x, 40);
                        }
                        x -= 110;
                        ctx.strokeText("Split: ", x, 40);
                        ctx.fillText("Split: ", x, 40);
                    },
                    updateBestLevelSplit: function (level) {
                        var previousLevelTime = saveData.bestLevelSplits[level];
                        previousLevelTime = previousLevelTime || Infinity;
                        if (this.levelTime < previousLevelTime) {
                            saveData.bestLevelSplits[level] = this.levelTime;

                        }
                    },
                    newLevel: function () {
                        this.levelTime = 0;
                    },
                    newGame: function () {
                        this.levelTime = -1;
                        this.gameTime = -1;
                    }
                },
                update: function () {
                    this.timer.update();
                },
                draw: function () {
                    this.timer.draw();
                }
            },
            level: {
                level: 0,
                tookShortcutLastLevel: false,
                levelAnimationTime: 0,
                playerControlDelay: 0,
                playerInPortal: false,
                portalNumber: false,
                playerExitingPortal: false,
                playerSpawnPoint: {},
                lastPlayerPosition: {},
                levelComplete: false,
                levelTransition: 0,
                levelTransitionCap: 100,
                playerDead: false,
                playerRespawnTime: 0,
                levelCompleteFunction: false,
                playerDeadFunction: false,
                manualRespawn: false,
                autoSkipCutscenes: false,
                lockedCamera: false,
                lockedPlayerCamera: false,
                stopLevelComplete: false,
                showWireframes: false,
                playerInvincible: false,
                playerGlobalWallJump: false,
                playerSpeedMultiplier: 1,
                playerJumpMultiplier: 1,
                playerFallMultiplier: 1,
                playerFlightMode: false,
                update: function () {
                    this.levelAnimationTime++;

                    if (this.playerControlDelay) this.playerControlDelay--;
                    if (this.autoSkipCutscenes) this.playerControlDelay = 0;

                    var player = game.objects.objects.find(e => e.type == "player");
                    var playerEye = game.objects.objects.find(e => e.id == "player eye 1") && game.objects.objects.find(e => e.id == "player eye 2");
                    if (player) {
                        this.lastPlayerPosition.x = player.x;
                        this.lastPlayerPosition.y = player.y;
                    } else if (playerEye) {
                        var eye1 = game.objects.objects.find(e => e.id == "player eye 1");
                        var eye2 = game.objects.objects.find(e => e.id == "player eye 2");
                        this.lastPlayerPosition.x = eye1.x * 0.5 + eye2.x * 0.5;
                        this.lastPlayerPosition.y = eye1.y * 0.5 + eye2.y * 0.5;
                    } else {
                        var possiblePlayers = game.objects.objects.filter(e => e.type.includes("player") && e.type != "player copy");
                        var substitutePlayer = possiblePlayers[possiblePlayers.length - 1];
                        if (substitutePlayer) {
                            this.lastPlayerPosition.x = substitutePlayer.x;
                            this.lastPlayerPosition.y = substitutePlayer.y;
                        }
                    }

                    this.triggers.update();

                    if (this.levelComplete) {
                        this.levelTransition++;
                        if (game.input.skip) this.levelTransition = this.levelTransitionCap;
                        if (this.levelTransition >= this.levelTransitionCap) {
                            game.background.effect.end("all");
                            game.ui.timer.updateBestLevelSplit(this.level);
                            this.level++;
                            if (this.tookShortcutLastLevel) {
                                this.reload(this.level);
                                var player = game.objects.objects.find(e => e.type == "player");
                                player.spawnTime = 0;
                                player.spawnAnimation = 0;
                                this.tookShortcutLastLevel = false;
                            } else {
                                this.load(this.level);
                            }
                            game.ui.timer.newLevel();
                            saveData.levelsBeaten = Math.max(saveData.levelsBeaten, this.level);
                            updateSaveData();
                        }
                        return;
                    } else {
                        this.levelTransition--;
                        if (game.input.skip) this.levelTransition = 0;
                    }
                    this.levelTransition = Math.min(Math.max(this.levelTransition, 0), this.levelTransitionCap);

                    if (this.levelCompleteFunction() && !this.stopLevelComplete) {
                        this.levelComplete = true;
                        if (this.triggers.tripped("shortcut")) {
                            this.tookShortcutLastLevel = true;
                            this.takeShortcut();
                        }
                    }

                    if (!this.playerDead) {
                        if (this.playerDeadFunction) {
                            if (this.playerDeadFunction()) {
                                this.playerDead = true;
                                this.playerRespawnTime = 200;
                            }
                        } else {
                            if (!player && !playerEye) {
                                this.playerDead = true;
                                this.playerRespawnTime = 200;
                            }
                        }
                    } else {
                        if (this.respawnTimeFunction) {
                            this.respawnTimeFunction();
                        } else {
                            this.playerRespawnTime--;
                        }
                        if (this.manualRespawn) {
                            this.playerRespawnTime;
                            if (this.playerRespawnTime <= 0) {
                                this.playerDead = false;
                                this.manualRespawn();
                            }
                        } else {
                            var a = Math.min(Math.max((120 - this.playerRespawnTime) / 120, 0), 1);
                            var p0 = easeInOut(a);
                            var p = easeInOut(a) * (1 - a);
                            game.cam.x = game.cam.x * (1 - p0) + game.cam.origin.x * p0;
                            game.cam.y = game.cam.y * (1 - p0) + game.cam.origin.y * p0;
                            game.cam.zoom = game.cam.zoom * (1 - p) + 1 * p;
                            game.backgroundOffset.x = game.backgroundOffset.x * (1 - p);
                            game.backgroundOffset.y = game.backgroundOffset.y * (1 - p);
                            if (this.playerRespawnTime <= 0) {
                                this.playerDead = false;
                                this.reload(this.level);
                            }
                        }
                    }

                    if (game.input.skip) {
                        if (levels[this.level].reload) levels[this.level].reload();
                        this.levelAnimationTime = 100000;
                        this.playerControlDelay = 0;
                    }

                    if (game.input.restartLevel) {
                        this.load(this.level);
                        game.ui.timer.newLevel();
                    }

                    if (game.input.restartGame) {
                        game.newGame();
                    }
                },
                drawLevelTransition: function () {
                    if (!this.levelTransition) return;
                    if (isNaN(this.lastPlayerPosition.x) || isNaN(this.lastPlayerPosition.y)) {
                        ctx.fillStyle = "black";
                        ctx.fillRect(0, 0, 1000, 1000);
                        return;
                    }
                    var a = easeInOut(this.levelTransition / (this.levelTransitionCap * 0.8));
                    var radius = (1 - a) * 1500;
                    var cors = game.cam.alignCoordinates(this.lastPlayerPosition.x + 20, this.lastPlayerPosition.y + 20);
                    var grd = ctx.createRadialGradient(cors.x, cors.y, radius, cors.x, cors.y, radius + 20);
                    grd.addColorStop(0, "rgba(0,0,0,0)");
                    grd.addColorStop(1, "rgba(0,0,0,1)");
                    ctx.fillStyle = grd;
                    ctx.fillRect(0, 0, 1000, 1000);

                    ctx.save();
                    ctx.fillStyle = "black";
                    ctx.globalAlpha = easeInOut((a - 0.99) * 100);
                    ctx.fillRect(0, 0, 1000, 1000);
                    ctx.restore();
                },
                discoverRedCube: function () {
                    saveData.redCubesDiscovered[this.level] = true;
                    updateSaveData();
                },
                discoverShortcut: function () {
                    saveData.shortcutsDiscovered[this.level] = true;
                    updateSaveData();
                },
                takeShortcut: function () {
                    saveData.shortcutsTaken[this.level] = true;
                    updateSaveData();
                },
                createPlayer: function (x, y) {
                    var o = {
                        type: "player",
                        x: x,
                        y: y,
                        w: 40,
                        h: 40,
                        xmove: 0,
                        ymove: 0,
                        targetEyeHeight: 0,
                        eyeHeight: 0,
                        eyeDirection: 0,
                        wallSlideAnimation: 0,
                        wallSlideAnimationDirection: "right",
                        stretchAnimation: 0,
                        splatAnimation: 0,
                        lastJumpType: false,
                        runSkew: 0,
                        positionHistory: [],
                        eyePositions: [],
                        againstLeft: { current: false, last: 100, time: 0 },
                        againstRight: { current: false, last: 100, time: 0 },
                        againstTop: { current: false, last: 100, time: 0 },
                        againstBottom: { current: false, last: 100, time: 0 },
                        touchingLeft: { current: false, last: 100, time: 0 },
                        touchingRight: { current: false, last: 100, time: 0 },
                        touchingTop: { current: false, last: 100, time: 0 },
                        touchingBottom: { current: false, last: 100, time: 0 },
                        roomToJump: true,
                        touchingSurfaces: {}
                    };
                    return o;
                },
                load: function (level) {
                    this.level = level;
                    this.levelAnimationTime = 0;
                    game.objects.objects = structuredClone(levels[level].objects);
                    game.particles.objects = [];
                    if (saveData.cubesCollected[this.level]) {
                        var cube = game.objects.objects.find(e => e.type == "cube");
                        if (cube) {
                            cube.color = "blue";
                            cube.grey = true;
                        }
                    }
                    if (saveData.redCubesCollected[this.level]) {
                        var cube = game.objects.objects.find(e => e.type == "cube" && e.red);
                        if (cube) {
                            cube.color = "red";
                            cube.grey = true;
                        }
                    }
                    for (var o of game.objects.objects) {
                        if (o.type == "text") o.collide = false;
                        if (o.type == "arrow") o.collide = false;
                        if (o.type == "button") o.slippery = o.slippery || true;
                        if (!o.w || !o.h) o.collide = false;
                    }
                    this.playerSpawnPoint = levels[level].spawnPoint;
                    var player = game.level.createPlayer(this.playerSpawnPoint.x, this.playerSpawnPoint.y);
                    game.objects.objects.push(player);
                    game.cam.levelFunction = levels[level].camFunction || false;
                    game.cam.viewportBoundary = structuredClone(levels[level].viewportBoundary);
                    game.cam.offset = structuredClone(levels[level].camOffset);
                    var x = levels[level].camStartingPosition.x;
                    var y = levels[level].camStartingPosition.y;
                    if (!game.newGameFromMenu) {
                        game.cam.x = x;
                        game.cam.y = y;
                    }
                    game.newGameFromMenu = false;
                    game.cam.origin = { x: x, y: y };
                    game.cam.zoom = 1;
                    game.cam.angle = 0;
                    game.cam.screenshake = 0;
                    game.cam.speedModifiers = levels[level].camSpeedModifiers || false;
                    game.cam.followX = levels[level].camFollowX || 0.01;
                    game.cam.followY = levels[level].camFollowY || 0.01;
                    game.backgroundOffset = { x: 0, y: 0 };
                    game.backgroundPatternOffset = { x: 0, y: 0 };
                    game.backgroundOpacity = 1;
                    game.level.playerRespawnTime = 0;
                    game.level.playerDead = false;
                    if (levels[level].playerDeadFunction) {
                        this.playerDeadFunction = levels[level].playerDeadFunction;
                    } else {
                        this.playerDeadFunction = false;
                    }
                    if (levels[level].manualRespawn) {
                        this.manualRespawn = levels[level].manualRespawn;
                    } else {
                        this.manualRespawn = false;
                    }
                    if (levels[level].respawnTimeFunction) {
                        this.respawnTimeFunction = levels[level].respawnTimeFunction;
                    } else {
                        this.respawnTimeFunction = false;
                    }
                    this.playerControlDelay = levels[level].playerControlDelay || 0;
                    this.playerInPortal = false;
                    this.portalNumber = false;
                    this.playerExitingPortal = false;
                    this.triggers.triggered = [];
                    this.triggers.triggerChecks = levels[level].triggers || [];
                    this.levelCompleteFunction = levels[level].levelComplete;
                    this.levelComplete = false;
                    game.background.effect.end("all");
                },
                reload: function (level) {
                    this.load(level);
                    for (var o of game.objects.objects) {
                        if (o.spawnAnimation) o.spawnAnimation = 0;
                    }
                    this.playerControlDelay = 0;
                    this.levelAnimationTime = 100000;
                    var player = game.objects.objects.find(e => e.type == "player");
                    player.spawnTime = 150;
                    player.spawnAnimation = 20;
                    game.background.effect.end("all");
                    if (levels[level].reload) levels[level].reload();
                },
                triggers: {
                    triggerChecks: [],
                    triggered: [],
                    tripped: function (name) {
                        return this.triggered.includes(name);
                    },
                    update: function () {
                        var untrip = [];
                        for (var trigger of this.triggerChecks) {
                            if (this.triggered.includes(trigger.name)) {
                                if (trigger.passive) trigger.passive();
                                if (trigger.stop && trigger.stop()) {
                                    if (trigger.untrip) trigger.untrip();
                                    untrip.push(trigger.name);
                                }
                                continue;
                            }
                            if (trigger.check()) {
                                this.triggered.push(trigger.name);
                                if (trigger.trip) trigger.trip();
                            }
                        }
                        this.triggered = this.triggered.filter(e => !untrip.includes(e));
                        for (var trigger of this.triggerChecks) {
                            if (this.triggered.includes(trigger.name)) {
                                if (trigger.passive) trigger.passive();
                            }
                        }
                    }
                }
            }
        }

        function drawRotatingCube(data) {
            var s = data.size || 30;
            var vertices = [
                { x: -s, y: -s, z: -s },
                { x: s, y: -s, z: -s },
                { x: s, y: s, z: -s },
                { x: -s, y: s, z: -s },
                { x: -s, y: -s, z: s },
                { x: s, y: -s, z: s },
                { x: s, y: s, z: s },
                { x: -s, y: s, z: s }
            ];
            var angle = data.zAngle || 0;
            for (var o of vertices) {
                var x = o.x * Math.cos(angle) - o.y * Math.sin(angle);
                var y = o.x * Math.sin(angle) + o.y * Math.cos(angle);
                o.x = x;
                o.y = y;
            }
            var angle = data.xAngle || 0;
            for (var o of vertices) {
                var y = o.y * Math.cos(angle) - o.z * Math.sin(angle);
                var z = o.y * Math.sin(angle) + o.z * Math.cos(angle);
                o.y = y;
                o.z = z;
            }
            var angle = data.yAngle || 0;
            for (var o of vertices) {
                var x = o.z * Math.sin(angle) + o.x * Math.cos(angle);
                var z = o.z * Math.cos(angle) - o.x * Math.sin(angle);
                o.x = x;
                o.z = z;
            }
            var edges = [
                [0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [1, 5], [2, 6], [3, 7]
            ];
            var faces = [
                [0, 1, 2, 3], [4, 5, 6, 7], [2, 3, 7, 6], [0, 1, 5, 4], [1, 2, 6, 5], [0, 3, 7, 4]
            ];
            var faceCoordinates = [];
            var faceZValues = [];
            for (var face of faces) {
                var point1 = vertices[face[0]];
                var point2 = vertices[face[1]];
                var point3 = vertices[face[2]];
                var point4 = vertices[face[3]];
                var avgX = (point1.x + point2.x + point3.x + point4.x) / 4;
                var avgY = (point1.y + point2.y + point3.y + point4.y) / 4;
                var avgZ = (point1.z + point2.z + point3.z + point4.z) / 4;
                faceZValues.push(avgZ);
                faceCoordinates.push({ x: avgX, y: avgY, z: avgZ });
            }
            var sortedZValues = [...faceZValues].sort((a, b) => b - a);
            var faceOrder = [];
            for (var n = 0; n < faceZValues.length; n++) {
                var e = faceZValues[n];
                var order = sortedZValues.indexOf(e);
                while (faceOrder.includes(order)) order++;
                faceOrder.push(order);
            }
            ctx.strokeStyle = "black";
            if (data.grey) {
                if (data.red) {
                    ctx.strokeStyle = "rgb(220,130,130)";
                } else {
                    ctx.strokeStyle = "rgb(150,150,255)";
                }
            }
            ctx.lineWidth = 8;
            ctx.lineCap = "round";

            for (var edge of edges) {
                if (data.border === false) break;
                ctx.beginPath();
                ctx.moveTo(vertices[edge[0]].x, vertices[edge[0]].y);
                ctx.lineTo(vertices[edge[1]].x, vertices[edge[1]].y);
                if (data.dashedBorder) {
                    ctx.lineWidth = 4;
                    var dist = distTo(vertices[edge[0]].x, vertices[edge[0]].y, vertices[edge[1]].x, vertices[edge[1]].y);
                    ctx.setLineDash([dist * 0.2, dist * 0.6]);
                }
                ctx.stroke();
            }
            if (data.grey) {
                ctx.globalAlpha = 0.3;
            }
            for (var n = faceOrder.length - 3; n < faceOrder.length; n++) {
                var index = faceOrder.indexOf(n);
                var face = faces[index];
                var position = faceCoordinates[index];
                var x = (position.x + 50) / 100;
                var y = (position.y + 50) / 100;
                var z = (position.z + 50) / 100;
                ctx.fillStyle = data.colorFunction(x, y, z, n);
                ctx.beginPath();
                ctx.moveTo(vertices[face[0]].x, vertices[face[0]].y);
                ctx.lineTo(vertices[face[1]].x, vertices[face[1]].y);
                ctx.lineTo(vertices[face[2]].x, vertices[face[2]].y);
                ctx.lineTo(vertices[face[3]].x, vertices[face[3]].y);
                ctx.fill();
            }
        }

        var noise = function (x, y, z) {
            function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            function lerp(t, a, b) { return a + t * (b - a); }
            function grad(hash, x, y, z) {
                var h = hash & 15;
                var u = h < 8 ? x : y,
                    v = h < 4 ? y : h == 12 || h == 14 ? x : z;
                return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);
            }
            function scale(n) { return (1 + n) / 2; }

            var p = new Array(512)
            var permutation = [151, 160, 137, 91, 90, 15,
                131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23,
                190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
                88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166,
                77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
                102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
                135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
                5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
                223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9,
                129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228,
                251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107,
                49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254,
                138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180
            ];
            for (var i = 0; i < 256; i++)
                p[256 + i] = p[i] = permutation[i];

            var X = Math.floor(x) & 255,
                Y = Math.floor(y) & 255,
                Z = Math.floor(z) & 255;
            x -= Math.floor(x);
            y -= Math.floor(y);
            z -= Math.floor(z);
            var u = fade(x),
                v = fade(y),
                w = fade(z);
            var A = p[X] + Y, AA = p[A] + Z, AB = p[A + 1] + Z,
                B = p[X + 1] + Y, BA = p[B] + Z, BB = p[B + 1] + Z;

            return scale(lerp(w, lerp(v, lerp(u, grad(p[AA], x, y, z),
                grad(p[BA], x - 1, y, z)),
                lerp(u, grad(p[AB], x, y - 1, z),
                    grad(p[BB], x - 1, y - 1, z))),
                lerp(v, lerp(u, grad(p[AA + 1], x, y, z - 1),
                    grad(p[BA + 1], x - 1, y, z - 1)),
                    lerp(u, grad(p[AB + 1], x, y - 1, z - 1),
                        grad(p[BB + 1], x - 1, y - 1, z - 1)))));
        }

        function createTimeText(time) {
            var milliseconds = time % 100 + "";
            if (milliseconds.length < 2) milliseconds = "0" + milliseconds;
            var seconds = Math.floor(time / 100) % 60 + "";
            if (seconds.length < 2 && time >= 6000) seconds = "0" + seconds;
            if (time < 6000) return `${seconds}.${milliseconds}`;
            var minutes = Math.floor(time / 6000) % 60 + "";
            if (minutes.length < 2 && time >= 360000) minutes = "0" + minutes;
            if (time < 360000) return `${minutes}:${seconds}.${milliseconds}`;
            var hours = Math.floor(time / 360000);
            return `${hours}:${minutes}:${seconds}.${milliseconds}`;
        }

        function pointInBox(x, y, box) {
            return x >= box.x && y >= box.y && x <= box.x + box.w && y <= box.y + box.h;
        }

        var saveData = false;
        var saveDataStored = false;
        if (localStorage.getItem("oppositeday2savedata") !== null) {
            saveData = JSON.parse(localStorage.getItem("oppositeday2savedata"));
            saveData.redCubesCollected = saveData.redCubesCollected || [];
            saveData.redCubesDiscovered = saveData.redCubesDiscovered || [];
            saveData.shortcutsDiscovered = saveData.shortcutsDiscovered || [];
            saveData.shortcutsTaken = saveData.shortcutsTaken || [];
            saveData.blueCubesCollected = saveData.blueCubesCollected || [];
            saveData.levelsBeaten = saveData.levelsBeaten || 0;
            saveData.time = saveData.time || 0;
            saveData.bestLevelSplits = saveData.bestLevelSplits || [];
            game.ui.timer.gameTime = saveData.time;
            saveDataStored = true;
            if (saveData.johnbutlergames) johnbutlergames = true;
            if (saveData.notobiv) notobiv = true;
            if (saveData.ppougjgaming) ppougjgaming = true;
            if (saveData.kribit) kribit = true;
        }

        function updateSaveData() {
            saveData.time = game.ui.timer.gameTime;
            saveData.johnbutlergames = johnbutlergames;
            saveData.ppougjgaming = ppougjgaming;
            saveData.notobiv = notobiv;
            saveData.kribit = kribit;
            saveData.larrythehamster = larrythehamster;
            localStorage.setItem("oppositeday2savedata", JSON.stringify(saveData));
            saveDataStored = true;
        }

        function deleteSaveData() {
            localStorage.removeItem("oppositeday2savedata");
            saveDataStored = false;
        }

        ctx.save();
        ctx.globalAlpha = 0;
        ctx.font = "1px rubik";
        ctx.fillText("0", 0, 0);
        ctx.font = "1px rubikbold";
        ctx.fillText("0", 0, 0);
        ctx.font = "1px rubikitalic";
        ctx.fillText("0", 0, 0);
        ctx.font = "1px rubikbolditalic";
        ctx.fillText("0", 0, 0);
        ctx.restore();

        var betaTesters = [
            "Notobiv",
            "Thomas Butler",
            "Kribit",
            "Kate Butler",
            "Oliver Butler",
            "Simon Butler",
            "Haven Wenzel",
            "ppougj Gaming",
            "God NTSC Player",
            "Ty Cirino",
            "Braxton McFarland",
            "Pompelo",
            "Annoying Dog",
            "Larry the Hamster",
            "Matt Quinn",
            "Josiah Sage",
            "James Butler",
            "CarsonPlay2",
            "Sharon Butler",
            "Dakota Reinikka",
            "Adrian Falcon",
            "Matthew Ritchey",
            "Okman241",
            "Mosh",
            "Qatt",
            "Jakem",
            "Arctic",
            "Dxtr",
            "Brain Washed",
            "GHY",
            "Kabez",
            "Jbg Goat"
        ];

        /*menu.titleScreen = 0;
        menu.titleScreenAnimation = 0;
        game.newGame();
        Loading.intro = false;
        Loading.loaded = true;
        /*
        To Do:
        Red cube level 10
        Red cube level 9
        Level 8 pointless collectable
        Add UI:
        Escape
        Restart
        Add Options Menu:
        Keybinds
        Sound/Music Volume

        Music:
        Menu Theme
        Main Theme
        Sound Effects:
        UI
        Pacman Death
        Snake Turns
        Snake Eat Apple
        Lvl 10 win

        Sell

        Stats page
        Music:
        Shortcut Theme
        Red Cube Theme
        Blue Cube Theme

        Content Update:
        Level 3 tesseract
        Level 6 tesseract
        Level 8 tesseract
        Level 9 tesseract
        Welcome to Hell
        Coin Dash
        */

        var bot = "0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 0111 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1000 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 1010 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1000 1000 0011 0101 0101 0101 0110 0101 0101 0101 0101 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110 0110";
        bot = false;
    </script>
</body>

</html>