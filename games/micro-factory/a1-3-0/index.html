<!DOCTYPE HTML>
<html>

<body>
    <canvas id="canvas"></canvas>
    <script src="https://johnbutlergames.w3spaces.com/game-setup.js"></script>
    <script>
        var title = "Micro Factory";
        var dimensions = { width: 1500, height: 1000 };
        var images = {};
        var audios = {};

        initialize();
        Loading.loaded = true;
        Loading.intro = 0;
        window.setInterval(update, 10);
        var t = 0;

        function main() {
            menu.tick();
            t++;
        }

        var menu = {
            page: "game",
            switchPage: "game",
            switchPageAnimation: 0,
            switchPageAnimationThreshold: 70,
            titleScreenAnimation: 0,
            tick: function () {
                this.update();
                this.draw();
            },
            update: function () {
                if (this.page != this.switchPage) {
                    this.switchPageAnimation++;
                    if (this.switchPageAnimation >= this.switchPageAnimationThreshold) {
                        this.page = this.switchPage;
                    }
                } else {
                    if (this.switchPageAnimation > 0) {
                        this.switchPageAnimation--;
                    }
                    if (this.switchPageAnimation < 0) {
                        this.switchPageAnimation = 0;
                    }
                    this.userInteractions(this.page);
                }
                this.updatePage(this.page);
            },
            draw: function () {
                this.drawPage(this.page);

                if (this.switchPageAnimation) {
                    var a = this.switchPageAnimation / this.switchPageAnimationThreshold;
                }
            },
            userInteractions: function (page) {
                if (page == "title screen") {
                    this.titleScreenButtons();
                } else if (page == "game") {
                    game.update();
                } else if (page == "tutorial") {
                    tutorial.update();
                }
            },
            drawPage: function (page) {
                if (page == "title screen") {
                    this.drawTitleScreen();
                } else if (page == "game") {
                    game.draw();
                } else if (page == "tutorial") {
                    tutorial.draw();
                }
            },
            updatePage: function (page) {
                if (page == "title screen") {
                    this.updateTitleScreen();
                } else if (page == "game") {
                    game.updateEffects();
                } else if (page == "tutorial") {
                    tutorial.updateEffects();
                } else if (page == "new game") {
                    this.page = "game";
                    this.switchPage = "game";
                    game.reset();
                }
            },
            drawTitleScreen: function () {
                var a = this.titleScreenAnimation;
            },
            updateTitleScreen: function () {
                this.titleScreenAnimation++;
            },
            titleScreenButtons: function () {
                var a = this.titleScreenAnimation;
            },
            resetTitleScreen: function () {
            }
        }

        var game = {
            mode: "editing",
            update: function () {
                this.background.update();
                this.objects.update();
                this.level.update();
                this.cam.update();
                this.editing.update();
                this.playback.update();
                this.updateMode();
            },
            updateEffects: function () {
            },
            draw: function () {
                this.background.draw();

                ctx.save();
                this.cam.viewport.align();
                this.objects.draw();
                this.editing.draw();
                this.level.boundary.draw();
                ctx.restore();

                this.editing.ui.draw();
                this.playback.ui.draw();
            },
            reset: function () {
                this.editing.reset();
                this.playback.reset();
                this.setEditingMode();
            },
            keys: {
                action: function (label, type) {
                    var keys = this[label];
                    for (var key of keys) {
                        if (typeof key == "number") {
                            if (Keys.keys[17]) return false;
                            if (Keys.keys[16]) return false;
                            if (Keys[type][key]) return true;
                        } else {
                            if (key.ctrl && !Keys.keys[17]) return false;
                            if (key.shift && !Keys.keys[16]) return false;
                            if (Keys[type][key.key]) return true;
                        }
                    }
                    return false;
                },
                panCamLeft: [37, 65],
                panCamRight: [39, 68],
                panCamUp: [38, 87],
                panCamDown: [40, 83],
                zoomCamIn: [90],
                zoomCamOut: [88],
                rotateClockwise: [82],
                rotateCounterclockwise: [69],
                undo: [{ ctrl: true, key: 90 }],
                redo: [{ ctrl: true, shift: true, key: 90 }],
                cut: [{ ctrl: true, key: 88 }],
                copy: [{ ctrl: true, key: 67 }],
                delete: [8, 46],
                playbackMode: [32],
                editMode: [27],
                pause: [32]
            },
            updateMode: function () {
                if (this.mode == "editing") {
                    if (!this.editing.editingMode || this.playback.playbackMode) this.setEditingMode();
                } else if (this.mode == "playback") {
                    if (this.editing.editingMode || !this.playback.playbackMode) this.setPlaybackMode();
                }
            },
            setEditingMode: function () {
                this.editing.editingMode = true;
                this.playback.playbackMode = false;
                this.playback.resetObjectsToSource();
                this.editing.selection.clearSelection();
                this.editing.selection.tooltip.visible = false;
            },
            setPlaybackMode: function () {
                this.editing.editingMode = false;
                this.playback.playbackMode = true;
                this.playback.resetSource();
                this.playback.reset();
                this.objects.initializePlayback();
            },
            background: {
                update: function () {
                },
                draw: function () {
                    ctx.fillStyle = "rgb(200,200,200)";
                    ctx.fillRect(0, 0, 1500, 1000);

                    ctx.save();
                    game.cam.viewport.align();
                    var backgroundTiles = [];
                    var vx = Math.floor(game.cam.viewport.x / 100) * 100 - 100;
                    var vy = Math.floor(game.cam.viewport.y / 100) * 100 - 100;
                    var vw = Math.ceil(game.cam.viewport.w / 100) * 100 + 200;
                    var vh = Math.ceil(game.cam.viewport.h / 100) * 100 + 200;
                    /*for (var x = vx; x < vx + vw; x += 100) {
                        for (var y = vy; y < vy + vh; y += 100) {
                            backgroundTiles.push({ x: x, y: y, w: 100, h: 100 });
                        }
                        for (var o of backgroundTiles) {
                            ctx.strokeStyle = "black";
                            ctx.lineWidth = 1;
                            ctx.strokeRect(o.x, o.y, o.w, o.h);
                        }
                    }*/
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = "black";
                    for (var x = vx; x < vx + vw; x += 100) {
                        ctx.beginPath();
                        ctx.moveTo(x, vy);
                        ctx.lineTo(x, vy + vh);
                        ctx.stroke();
                    }
                    for (var y = vy; y < vy + vh; y += 100) {
                        ctx.beginPath();
                        ctx.moveTo(vx, y);
                        ctx.lineTo(vx + vw, y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            },
            objects: {
                objects: [],
                animatedObjects: [],
                emptyGroupObject: { wire: [], piston: [], element: [], emitter: [], activator: [] },
                update: function () {
                },
                tick: function () {
                    var groups = JSON.parse(JSON.stringify(this.emptyGroupObject));
                    for (var o of this.objects) {
                        if (!groups[o.type]) groups[o.type] = [];
                        groups[o.type].push(o);
                    }
                    this.updateWires(groups);
                    this.updatePistons(groups);
                    this.updateElements(groups);
                },
                updateWires: function (groups) {
                    var wireGroups = this.createWireGroups(groups);
                    var activeCors = this.updateWireActivity(groups, wireGroups);
                },
                updateWireActivity: function (groups, wireGroups) {
                    var activeCors = [];
                    for (var o of groups.emitter) {
                        //if (!o.active) continue;
                        for (var x = -100; x <= 100; x += 100) {
                            for (var y = -100; y <= 100; y += 100) {
                                if (activeCors.findIndex(e => e.x == o.x + x && e.y == o.y + y) != -1) continue;
                                activeCors.push({ x: o.x + x, y: o.y + y });
                            }
                        }
                    }
                    for (var group of wireGroups) {
                        var powered = false;
                        for (var id of group) {
                            var o = groups.wire[id];
                            if (!activeCors.some(e => e.x == o.x && e.y == o.y)) continue;
                            powered = true;
                            break;
                        }
                        if (!powered) continue;
                        for (var id of group) {
                            var o = groups.wire[id];
                            o.powered = true;
                        }
                    }
                    var newActiveCors = [];
                    var change = true;
                    while (change) {
                        change = false;

                    }
                    return activeCors;
                },
                createWireGroups: function (groups) {
                    var wireGroups = [];
                    for (var n = 0; n < groups.wire.length; n++) {
                        var o = groups.wire[n];
                        o.powered = false;
                        wireGroups.push([n]);
                        o.group = wireGroups.length - 1;
                    }
                    var change = true;
                    while (change) {
                        change = false;
                        for (var n = 0; n < groups.wire.length; n++) {
                            var o = groups.wire[n];
                            for (var n2 = n + 1; n2 < groups.wire.length; n2++) {
                                var o2 = groups.wire[n2];
                                var dist = distTo(o.x, o.y, o2.x, o2.y);
                                if (dist != 100) continue;
                                if (o.group == o2.group) continue;
                                change = true;
                                var index = o2.group;
                                var groupToMerge = wireGroups[index];
                                groupToMerge.forEach(function (e) {
                                    groups.wire[e].group = o.group;
                                });
                                groups.wire.forEach(function (e) {
                                    if (e.group < index) return;
                                    e.group--;
                                });
                                wireGroups.splice(index, 1);
                                wireGroups[o.group].push(...groupToMerge);
                            }
                        }
                    }
                    return wireGroups;
                },
                updatePistons: function (groups) {
                    for (var o of groups.piston) {
                        o.canPush = true;
                        o.force = distToMove(100, o.angle);
                        var checkCors = {
                            x: o.x + o.force.x,
                            y: o.y + o.force.y
                        };
                        var iterations = 0;
                        while (true) {
                            var list = this.objects.filter(e => e.x == checkCors.x && e.y == checkCors.y);
                            if (list.length == 0) break;
                            var tryingToPushImmovable = false;
                            for (var o2 of list) {
                                if (o2.type != "element" && o2.type != "conveyer") {
                                    tryingToPushImmovable = true;
                                    break;
                                }
                            }
                            if (tryingToPushImmovable) {
                                o.canPush = false;
                                break;
                            }
                            checkCors.x += o.force.x;
                            checkCors.y += o.force.y;
                            iterations++;
                        }
                        if (!o.canPush) continue;
                        if (iterations == 0) {
                            o.targetArea = { x: o.x + o.force.x, y: o.y + o.force.y, w: 100, h: 100 };
                            o.extensionArea = o.targetArea;
                            continue;
                        }
                        var x1 = o.x + o.force.x;
                        var y1 = o.y + o.force.y;
                        var x2 = checkCors.x - o.force.x;
                        var y2 = checkCors.y - o.force.y;
                        o.targetArea = {
                            x: Math.min(x1, x2),
                            y: Math.min(y1, y2),
                            w: Math.max(x1, x2) - Math.min(x1, x2) + 100,
                            h: Math.max(y1, y2) - Math.min(y1, y2) + 100
                        };
                        x2 += o.force.x;
                        y2 += o.force.y;
                        o.extensionArea = {
                            x: Math.min(x1, x2),
                            y: Math.min(y1, y2),
                            w: Math.max(x1, x2) - Math.min(x1, x2) + 100,
                            h: Math.max(y1, y2) - Math.min(y1, y2) + 100
                        };
                    }
                    var canPush = groups.piston.filter(e => e.canPush);
                    for (var n = 0; n < canPush.length; n++) {
                        var o = canPush[n];
                        for (var n2 = n + 1; n2 < canPush.length; n2++) {
                            var o2 = canPush[n2];
                            if (!blocksColliding(o.extensionArea, o2.extensionArea)) continue;
                            o.canPush = false;
                            o2.canPush = false;
                        }
                    }
                    for (var o of canPush) {
                        if (!o.canPush) continue;
                        o.targetObjects = this.objects.filter(function (e) {
                            return blocksColliding({ x: e.x, y: e.y, w: 100, h: 100 }, o.targetArea);
                        });
                    }
                    for (var o of canPush) {
                        if (!o.canPush) continue;
                        o.targetObjects.forEach(function (e) {
                            e.x += o.force.x;
                            e.y += o.force.y;
                        });
                    }
                },
                updateElements: function (groups) {
                },
                initializePlayback: function () {
                    var groups = JSON.parse(JSON.stringify(this.emptyGroupObject));
                    for (var o of this.objects) {
                        if (!groups[o.type]) groups[o.type] = [];
                        groups[o.type].push(o);
                    }
                },
                clearObjectsAtCoordinates: function (x, y) {
                    for (var n = 0; n < this.objects.length; n++) {
                        var o = this.objects[n];
                        if (x != o.x || y != o.y) continue;
                        this.objects.splice(n, 1);
                        n--;
                    }
                },
                draw: function () {
                    for (var n = 0; n < this.objects.length; n++) {
                        var o = this.objects[n];
                        this.drawObject(o);
                    }
                },
                drawObject: function (o) {
                    if (o.targetArea) {
                        ctx.fillStyle = "rgba(255,0,255,0.2)";
                        ctx.fillRect(o.targetArea.x, o.targetArea.y, o.targetArea.w, o.targetArea.h);
                        if (o.extensionArea) {
                            ctx.fillStyle = "rgba(255,0,0,0.2)";
                            ctx.fillRect(o.extensionArea.x, o.extensionArea.y, o.extensionArea.w, o.extensionArea.h);
                        }
                    }
                    ctx.save();
                    ctx.translate(o.x + 50, o.y + 50);
                    ctx.rotate(o.angle * Math.PI / 180);
                    this.drawObjectInPosition(o);
                    ctx.restore();
                },
                drawObjectInPosition: function (o) {
                    if (o.type == "piston") {
                        ctx.fillStyle = "green";
                        if (o.canPush) ctx.fillStyle = "blue";
                        ctx.fillRect(-40, -20, 80, 60);
                        ctx.fillRect(-20, -30, 40, 10);
                        ctx.fillRect(-40, -40, 80, 10);
                    } else if (o.type == "emitter") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-30, -30, 60, 60);
                        ctx.fillStyle = "blue";
                        ctx.fillRect(-20, -20, 40, 40);
                    } else if (o.type == "scanner") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-30, -30, 60, 60);
                        ctx.fillStyle = "blue";
                        ctx.beginPath();
                        ctx.arc(0, -20, 10, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.type == "delay") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-30, -30, 60, 60);
                        ctx.fillStyle = "white";
                        ctx.fillRect(-20, -20, 40, 40);
                        ctx.fillStyle = "blue";
                        ctx.fillRect(-20, 0, 40, 20);
                    } else if (o.type == "bonder") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-30, -30, 60, 60);
                        ctx.fillRect(-5, -50, 10, 20);
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 5;
                        ctx.strokeRect(-50, -250, 100, 200);
                    } else if (o.type == "producer") {
                        ctx.fillStyle = "grey";
                        ctx.beginPath();
                        ctx.arc(0, 0, 30, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillStyle = "black";
                        ctx.fillRect(-50, 0, 30, 50);
                        ctx.fillRect(20, 0, 30, 50);
                        ctx.fillRect(-50, 20, 100, 30);
                    } else if (o.type == "activator") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-30, -30, 60, 60);
                        ctx.fillRect(-10, -40, 20, 10);
                    } else if (o.type == "wire") {
                        ctx.fillStyle = "black";
                        if (o.powered) ctx.fillStyle = "blue";
                        ctx.fillRect(-10, -10, 20, 20);
                    } else if (o.type == "element") {
                        ctx.fillStyle = "red";
                        ctx.beginPath();
                        ctx.arc(0, 0, 40, 0, 2 * Math.PI);
                        ctx.fill();
                    } else if (o.type == "conveyer") {
                        ctx.fillStyle = "rgb(255,0,255)";
                        ctx.fillRect(-50, -50, 100, 100);
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.moveTo(-30, 30);
                        ctx.lineTo(0, -30);
                        ctx.lineTo(30, 30);
                        ctx.closePath();
                        ctx.fill();
                    } else if (o.type == "barrier") {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-50, -50, 100, 100);
                    }
                },
                create: function (o) {
                    var newObject = JSON.parse(JSON.stringify(o));
                    this.objects.push(newObject);
                }
            },
            playback: {
                playbackMode: false,
                paused: false,
                timeUntilTick: 0,
                tickReset: 50,
                source: [],
                update: function () {
                    this.ui.visible = this.playbackMode;
                    this.ui.update();
                    if (!this.playbackMode) return;
                    this.updateTick();
                },
                draw: function () {
                },
                resetSource: function () {
                    this.source = JSON.parse(JSON.stringify(game.objects.objects));
                },
                resetObjectsToSource: function () {
                    game.objects.objects = JSON.parse(JSON.stringify(this.source));
                },
                updateTick: function () {
                    var chosenSpeed = this.ui.speeds[this.ui.speedChosenId].frames;
                    this.tickReset = chosenSpeed;
                    if (!this.paused) this.timeUntilTick--;
                    this.timeUntilTick = Math.min(this.timeUntilTick, this.tickReset);
                    if (this.timeUntilTick <= 0) {
                        this.timeUntilTick = this.tickReset;
                        this.tick();
                    }
                },
                tick: function () {
                    game.objects.tick();
                },
                reset: function () {
                    this.paused = false;
                    this.timeUntilTick = this.tickReset;
                },
                ui: {
                    x: 750,
                    y: 925,
                    opacity: 0,
                    hitbox: { x: -200, y: -50, w: 400, h: 100 },
                    options: ["stop playback", "pause", "reset", "speed"],
                    speeds: [
                        { name: "0.1x", frames: 500 },
                        { name: "0.2x", frames: 250 },
                        { name: "0.5x", frames: 100 },
                        { name: "1x", frames: 50 },
                        { name: "2x", frames: 25 },
                        { name: "5x", frames: 10 },
                        { name: "10x", frames: 5 },
                        { name: "50x", frames: 1 }
                    ],
                    speedChosenId: 3,
                    visible: true,
                    update: function () {
                        this.updateOpacity();
                        if (!this.visible) return;
                        this.updateOptions();
                    },
                    draw: function () {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.globalAlpha = this.opacity;

                        ctx.fillStyle = "rgb(150,150,150)";
                        ctx.roundRect(-200, -50, 400, 100, 20);
                        ctx.fill();

                        this.drawOptions();

                        ctx.restore();
                    },
                    drawOptions: function () {
                        for (var n = 0; n < this.options.length; n++) {
                            var o = this.options[n];
                            ctx.save();
                            ctx.translate(-150 + n * 100, 0);
                            ctx.scale(0.7, 0.7);
                            this.drawOption(o);
                            ctx.restore();
                        }
                    },
                    drawOption: function (o) {
                        if (o == "stop playback") {
                            ctx.fillStyle = "red";
                            ctx.fillRect(-50, -50, 100, 100);
                            ctx.fillStyle = "black";
                            ctx.fillRect(-30, -30, 60, 60);
                        } else if (o == "pause") {
                            ctx.fillStyle = "orange";
                            ctx.fillRect(-50, -50, 100, 100);
                            ctx.fillStyle = "black";
                            if (game.playback.paused) {
                                ctx.beginPath();
                                ctx.moveTo(40, 0);
                                ctx.lineTo(-40, 40);
                                ctx.lineTo(-40, -40);
                                ctx.closePath();
                                ctx.fill();
                            } else {
                                ctx.fillRect(-40, -40, 30, 80);
                                ctx.fillRect(10, -40, 30, 80);
                            }
                        } else if (o == "reset") {
                            ctx.fillStyle = "yellow";
                            ctx.fillRect(-50, -50, 100, 100);
                            ctx.strokeStyle = "black";
                            ctx.lineWidth = 5;
                            ctx.beginPath();
                            ctx.arc(0, 0, 40, 0, 1.5 * Math.PI);
                            ctx.stroke();
                        } else if (o == "speed") {
                            ctx.fillStyle = "green";
                            ctx.fillRect(-50, -50, 100, 100);
                            ctx.fillStyle = "black";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.font = "40px Arial";
                            var speed = this.speeds[this.speedChosenId];
                            ctx.fillText(speed.name, 0, 0);
                        }
                    },
                    updateOptions: function () {
                        for (var n = 0; n < this.options.length; n++) {
                            var o = this.options[n];
                            var hitbox = {
                                x: this.x - 150 + n * 100 - 60 * 0.7,
                                y: this.y + 0 - 60 * 0.7,
                                w: 120 * 0.7,
                                h: 120 * 0.7
                            };
                            if (Mouse.clickInBox(hitbox.x, hitbox.y, hitbox.w, hitbox.h) || Keys.keys[49 + n]) {
                                this.executeOption(o);
                            }
                        }
                    },
                    executeOption: function (o) {
                        if (o == "stop playback") {
                            game.mode = "editing";
                        } else if (o == "pause") {
                            game.playback.paused = !game.playback.paused;
                        } else if (o == "reset") {
                            game.timeUntilTick = game.tickReset;
                            game.playback.resetObjectsToSource();
                        } else if (o == "speed") {
                            this.speedChosenId++;
                            this.speedChosenId %= this.speeds.length;
                        }
                    },
                    updateOpacity: function () {
                        if (!this.visible) {
                            this.opacity -= options.ui.opacityChange * 3;
                            this.opacity = Math.max(this.opacity, 0);
                            return;
                        }
                        if (this.mouseCloseToHitbox(50) && !game.editing.selection.creatingSelection) {
                            this.opacity += options.ui.opacityChange;
                        } else {
                            this.opacity -= options.ui.opacityChange;
                        }
                        this.opacity = Math.max(Math.min(this.opacity, 1), options.ui.opacityLowerBound);
                    },
                    mouseInHitbox: function () {
                        return Mouse.inBox(this.x + this.hitbox.x, this.y + this.hitbox.y, this.hitbox.w, this.hitbox.h);
                    },
                    mouseCloseToHitbox: function (distance) {
                        var hitbox = {};
                        hitbox.x = this.hitbox.x - distance;
                        hitbox.y = this.hitbox.y - distance;
                        hitbox.w = this.hitbox.w + distance * 2;
                        hitbox.h = this.hitbox.h + distance * 2;
                        return Mouse.inBox(this.x + hitbox.x, this.y + hitbox.y, hitbox.w, hitbox.h);
                    }
                }
            },
            editing: {
                creatingObject: {},
                mouseOffset: { x: 0, y: 0 },
                objectPlacementCors: { x: 0, y: 0 },
                objectPreviewCors: { x: 0, y: 0 },
                creatingObjectDimensions: { w: 0, h: 0 },
                canPlace: true,
                justPlaced: false,
                editingMode: true,
                history: [],
                redoBuffer: [],
                update: function () {
                    this.ui.visible = this.editingMode;
                    this.ui.update();
                    if (!this.editingMode) return;
                    this.updateUndoAndRedo();
                    this.updatePlacementRotation();
                    this.updatePlacementPosition();
                    this.canPlace = this.validatePlacement();
                    this.justPlaced = false;
                    this.updatePlacing();
                    this.selection.update();
                },
                draw: function () {
                    if (!this.editingMode) return;
                    if (this.selection.active) {
                        this.selection.draw();
                        return;
                    }
                    if (!this.canPlace) return;
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = "rgba(0,0,0,0.5)";
                    var x = this.objectPlacementCors.x;
                    var y = this.objectPlacementCors.y;
                    var w = this.creatingObjectDimensions.w;
                    var h = this.creatingObjectDimensions.h;
                    ctx.fillRect(x, y, w, h);

                    if (this.creatingObject.type == "paste data") {
                        ctx.save();
                        ctx.translate(this.objectPlacementCors.x, this.objectPlacementCors.y);
                        for (var n = 0; n < this.creatingObject.objects.length; n++) {
                            var o = this.creatingObject.objects[n];
                            game.objects.drawObject(o);
                        }
                        ctx.restore();
                    } else {
                        game.objects.drawObject(this.creatingObject);
                    }
                    ctx.restore();
                },
                reset: function () {
                    this.setCreatingObject(0);
                    this.opacity = this.opacityLowerBound;
                    this.justPlaced = false;
                    this.selection.reset();
                    this.resetHistory();
                },
                resetHistory: function () {
                    this.history = [];
                    this.addHistoryEntry();
                },
                addHistoryEntry() {
                    this.redoBuffer = [];
                    var entry = JSON.parse(JSON.stringify(game.objects.objects));
                    this.history.push(entry);
                },
                undo: function () {
                    if (this.history.length <= 1) return;
                    this.redoBuffer.push(this.history.pop());
                    game.objects.objects = JSON.parse(JSON.stringify(this.history[this.history.length - 1]));
                },
                redo: function () {
                    if (this.redoBuffer.length == 0) return;
                    this.history.push(this.redoBuffer.pop());
                    game.objects.objects = JSON.parse(JSON.stringify(this.history[this.history.length - 1]));
                },
                updateUndoAndRedo: function () {
                    if (game.keys.action("redo", "down")) {
                        this.redo();
                        this.selection.clearSelection();
                    } else if (game.keys.action("undo", "down")) {
                        this.undo();
                        this.selection.clearSelection();
                    }
                },
                updatePlacing: function () {
                    if (this.selection.active) return;
                    if (!this.canPlace) return;
                    var correctButton = Mouse.buttons[0] && !Mouse.buttons[1] && !Mouse.buttons[2];
                    var correctClickButton = Mouse.clickButtons[0] && !Mouse.clickButtons[1] && !Mouse.clickButtons[2];
                    if (this.creatingObject.type == "paste data") {
                        if (!correctClickButton) return;
                        this.placePasteData();
                    } else {
                        if (!correctClickButton) return;
                        this.placeRegular();
                    }
                    this.justPlaced = true;
                    this.addHistoryEntry();
                },
                placeRegular: function () {
                    var o = {};
                    game.objects.clearObjectsAtCoordinates(this.objectPlacementCors.x, this.objectPlacementCors.y)
                    for (var key of Object.keys(this.creatingObject)) {
                        o[key] = this.creatingObject[key];
                    }
                    o.x = this.objectPlacementCors.x;
                    o.y = this.objectPlacementCors.y;
                    this.placeObject(o);
                },
                placePasteData: function () {
                    var placedCoordinates = [];
                    for (var n = 0; n < this.creatingObject.objects.length; n++) {
                        var o = this.creatingObject.objects[n];
                        o.x += this.objectPlacementCors.x;
                        o.y += this.objectPlacementCors.y;
                        game.objects.clearObjectsAtCoordinates(o.x, o.y);
                        placedCoordinates.push({ x: o.x, y: o.y });
                        this.placeObject(o);
                    }
                    this.selection.selection = {
                        x: this.objectPlacementCors.x,
                        y: this.objectPlacementCors.y,
                        w: this.creatingObjectDimensions.w,
                        h: this.creatingObjectDimensions.h
                    };
                    this.selection.objectsSelected = [];
                    this.selection.objectsSelectedIds = [];
                    for (var n = 0; n < placedCoordinates.length; n++) {
                        var cors = placedCoordinates[n];
                        var id = game.objects.objects.findIndex(e => e.x == cors.x && e.y == cors.y);
                        if (id == -1) continue;
                        this.selection.objectsSelectedIds.push(id);
                        this.selection.objectsSelected.push(game.objects.objects[id]);
                    }
                    this.selection.finalizeSelection();
                    this.setCreatingObject(0);
                },
                placeObject: function (o) {
                    var hitbox = { x: o.x, y: o.y, w: 100, h: 100 };
                    if (!blocksColliding(hitbox, game.level.boundary)) return;
                    game.objects.create(o);
                },
                updatePlacementRotation: function () {
                    if (game.keys.action("rotateClockwise", "down")) {
                        this.rotatePlacement(90);
                    }
                    if (game.keys.action("rotateCounterclockwise", "down")) {
                        this.rotatePlacement(-90);
                    }
                },
                rotatePlacement: function (angle) {
                    if (this.creatingObject.type == "paste data") {
                        this.rotatePasteData(angle);
                    } else {
                        this.creatingObject.angle += angle;
                        this.creatingObject.angle = (this.creatingObject.angle % 360 + 360) % 360;
                    }
                },
                rotatePasteData: function (angle) {
                    var data = {};
                    data.x = 0;
                    data.y = 0;
                    data.w = this.creatingObjectDimensions.w;
                    data.h = this.creatingObjectDimensions.h;
                    data.objects = this.creatingObject.objects;
                    data = game.editing.rotateObjectData(angle, data);
                    this.creatingObjectDimensions.w = data.w;
                    this.creatingObjectDimensions.h = data.h;
                },
                updatePlacementPosition: function () {
                    var mouseX = game.cam.viewport.mouse.x + this.mouseOffset.x;
                    var mouseY = game.cam.viewport.mouse.y + this.mouseOffset.y;
                    this.objectPlacementCors.x = Math.floor(mouseX / 100) * 100;
                    this.objectPlacementCors.y = Math.floor(mouseY / 100) * 100;
                    var x = mouseX - Math.floor(mouseX / 100) * 100;
                    var y = mouseY - Math.floor(mouseY / 100) * 100;
                    var dist = distTo(50, 50, x, y);
                    var percent = 1 * ((dist / 50) ** 5);
                    percent = Math.min(percent, 1);
                    var targetX = (this.objectPlacementCors.x + 50) * (1 - percent) + game.cam.viewport.mouse.x * percent;
                    var targetY = (this.objectPlacementCors.y + 50) * (1 - percent) + game.cam.viewport.mouse.y * percent;
                    this.objectPreviewCors.x = targetX;
                    this.objectPreviewCors.y = targetY;
                    this.creatingObject.x = this.objectPreviewCors.x - 50;
                    this.creatingObject.y = this.objectPreviewCors.y - 50;
                },
                validatePlacement: function () {
                    if (this.ui.mouseInHitbox()) return false;
                    //var placementBox = { x: this.objectPlacementCors.x, y: this.objectPlacementCors.y, w: 100, h: 100 };
                    //if (!blocksColliding(placementBox, game.level.boundary)) return false;
                    return true;
                },
                setCreatingObject: function (n) {
                    this.ui.objectSelectedId = n;
                    this.creatingObject = this.ui.objects[this.ui.objectSelectedId];
                    this.creatingObjectDimensions = { w: 100, h: 100 };
                    this.creatingObject.angle = 0;
                    this.mouseOffset = { x: 0, y: 0 };
                    this.updatePlacementPosition();
                },
                rotateObjectData: function (angle, data) {
                    angle = (angle % 360 + 360) % 360;
                    if (angle == 0) return data;
                    if (angle == 90) {
                        return this.rotateObjectDataClockwise(data);
                    }
                    if (angle == 180) {
                        return this.rotateObjectDataClockwise(this.rotateObjectDataClockwise(data));
                    }
                    if (angle == 270) {
                        return this.rotateObjectDataClockwise(this.rotateObjectDataClockwise(this.rotateObjectDataClockwise(data)));
                    }
                },
                rotateObjectDataClockwise: function (data) {
                    for (var o of data.objects) {
                        o.x -= data.x;
                        o.y -= data.y;
                    }
                    for (var o of data.objects) {
                        o.angle += 90;
                        o.angle %= 360;
                        var x = o.x;
                        var y = o.y;
                        o.x = data.h - 100 - y;
                        o.y = x;
                    }
                    for (var o of data.objects) {
                        o.x += data.x;
                        o.y += data.y;
                    }
                    var w = data.w;
                    var h = data.h;
                    data.w = h;
                    data.h = w;
                    return data;
                },
                selection: {
                    active: false,
                    selectionStartCoordinates: false,
                    selectionEndCoordinates: false,
                    creatingSelection: false,
                    selection: false,
                    selectionFinalized: false,
                    objectsSelected: [],
                    objectsSelectedIds: [],
                    update: function () {
                        this.active = game.editing.creatingObject.type == "selection";
                        this.tooltip.update();
                        if (!this.active) {
                            this.clearSelection();
                            return;
                        }
                        var correctButton = Mouse.buttons[0] && !Mouse.buttons[1] && !Mouse.buttons[2];
                        if (Mouse.down && correctButton) {
                            var notUsingUI = !game.editing.ui.mouseInHitbox() && !this.tooltip.mouseInHitbox();
                            if (notUsingUI) this.selectionFinalized = false;
                            if (!this.creatingSelection && notUsingUI) this.startSelection();
                            if (this.creatingSelection) this.updateSelection();
                        } else {
                            if (this.creatingSelection) {
                                this.finalizeSelection();
                            }
                        }
                    },
                    draw: function () {
                        if (!this.selection) return;
                        for (var n = 0; n < this.objectsSelected.length; n++) {
                            var o = this.objectsSelected[n];
                            ctx.fillStyle = "rgba(0,0,255,0.35)";
                            ctx.fillRect(o.x, o.y, 100, 100);
                        }
                        if (this.selectionFinalized) {
                            ctx.fillStyle = "rgba(0,0,0,0.15)";
                            ctx.fillRect(this.selection.x, this.selection.y, this.selection.w, this.selection.h);
                            ctx.strokeStyle = "rgb(50,50,50)";
                            ctx.lineWidth = 10;
                            ctx.setLineDash([50, 50]);
                            ctx.lineDashOffset = t * 1.5;
                            ctx.strokeRect(this.selection.x, this.selection.y, this.selection.w, this.selection.h);
                            ctx.setLineDash([]);
                        } else {
                            ctx.fillStyle = "rgba(0,0,0,0.1)";
                            ctx.fillRect(this.selection.x, this.selection.y, this.selection.w, this.selection.h);
                        }
                    },
                    reset: function () {
                        this.active = false;
                        this.selectionStartCoordinates = false;
                        this.selectionEndCoordinates = false;
                        this.creatingSelection = false;
                        this.selection = false;
                        this.selectionFinalized = false;
                        this.objectsSelected = false;
                        this.objectsSelectedIds = false;
                        this.tooltip.reset();
                    },
                    updateSelection: function () {
                        this.selectionEndCoordinates = { x: game.editing.objectPlacementCors.x, y: game.editing.objectPlacementCors.y };
                        this.selection = this.createBoxFromPoints(this.selectionStartCoordinates, this.selectionEndCoordinates);
                        this.selection.w += 100;
                        this.selection.h += 100;

                        this.updateObjectsSelected();
                    },
                    updateObjectsSelected: function () {
                        this.objectsSelected = [];
                        this.objectsSelectedIds = [];
                        for (var n = 0; n < game.objects.objects.length; n++) {
                            var o = game.objects.objects[n];
                            var rect = { x: o.x, y: o.y, w: 100, h: 100 };
                            if (!blocksColliding(rect, this.selection)) continue;
                            this.objectsSelected.push(o);
                            this.objectsSelectedIds.push(n);
                        }
                    },
                    startSelection: function () {
                        this.selectionStartCoordinates = { x: game.editing.objectPlacementCors.x, y: game.editing.objectPlacementCors.y };
                        this.creatingSelection = true;
                    },
                    clearSelection: function () {
                        this.creatingSelection = false;
                        this.selection = false;
                        this.selectionFinalized = false;
                        this.selectionStartCoordinates = false;
                        this.selectionEndCoordinates = false;
                    },
                    createBoxFromPoints: function (p1, p2) {
                        var minX = Math.min(p1.x, p2.x);
                        var minY = Math.min(p1.y, p2.y);
                        var maxX = Math.max(p1.x, p2.x);
                        var maxY = Math.max(p1.y, p2.y);
                        var box = {};
                        box.x = minX;
                        box.y = minY;
                        box.w = maxX - minX;
                        box.h = maxY - minY;
                        return box;
                    },
                    finalizeSelection: function () {
                        if (this.objectsSelected.length == 0) {
                            this.clearSelection();
                            return;
                        }
                        this.selectionFinalized = true;
                        var minX = Math.min(...this.objectsSelected.map(e => e.x));
                        var minY = Math.min(...this.objectsSelected.map(e => e.y));
                        var maxX = Math.max(...this.objectsSelected.map(e => e.x)) + 100;
                        var maxY = Math.max(...this.objectsSelected.map(e => e.y)) + 100;
                        this.selection = { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
                        this.creatingSelection = false;
                    },
                    tooltip: {
                        visible: true,
                        x: 0,
                        y: 0,
                        rootCors: { x: 0, y: 0 },
                        opacity: 0,
                        hitbox: { x: 0, y: 0, w: 310, h: 75 },
                        options: ["clear", "copy", "move", "rotate clockwise", "rotate counterclockwise"],
                        optionSizes: [1, 1, 1, 1, 1],
                        update: function () {
                            this.visible = game.editing.selection.selectionFinalized;
                            if (!this.visible) {
                                this.optionsSizes = this.optionSizes.map(e => 1);
                                return;
                            }
                            this.updateOpacity();
                            this.setPosition();
                            if (!game.editing.justPlaced) this.updateOptions();
                            this.handleInput();
                        },
                        draw: function () {
                            if (!game.editing.editingMode) return;
                            if (!this.visible) return;
                            ctx.save();
                            ctx.globalAlpha = this.opacity;
                            ctx.translate(this.x, this.y);
                            ctx.fillStyle = "rgb(150,150,150)";
                            ctx.roundRect(0, 0, 310, 75, 20);
                            ctx.fill();

                            for (var n = 0; n < this.options.length; n++) {
                                var o = this.options[n];
                                ctx.save();
                                ctx.translate(n * 60 + 35, 37.5);
                                ctx.scale(this.optionSizes[n], this.optionSizes[n]);
                                this.drawOption(o);
                                ctx.restore();
                            }

                            ctx.restore();
                        },
                        reset: function () {
                            this.optionSizes = [1, 1, 1, 1, 1];
                        },
                        updateOptions: function () {
                            for (var n = 0; n < this.options.length; n++) {
                                var o = this.options[n];
                                var dist = distTo(this.x + this.hitbox.x + n * 60 + 35, this.y + this.hitbox.y + 37.5, Mouse.x, Mouse.y);
                                if (dist < 25) {
                                    this.optionSizes[n] += 0.03;
                                    if (Mouse.click) {
                                        this.performAction(o);
                                    }
                                } else {
                                    this.optionSizes[n] -= 0.03;
                                }
                                this.optionSizes[n] = Math.max(1, Math.min(this.optionSizes[n], 1.15));
                            }
                        },
                        handleInput: function () {
                            if (game.keys.action("delete", "down")) this.performAction("clear");
                            if (game.keys.action("copy", "down")) this.performAction("copy", true, false);
                            if (game.keys.action("cut", "down")) this.performAction("move", true, false);
                            if (game.keys.action("rotateClockwise", "down")) this.performAction("rotate clockwise", true, false);
                            if (game.keys.action("rotateCounterclockwise", "down")) this.performAction("rotate counterclockwise", true, false);
                        },
                        drawOption: function (o) {
                            if (o == "clear") {
                                ctx.fillStyle = "red";
                                ctx.fillRect(-20, -20, 40, 40);
                            } else if (o == "copy") {
                                ctx.strokeStyle = "black";
                                ctx.lineWidth = 3;
                                ctx.strokeRect(-20, -20, 40, 40);
                            } else if (o == "move") {
                                ctx.fillStyle = "black";
                                ctx.fillRect(-20, -20, 40, 40);
                            } else if (o == "rotate clockwise") {
                                ctx.fillStyle = "black";
                                ctx.fillRect(-20, -20, 40, 40);
                                ctx.fillStyle = "white";
                                ctx.fillRect(0, -20, 20, 20);
                            } else if (o == "rotate counterclockwise") {
                                ctx.fillStyle = "black";
                                ctx.fillRect(-20, -20, 40, 40);
                                ctx.fillStyle = "white";
                                ctx.fillRect(-20, -20, 20, 20);
                            }
                        },
                        performAction: function (o, clear, mouseOffset) {
                            if (o == "clear") {
                                var ids = game.editing.selection.objectsSelectedIds.sort((a, b) => b - a);
                                for (var n = 0; n < ids.length; n++) {
                                    game.objects.objects.splice(ids[n], 1);
                                }
                                game.editing.addHistoryEntry();
                            } else if (o == "copy") {
                                var data = {};
                                data.objects = [];
                                for (var n = 0; n < game.editing.selection.objectsSelected.length; n++) {
                                    var o = game.editing.selection.objectsSelected[n];
                                    var copy = JSON.parse(JSON.stringify(o));
                                    copy.x -= game.editing.selection.selection.x;
                                    copy.y -= game.editing.selection.selection.y;
                                    data.objects.push(copy);
                                }
                                data.type = "paste data";
                                game.editing.creatingObject = data;
                                game.editing.creatingObjectDimensions.w = game.editing.selection.selection.w;
                                game.editing.creatingObjectDimensions.h = game.editing.selection.selection.h;
                                if (mouseOffset !== false) {
                                    var viewportCors = game.cam.viewport.translateFromViewportCoordinates(this.rootCors);
                                    game.editing.mouseOffset.x = viewportCors.x - game.cam.viewport.mouse.x;
                                    game.editing.mouseOffset.y = viewportCors.y - game.cam.viewport.mouse.y;
                                }
                            } else if (o == "move") {
                                this.performAction("copy", false, mouseOffset);
                                this.performAction("clear");
                            } else if (o == "rotate clockwise") {
                                this.performAction("move", true, mouseOffset);
                                game.editing.rotatePasteData(90);
                            } else if (o == "rotate counterclockwise") {
                                this.performAction("move", true, mouseOffset);
                                game.editing.rotatePasteData(-90);
                            }
                            if (clear !== false) game.editing.selection.clearSelection();
                        },
                        setPosition: function () {
                            var x = game.editing.selection.selection.x;
                            var y = game.editing.selection.selection.y;
                            var cors = game.cam.viewport.translateToVieportCoordinates({ x: x, y: y });
                            this.rootCors = cors;
                            this.x = cors.x;
                            this.y = cors.y - this.hitbox.h - 10;

                            var buffer = 10;
                            this.x = Math.max(this.x, buffer);
                            this.y = Math.max(this.y, buffer);
                            this.x = Math.min(this.x, 1500 - this.hitbox.w - buffer);
                            this.y = Math.min(this.y, game.editing.ui.y + game.editing.ui.hitbox.y - this.hitbox.h - buffer);
                        },
                        updateOpacity: function () {
                            if (this.mouseCloseToHitbox(50)) {
                                this.opacity += options.ui.opacityChange;
                            } else {
                                this.opacity -= options.ui.opacityChange;
                            }
                            this.opacity = Math.max(Math.min(this.opacity, 1), options.ui.opacityLowerBound);
                        },
                        mouseInHitbox: function () {
                            return Mouse.inBox(this.x + this.hitbox.x, this.y + this.hitbox.y, this.hitbox.w, this.hitbox.h);
                        },
                        mouseCloseToHitbox: function (distance) {
                            var hitbox = {};
                            hitbox.x = this.hitbox.x - distance;
                            hitbox.y = this.hitbox.y - distance;
                            hitbox.w = this.hitbox.w + distance * 2;
                            hitbox.h = this.hitbox.h + distance * 2;
                            return Mouse.inBox(this.x + hitbox.x, this.y + hitbox.y, hitbox.w, hitbox.h);
                        }
                    }
                },
                ui: {
                    x: 750,
                    y: 925,
                    opacity: 0,
                    hitbox: { x: -510, y: -50, w: 910, h: 100 },
                    objectSelectedId: 0,
                    visible: true,
                    objects: [
                        {
                            type: "selection"
                        },
                        {
                            type: "piston"
                        },
                        {
                            type: "emitter"
                        },
                        {
                            type: "scanner"
                        },
                        {
                            type: "delay"
                        },
                        {
                            type: "conveyer"
                        },
                        {
                            type: "bonder"
                        },
                        {
                            type: "producer"
                        },
                        {
                            type: "wire"
                        },
                        {
                            type: "activator"
                        },
                        {
                            type: "barrier"
                        },
                        {
                            type: "element"
                        }
                    ],
                    update: function () {
                        this.updateOpacity();
                        if (!this.visible) return;
                        this.updateTool();
                        this.updatePlaybackButton();
                    },
                    draw: function () {
                        ctx.save();
                        ctx.translate(this.x, this.y);
                        ctx.globalAlpha = this.opacity;

                        this.drawPlaybackButton();
                        this.drawMainBody();
                        this.drawObjects();

                        ctx.restore();

                        game.editing.selection.tooltip.draw();
                    },
                    drawPlaybackButton: function () {
                        ctx.save();
                        ctx.translate(-470, 0);

                        ctx.fillStyle = "rgb(150,150,150)";
                        ctx.roundRect(-40, -40, 80, 80, 20);
                        ctx.fill();
                        ctx.fillStyle = "black";
                        ctx.beginPath();
                        ctx.moveTo(20, 0);
                        ctx.lineTo(-20, 20);
                        ctx.lineTo(-20, -20);
                        ctx.closePath();
                        ctx.fill();

                        ctx.restore();
                    },
                    drawMainBody: function () {
                        ctx.fillStyle = "rgb(150,150,150)";
                        ctx.roundRect(-400, -50, 800, 100, 20);
                        ctx.fill();
                    },
                    drawObjects: function () {
                        for (var n = 0; n < this.objects.length; n++) {
                            var o = this.objects[n];
                            ctx.save();
                            ctx.translate(-350 + n * 100, 0);
                            ctx.scale(0.7, 0.7);
                            if (o.type == "selection") {
                                this.drawSelectionIcon();
                            } else {
                                game.objects.drawObjectInPosition(o);
                            }
                            if (this.objectSelectedId == n) {
                                ctx.strokeStyle = "black";
                                ctx.lineWidth = 4;
                                ctx.lineJoin = "round";
                                ctx.strokeRect(-60, -60, 120, 120);
                            }
                            ctx.restore();
                        }
                    },
                    updateOpacity: function () {
                        if (!this.visible) {
                            this.opacity -= options.ui.opacityChange * 3;
                            this.opacity = Math.max(this.opacity, 0);
                            return;
                        }
                        if (this.mouseCloseToHitbox(50) && !game.editing.selection.creatingSelection) {
                            this.opacity += options.ui.opacityChange;
                        } else {
                            this.opacity -= options.ui.opacityChange;
                        }
                        this.opacity = Math.max(Math.min(this.opacity, 1), options.ui.opacityLowerBound);
                    },
                    updatePlaybackButton: function () {
                        var hitbox = {
                            x: this.x - 510,
                            y: this.y - 40,
                            w: 80,
                            h: 80
                        };
                        if (Mouse.clickInBox(hitbox.x, hitbox.y, hitbox.w, hitbox.h)) {
                            game.mode = "playback";
                        }
                    },
                    updateTool: function () {
                        for (var n = 0; n < this.objects.length; n++) {
                            var o = this.objects[n];
                            var hitbox = {
                                x: this.x - 350 + n * 100 - 60 * 0.7,
                                y: this.y + 0 - 60 * 0.7,
                                w: 120 * 0.7,
                                h: 120 * 0.7
                            };
                            if (Mouse.clickInBox(hitbox.x, hitbox.y, hitbox.w, hitbox.h) || Keys.keys[49 + n]) {
                                game.editing.setCreatingObject(n);
                            }
                        }
                    },
                    drawSelectionIcon: function () {
                        ctx.fillStyle = "black";
                        ctx.fillRect(-40, -40, 80, 80);
                    },
                    mouseInHitbox: function () {
                        return Mouse.inBox(this.x + this.hitbox.x, this.y + this.hitbox.y, this.hitbox.w, this.hitbox.h);
                    },
                    mouseCloseToHitbox: function (distance) {
                        var hitbox = {};
                        hitbox.x = this.hitbox.x - distance;
                        hitbox.y = this.hitbox.y - distance;
                        hitbox.w = this.hitbox.w + distance * 2;
                        hitbox.h = this.hitbox.h + distance * 2;
                        return Mouse.inBox(this.x + hitbox.x, this.y + hitbox.y, hitbox.w, hitbox.h);
                    }
                }
            },
            level: {
                update: function () {
                },
                boundary: {
                    x: -1500,
                    y: -1500,
                    w: 3000,
                    h: 3000,
                    draw: function () {
                        ctx.strokeStyle = "blue";
                        ctx.lineWidth = 5;
                        ctx.strokeRect(this.x, this.y, this.w, this.h);
                    }
                }
            },
            cam: {
                x: 0,
                y: 0,
                zoom: 1,
                realPosition: {
                    x: 0,
                    y: 0,
                    zoom: 1,
                },
                viewport: {
                    x: 0,
                    y: 0,
                    w: 0,
                    h: 0,
                    update: function () {
                        this.normalizeViewportToLevelBoundary();
                        this.setViewport();
                        this.mouse.update();
                    },
                    normalizeViewportToLevelBoundary: function () {
                        var zoomBuffer = 200;
                        var maxWidth = game.level.boundary.w + zoomBuffer * 2;
                        var maxHeight = game.level.boundary.h + zoomBuffer * 2;
                        var maxZoom = Math.min(1500 / maxWidth, 1000 / maxHeight);
                        game.cam.realPosition.zoom = Math.max(game.cam.realPosition.zoom, maxZoom);
                        game.cam.realPosition.zoom = Math.min(game.cam.realPosition.zoom, 3);

                        game.cam.realPosition.x = Math.max(game.cam.realPosition.x, game.level.boundary.x);
                        game.cam.realPosition.y = Math.max(game.cam.realPosition.y, game.level.boundary.y);
                        game.cam.realPosition.x = Math.min(game.cam.realPosition.x, game.level.boundary.x + game.level.boundary.w);
                        game.cam.realPosition.y = Math.min(game.cam.realPosition.y, game.level.boundary.y + game.level.boundary.h);
                    },
                    setViewport: function () {
                        var w = 1500 / game.cam.zoom;
                        var h = 1000 / game.cam.zoom;
                        var x = game.cam.x;
                        var y = game.cam.y;
                        this.x = x - w / 2;
                        this.y = y - h / 2;
                        this.w = w;
                        this.h = h;
                    },
                    mouse: {
                        x: 0,
                        y: 0,
                        update: function () {
                            var cors = game.cam.viewport.translateFromViewportCoordinates({ x: Mouse.x, y: Mouse.y });
                            this.x = cors.x;
                            this.y = cors.y;
                        }
                    },
                    translateFromViewportCoordinates: function ({ x: x, y: y }) {
                        x = (x - 750) / game.cam.zoom + game.cam.x;
                        y = (y - 500) / game.cam.zoom + game.cam.y;
                        return { x: x, y: y };
                    },
                    translateToVieportCoordinates: function ({ x: x, y: y }) {
                        x = (x - game.cam.x) * game.cam.zoom + 750;
                        y = (y - game.cam.y) * game.cam.zoom + 500;
                        return { x: x, y: y };
                    },
                    align: function () {
                        ctx.translate(750, 500);
                        ctx.scale(game.cam.zoom, game.cam.zoom);
                        ctx.translate(-game.cam.x, -game.cam.y);
                    }
                },
                update: function () {
                    this.handleInput();
                    this.viewport.update();
                    this.animatePosition();
                },
                animatePosition: function () {
                    var animateFactor = 0.1;
                    this.x = this.x * (1 - animateFactor) + this.realPosition.x * animateFactor;
                    this.y = this.y * (1 - animateFactor) + this.realPosition.y * animateFactor;
                    this.zoom = this.zoom * (1 - animateFactor) + this.realPosition.zoom * animateFactor;
                    if (Mouse.buttons[1]) {
                        this.x = this.realPosition.x;
                        this.y = this.realPosition.y;
                    }
                },
                handleInput: function () {
                    this.handleKeyboardInput();
                    this.handleMouseInput();
                },
                handleKeyboardInput: function () {
                    var movementSpeed = 15 / this.zoom;
                    var zoomSpeed = 1.02;
                    if (game.keys.action("panCamLeft", "keys")) {
                        this.realPosition.x -= movementSpeed;
                    }
                    if (game.keys.action("panCamRight", "keys")) {
                        this.realPosition.x += movementSpeed;
                    }
                    if (game.keys.action("panCamUp", "keys")) {
                        this.realPosition.y -= movementSpeed;
                    }
                    if (game.keys.action("panCamDown", "keys")) {
                        this.realPosition.y += movementSpeed;
                    }
                    if (game.keys.action("zoomCamIn", "keys")) {
                        this.realPosition.zoom *= zoomSpeed;
                    }
                    if (game.keys.action("zoomCamOut", "keys")) {
                        this.realPosition.zoom /= zoomSpeed;
                    }
                },
                handleMouseInput: function () {
                    this.realPosition.zoom -= Mouse.scrollY / 500 * this.realPosition.zoom;
                    if (Mouse.buttons[1]) {
                        this.realPosition.x -= Mouse.xmove / this.realPosition.zoom;
                        this.realPosition.y -= Mouse.ymove / this.realPosition.zoom;
                    }
                }
            }
        }

        var options = {
            ui: {
                opacityLowerBound: 0.6,
                opacityChange: 0.02
            }
        }

        game.reset();
        game.objects.objects = [
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -1100
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -1000
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -900
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -800
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -700
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -600
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -500
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -1100,
                "y": -400
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -600,
                "y": -900
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -600,
                "y": -800
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -600,
                "y": -700
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -600,
                "y": -600
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -600,
                "y": -500
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -500,
                "y": -500
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -400,
                "y": -500
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -300,
                "y": -500
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -200,
                "y": -500
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -200,
                "y": -400
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -200,
                "y": -300
            },
            {
                "type": "wire",
                "angle": 0,
                "x": -200,
                "y": -200
            },
            {
                "type": "wire",
                "angle": 0,
                "x": 600,
                "y": -700
            },
            {
                "type": "wire",
                "angle": 0,
                "x": 600,
                "y": -600
            },
            {
                "type": "wire",
                "angle": 0,
                "x": 700,
                "y": -600
            },
            {
                "type": "wire",
                "angle": 0,
                "x": 700,
                "y": -700
            },
            {
                "type": "wire",
                "angle": 0,
                "x": 400,
                "y": 200
            }
        ];

        /*
        TODO:
        Placement:
            Animations
            Keybind Prompts
            Clear Level
            Specialized Actions for Single Block Selection
        Playback:
            Keybinds
            Pause
            Play
            Step
            Animations
            Speed
            Reset
            Logic:
                Pistons
                Conveyers
                Producers
                Wires
        Level:
            Goal molecule
            First Levels
            Uneditables
        Blocks:
            Block Logic
            Tileset
        */
    </script>
</body>

</html>